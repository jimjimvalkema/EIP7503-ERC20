{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-b34f469bfeff0d075505cbfec18bef1fb79dc0a8",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PrivateTransferVerifier.sol": "project/contracts/PrivateTransferVerifier.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 20
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PrivateTransferVerifier.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec\npragma solidity >=0.8.21;\n\nuint256 constant N = 65536;\nuint256 constant LOG_N = 16;\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 52;\nuint256 constant VK_HASH = 0x1265946633a6ef657bfd84d786c46df67dc5980fb454c4653b34afe36124dd3d;\nlibrary HonkVerificationKey {\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\n            circuitSize: uint256(65536),\n            logCircuitSize: uint256(16),\n            publicInputsSize: uint256(52),\n            ql: Honk.G1Point({ \n               x: uint256(0x21b806eca3bc44e73b11d10e3ed3949d606f43aa65c4c07a8c07d8184f060c01),\n               y: uint256(0x04e04b2ad909afb68ba6388ededf41a454fe63d1b125657d68e824fc1a9cea8a)\n            }),\n            qr: Honk.G1Point({ \n               x: uint256(0x25b89d15df91ea3ff3f268dbb7467675e990944a9ebc3f02f85e19b62c61b5ff),\n               y: uint256(0x0d69f756e1a356ac0177a782d82d0fecacbe973645ffe3f7d171fcbc624146b7)\n            }),\n            qo: Honk.G1Point({ \n               x: uint256(0x0cbc4d0f8ad324c147d4c21382d7967b051b116411083f93d8e042d6b2ccf20e),\n               y: uint256(0x1866f793bddb14ec9e3297d017839454c24b999568e9ba425335f29e28387f06)\n            }),\n            q4: Honk.G1Point({ \n               x: uint256(0x0b207aa4e2286ca71f99d6bf26b0e4d5ad42fa44bb5deda6ead28b0e0ca843d9),\n               y: uint256(0x10eee41acdef4adf29a72b980e0b3d4306896365eec0ccb4c8420ba77320892f)\n            }),\n            qm: Honk.G1Point({ \n               x: uint256(0x1087d61522eae645e17b5647751cc72328078c8478dcd0d3ba6fa3d6483b35c9),\n               y: uint256(0x1e8fb65051fd869bb78519a72235a692f60cac1df81f9a2301c3b2feb4e6676b)\n            }),\n            qc: Honk.G1Point({ \n               x: uint256(0x01d436feaa4a608cd1553c95dec5a4c644c0219bc2f57487241c52764299e653),\n               y: uint256(0x0f9b7e777c8dc42d4e54e9de325c61d6ae205b206f06bfb8508786b062b324f0)\n            }),\n            qLookup: Honk.G1Point({ \n               x: uint256(0x108938900e390b27026fa24cbe8ec22e51ebdacf0d68806b312039c76025deac),\n               y: uint256(0x2c5be6773cafec40fdcb7f455e43a1fdf86e76cfa60f6a761f5cc0fb6cc40162)\n            }),\n            qArith: Honk.G1Point({ \n               x: uint256(0x0f8726088dccf9c9a814ca667f113c72ec84190787efb35ca5e9964995f13043),\n               y: uint256(0x0d0b44577fb17022355ccde6f7fdb4054f540fd7f03c839cfe3b7db869894c24)\n            }),\n            qDeltaRange: Honk.G1Point({ \n               x: uint256(0x220ac96bb06bc550210cf27e1b0ce05e0a36a15027a4142409c5c229f0f35e2f),\n               y: uint256(0x1e8269682842b916b676ff694f2320614c043f92ec21611c9a1f8a58eaa4ab5d)\n            }),\n            qElliptic: Honk.G1Point({ \n               x: uint256(0x0bc16dcf8aa408292086d2e6d605174ac9644bc11d3e8b1321554684ac19f8a9),\n               y: uint256(0x0dc5d77835ed8e296b25e6f1e032c686db31266ba282dcea5f23127f11e02a58)\n            }),\n            qMemory: Honk.G1Point({ \n               x: uint256(0x0efc9d046c377e018fc10c8a8a211d2ad3247bb3f6cd63d73e642f65e40cc971),\n               y: uint256(0x098a2e6b0aa48b220baaf908f925d2be1ee78bc023d0b6e9ccd402b7de76a0a1)\n            }),\n            qNnf: Honk.G1Point({ \n               x: uint256(0x1ff281d1396252e3b2337af55304cbb08b8c9c1c3913699579d048efb4320614),\n               y: uint256(0x28ed793b18de3fb38e87f539d5b18cbd5ec3554fdc0c54dd838beb85c313d451)\n            }),\n            qPoseidon2External: Honk.G1Point({ \n               x: uint256(0x26b9a3465f90d263191d6511e642153bdf1a60b1e8e0c6d30fcb241acf0f7936),\n               y: uint256(0x15223a178e784fafe5c5d4adb0a93e58ab0000a1b05a4ae897f6eb0ddfa3af7b)\n            }),\n            qPoseidon2Internal: Honk.G1Point({ \n               x: uint256(0x2b78178d7021f4dd912799afd9bd22d48baffd4f33e8c4aab19d792b639b7fed),\n               y: uint256(0x156ddd4986e0ff0e0ec67441235353857222071d9f236a87de341bbfb71fdd5c)\n            }),\n            s1: Honk.G1Point({ \n               x: uint256(0x297cc98ac85ba214a8116963fb422c5affbd189ac285a1e9db23bfaf5f33ab39),\n               y: uint256(0x082014ea4b8f97abbfac5e6b94f5d12cb6978c36324cd9c1db45441a30794a1a)\n            }),\n            s2: Honk.G1Point({ \n               x: uint256(0x1ab32d05e9497cc38e15e5416703aca9f7e92c86bc8d1708131b8e4fee9ba2fa),\n               y: uint256(0x1b3e00e0d8996e3bd44c643db2d3a90bb8beebcd3949db334d06548f214a7ab4)\n            }),\n            s3: Honk.G1Point({ \n               x: uint256(0x2f0552d7ace9c6d0fec5c1f74fdd18e416169b1df843e917027dfbb2d98d6153),\n               y: uint256(0x068f8057c6c0bd529ae0a431a13e00afaf6fe2148fd6cf68c6ad8f0d3733ed21)\n            }),\n            s4: Honk.G1Point({ \n               x: uint256(0x2466ee4964d5f34ba87e20691e6cfab3981d81ed7c2a1627b3b24f3e56d8f28e),\n               y: uint256(0x2cee001c12931788c356c62f1c48c524b8e01d1642bf7e673be6cfa8ce61da3f)\n            }),\n            t1: Honk.G1Point({ \n               x: uint256(0x21f2f5782a3a94aa5856f3eff751edb9e4120beb06d453a495050489262c4eea),\n               y: uint256(0x0373f2cead3e5ba2a446fb8df39b154858985706361a5b7aab453c9374326373)\n            }),\n            t2: Honk.G1Point({ \n               x: uint256(0x2a558493d752e5680e2edd6685c77245b1f54412e8bbee930c8b56e8aa8549db),\n               y: uint256(0x2675e9792827a98dd0b837b199a162e6a94d654384f9fc2e3127a27d11db9c4a)\n            }),\n            t3: Honk.G1Point({ \n               x: uint256(0x26ff8099fe3c6c76aaaf5488398b05c3341147bd295343830918272b6c83cb70),\n               y: uint256(0x249df185772ddd5da30be921487f07da456925980f685552aac0ba80afa5e6ed)\n            }),\n            t4: Honk.G1Point({ \n               x: uint256(0x14f7579237a207a828edb64cfa0284f0bef96341f659ae36e0099235a97370f0),\n               y: uint256(0x21b63c1e699dae239c9fc6c37965cf271d1d6b19d56625d8e7acee39ddb76e31)\n            }),\n            id1: Honk.G1Point({ \n               x: uint256(0x180a1f481a9aef3504b42cc676969c4efb8e43b1d73260acadbff21cfd66b9e0),\n               y: uint256(0x1c38cad1c8b3531aaa75ccd0175bdc12558fd238e997366e9338a00655895c62)\n            }),\n            id2: Honk.G1Point({ \n               x: uint256(0x26ed6c5f7b288ebd665935f18235b0c3d80d65486dbdfbff3833f275e0f6829c),\n               y: uint256(0x00998dfcf209a9057447f54e113ed79e75b943a5f57d3e716a13ac4b85c270e6)\n            }),\n            id3: Honk.G1Point({ \n               x: uint256(0x0bd6c45220d2c5696c6dcfe9af88ca76bacbdd657235b2a671690f95d93de1f3),\n               y: uint256(0x26b7049c9a207c1802b130f746664f845276e9e21f71d860c5ed871a0512ebf6)\n            }),\n            id4: Honk.G1Point({ \n               x: uint256(0x0b32ae3b149ccb2c63fb413997276307410c777ed838a8118b268734bd5c15eb),\n               y: uint256(0x0d1f939d393870ce5bc84659ca639be0372a8f43358106922ad7209ec25684c7)\n            }),\n            lagrangeFirst: Honk.G1Point({ \n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\n            }),\n            lagrangeLast: Honk.G1Point({ \n               x: uint256(0x1118a327c37b797629c1dda95672ed62847f967422b842931028c1a6a3e56f67),\n               y: uint256(0x2350eb90ee27628f4d68a9c75ed6b84affe67e3a930c5032c02c554610b5ecaa)\n            })\n        });\n        return vk;\n    }\n}\n\npragma solidity ^0.8.27;\n\ninterface IVerifier {\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external returns (bool);\n}\n\ntype Fr is uint256;\n\nusing {add as +} for Fr global;\nusing {sub as -} for Fr global;\nusing {mul as *} for Fr global;\n\nusing {exp as ^} for Fr global;\nusing {notEqual as !=} for Fr global;\nusing {equal as ==} for Fr global;\n\nuint256 constant SUBGROUP_SIZE = 256;\nuint256 constant MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\nuint256 constant P = MODULUS;\nFr constant SUBGROUP_GENERATOR = Fr.wrap(0x07b0c561a6148404f086204a9f36ffb0617942546750f230c893619174a57a76);\nFr constant SUBGROUP_GENERATOR_INVERSE = Fr.wrap(0x204bd3277422fad364751ad938e2b5e6a54cf8c68712848a692c553d0329f5d6);\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\nFr constant ONE = Fr.wrap(1);\nFr constant ZERO = Fr.wrap(0);\n// Instantiation\n\nlibrary FrLib {\n    function from(uint256 value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(value % MODULUS);\n        }\n    }\n\n    function fromBytes32(bytes32 value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(uint256(value) % MODULUS);\n        }\n    }\n\n    function toBytes32(Fr value) internal pure returns (bytes32) {\n        unchecked {\n            return bytes32(Fr.unwrap(value));\n        }\n    }\n\n    function invert(Fr value) internal view returns (Fr) {\n        uint256 v = Fr.unwrap(value);\n        uint256 result;\n\n        // Call the modexp precompile to invert in the field\n        assembly {\n            let free := mload(0x40)\n            mstore(free, 0x20)\n            mstore(add(free, 0x20), 0x20)\n            mstore(add(free, 0x40), 0x20)\n            mstore(add(free, 0x60), v)\n            mstore(add(free, 0x80), sub(MODULUS, 2)) \n            mstore(add(free, 0xa0), MODULUS)\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\n            if iszero(success) {\n                revert(0, 0)\n            }\n            result := mload(0x00)\n            mstore(0x40, add(free, 0x80))\n        }\n\n        return Fr.wrap(result);\n    }\n\n    function pow(Fr base, uint256 v) internal view returns (Fr) {\n        uint256 b = Fr.unwrap(base);\n        uint256 result;\n\n        // Call the modexp precompile to invert in the field\n        assembly {\n            let free := mload(0x40)\n            mstore(free, 0x20)\n            mstore(add(free, 0x20), 0x20)\n            mstore(add(free, 0x40), 0x20)\n            mstore(add(free, 0x60), b)\n            mstore(add(free, 0x80), v) \n            mstore(add(free, 0xa0), MODULUS)\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\n            if iszero(success) {\n                revert(0, 0)\n            }\n            result := mload(0x00)\n            mstore(0x40, add(free, 0x80))\n        }\n\n        return Fr.wrap(result);\n    }\n\n    function div(Fr numerator, Fr denominator) internal view returns (Fr) {\n        unchecked {\n            return numerator * invert(denominator);\n        }\n    }\n\n    function sqr(Fr value) internal pure returns (Fr) {\n        unchecked {\n            return value * value;\n        }\n    }\n\n    function unwrap(Fr value) internal pure returns (uint256) {\n        unchecked {\n            return Fr.unwrap(value);\n        }\n    }\n\n    function neg(Fr value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(MODULUS - Fr.unwrap(value));\n        }\n    }\n}\n\n// Free functions\nfunction add(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction mul(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction sub(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction exp(Fr base, Fr exponent) pure returns (Fr) {\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\n    // Implement exponent with a loop as we will overflow otherwise\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\n        base = base * base;\n    }\n    return base;\n}\n\nfunction notEqual(Fr a, Fr b) pure returns (bool) {\n    unchecked {\n        return Fr.unwrap(a) != Fr.unwrap(b);\n    }\n}\n\nfunction equal(Fr a, Fr b) pure returns (bool) {\n    unchecked {\n        return Fr.unwrap(a) == Fr.unwrap(b);\n    }\n}\n\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\n\nuint256 constant NUMBER_OF_SUBRELATIONS = 28;\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\nuint256 constant ZK_BATCHED_RELATION_PARTIAL_LENGTH = 9;\nuint256 constant NUMBER_OF_ENTITIES = 41;\nuint256 constant NUMBER_UNSHIFTED = 36;\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\nuint256 constant PAIRING_POINTS_SIZE = 16;\n\nuint256 constant FIELD_ELEMENT_SIZE = 0x20;\nuint256 constant GROUP_ELEMENT_SIZE = 0x40;\n\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\nuint256 constant NUMBER_OF_ALPHAS = NUMBER_OF_SUBRELATIONS - 1;\n\n// ENUM FOR WIRES\nenum WIRE {\n    Q_M,\n    Q_C,\n    Q_L,\n    Q_R,\n    Q_O,\n    Q_4,\n    Q_LOOKUP,\n    Q_ARITH,\n    Q_RANGE,\n    Q_ELLIPTIC,\n    Q_MEMORY,\n    Q_NNF,\n    Q_POSEIDON2_EXTERNAL,\n    Q_POSEIDON2_INTERNAL,\n    SIGMA_1,\n    SIGMA_2,\n    SIGMA_3,\n    SIGMA_4,\n    ID_1,\n    ID_2,\n    ID_3,\n    ID_4,\n    TABLE_1,\n    TABLE_2,\n    TABLE_3,\n    TABLE_4,\n    LAGRANGE_FIRST,\n    LAGRANGE_LAST,\n    W_L,\n    W_R,\n    W_O,\n    W_4,\n    Z_PERM,\n    LOOKUP_INVERSES,\n    LOOKUP_READ_COUNTS,\n    LOOKUP_READ_TAGS,\n    W_L_SHIFT,\n    W_R_SHIFT,\n    W_O_SHIFT,\n    W_4_SHIFT,\n    Z_PERM_SHIFT\n}\n\nlibrary Honk {\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct VerificationKey {\n        // Misc Params\n        uint256 circuitSize;\n        uint256 logCircuitSize;\n        uint256 publicInputsSize;\n        // Selectors\n        G1Point qm;\n        G1Point qc;\n        G1Point ql;\n        G1Point qr;\n        G1Point qo;\n        G1Point q4;\n        G1Point qLookup; // Lookup\n        G1Point qArith; // Arithmetic widget\n        G1Point qDeltaRange; // Delta Range sort\n        G1Point qMemory; // Memory\n        G1Point qNnf; // Non-native Field\n        G1Point qElliptic; // Auxillary\n        G1Point qPoseidon2External;\n        G1Point qPoseidon2Internal;\n        // Copy cnstraints\n        G1Point s1;\n        G1Point s2;\n        G1Point s3;\n        G1Point s4;\n        // Copy identity\n        G1Point id1;\n        G1Point id2;\n        G1Point id3;\n        G1Point id4;\n        // Precomputed lookup table\n        G1Point t1;\n        G1Point t2;\n        G1Point t3;\n        G1Point t4;\n        // Fixed first and last\n        G1Point lagrangeFirst;\n        G1Point lagrangeLast;\n    }\n\n    struct RelationParameters {\n        // challenges\n        Fr eta;\n        Fr etaTwo;\n        Fr etaThree;\n        Fr beta;\n        Fr gamma;\n        // derived\n        Fr publicInputsDelta;\n    }\n\n    struct Proof {\n        // Pairing point object\n        Fr[PAIRING_POINTS_SIZE] pairingPointObject;\n        // Free wires\n        G1Point w1;\n        G1Point w2;\n        G1Point w3;\n        G1Point w4;\n        // Lookup helpers - Permutations\n        G1Point zPerm;\n        // Lookup helpers - logup\n        G1Point lookupReadCounts;\n        G1Point lookupReadTags;\n        G1Point lookupInverses;\n        // Sumcheck\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\n        // Shplemini\n        G1Point[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\n        G1Point shplonkQ;\n        G1Point kzgQuotient;\n    }\n\n    struct ZKProof {\n        // Pairing point object\n        Fr[PAIRING_POINTS_SIZE] pairingPointObject;\n        // Commitments to wire polynomials\n        G1Point w1;\n        G1Point w2;\n        G1Point w3;\n        G1Point w4;\n        // Commitments to logup witness polynomials\n        G1Point lookupReadCounts;\n        G1Point lookupReadTags;\n        G1Point lookupInverses;\n        // Commitment to grand permutation polynomial\n        G1Point zPerm;\n        G1Point[3] libraCommitments;\n        // Sumcheck\n        Fr libraSum;\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\n        Fr libraEvaluation;\n        // ZK\n        G1Point geminiMaskingPoly;\n        Fr geminiMaskingEval;\n        // Shplemini\n        G1Point[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\n        Fr[4] libraPolyEvals;\n        G1Point shplonkQ;\n        G1Point kzgQuotient;\n    }\n}\n\n// ZKTranscript library to generate fiat shamir challenges, the ZK transcript only differest\nstruct ZKTranscript {\n    // Oink\n    Honk.RelationParameters relationParameters;\n    Fr[NUMBER_OF_ALPHAS] alphas;\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\n    // Sumcheck\n    Fr libraChallenge;\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\n    // Shplemini\n    Fr rho;\n    Fr geminiR;\n    Fr shplonkNu;\n    Fr shplonkZ;\n    // Derived\n    Fr publicInputsDelta;\n}\n\nlibrary ZKTranscriptLib {\n    function generateTranscript(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize,\n        uint256 logN\n    ) external pure returns (ZKTranscript memory t) {\n        Fr previousChallenge;\n        (t.relationParameters, previousChallenge) =\n            generateRelationParametersChallenges(proof, publicInputs, vkHash, publicInputsSize, previousChallenge);\n\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\n\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge, logN);\n        (t.libraChallenge, previousChallenge) = generateLibraChallenge(previousChallenge, proof);\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge, logN);\n\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\n\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge, logN);\n\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge, logN);\n\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\n        return t;\n    }\n\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        uint256 hi = challengeU256 >> 128;\n        first = FrLib.fromBytes32(bytes32(lo));\n        second = FrLib.fromBytes32(bytes32(hi));\n    }\n\n    function generateRelationParametersChallenges(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize,\n        Fr previousChallenge\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\n            generateEtaChallenge(proof, publicInputs, vkHash, publicInputsSize);\n\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\n    }\n\n    function generateEtaChallenge(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize\n    ) internal pure returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge) {\n        bytes32[] memory round0 = new bytes32[](1 + publicInputsSize + 6);\n        round0[0] = bytes32(vkHash);\n\n        for (uint256 i = 0; i < publicInputsSize - PAIRING_POINTS_SIZE; i++) {\n            round0[1 + i] = bytes32(publicInputs[i]);\n        }\n        for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n            round0[1 + publicInputsSize - PAIRING_POINTS_SIZE + i] = FrLib.toBytes32(proof.pairingPointObject[i]);\n        }\n\n        // Create the first challenge\n        // Note: w4 is added to the challenge later on\n        round0[1 + publicInputsSize] = bytes32(proof.w1.x);\n        round0[1 + publicInputsSize + 1] = bytes32(proof.w1.y);\n        round0[1 + publicInputsSize + 2] = bytes32(proof.w2.x);\n        round0[1 + publicInputsSize + 3] = bytes32(proof.w2.y);\n        round0[1 + publicInputsSize + 4] = bytes32(proof.w3.x);\n        round0[1 + publicInputsSize + 5] = bytes32(proof.w3.y);\n\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\n        (eta, etaTwo) = splitChallenge(previousChallenge);\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\n\n        (etaThree,) = splitChallenge(previousChallenge);\n    }\n\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\n    {\n        bytes32[7] memory round1;\n        round1[0] = FrLib.toBytes32(previousChallenge);\n        round1[1] = bytes32(proof.lookupReadCounts.x);\n        round1[2] = bytes32(proof.lookupReadCounts.y);\n        round1[3] = bytes32(proof.lookupReadTags.x);\n        round1[4] = bytes32(proof.lookupReadTags.y);\n        round1[5] = bytes32(proof.w4.x);\n        round1[6] = bytes32(proof.w4.y);\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\n    }\n\n    // Alpha challenges non-linearise the gate contributions\n    function generateAlphaChallenges(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\n    {\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\n        uint256[5] memory alpha0;\n        alpha0[0] = Fr.unwrap(previousChallenge);\n        alpha0[1] = proof.lookupInverses.x;\n        alpha0[2] = proof.lookupInverses.y;\n        alpha0[3] = proof.zPerm.x;\n        alpha0[4] = proof.zPerm.y;\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\n        Fr alpha;\n        (alpha,) = splitChallenge(nextPreviousChallenge);\n\n        // Compute powers of alpha for batching subrelations\n        alphas[0] = alpha;\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS; i++) {\n            alphas[i] = alphas[i - 1] * alpha;\n        }\n    }\n\n    function generateGateChallenges(Fr previousChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\n    {\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\n        (gateChallenges[0],) = splitChallenge(previousChallenge);\n        for (uint256 i = 1; i < logN; i++) {\n            gateChallenges[i] = gateChallenges[i - 1] * gateChallenges[i - 1];\n        }\n        nextPreviousChallenge = previousChallenge;\n    }\n\n    function generateLibraChallenge(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr libraChallenge, Fr nextPreviousChallenge)\n    {\n        // 2 comm, 1 sum, 1 challenge\n        uint256[4] memory challengeData;\n        challengeData[0] = Fr.unwrap(previousChallenge);\n        challengeData[1] = proof.libraCommitments[0].x;\n        challengeData[2] = proof.libraCommitments[0].y;\n        challengeData[3] = Fr.unwrap(proof.libraSum);\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(challengeData)));\n        (libraChallenge,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateSumcheckChallenges(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\n    {\n        for (uint256 i = 0; i < logN; i++) {\n            Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\n            univariateChal[0] = prevChallenge;\n\n            for (uint256 j = 0; j < ZK_BATCHED_RELATION_PARTIAL_LENGTH; j++) {\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\n            }\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\n\n            (sumcheckChallenges[i],) = splitChallenge(prevChallenge);\n        }\n        nextPreviousChallenge = prevChallenge;\n    }\n\n    // We add Libra claimed eval + 3 comm + 1 more eval\n    function generateRhoChallenge(Honk.ZKProof memory proof, Fr prevChallenge)\n        internal\n        pure\n        returns (Fr rho, Fr nextPreviousChallenge)\n    {\n        uint256[NUMBER_OF_ENTITIES + 9] memory rhoChallengeElements;\n        rhoChallengeElements[0] = Fr.unwrap(prevChallenge);\n        uint256 i;\n        for (i = 1; i <= NUMBER_OF_ENTITIES; i++) {\n            rhoChallengeElements[i] = Fr.unwrap(proof.sumcheckEvaluations[i - 1]);\n        }\n        rhoChallengeElements[i] = Fr.unwrap(proof.libraEvaluation);\n\n        i += 1;\n        rhoChallengeElements[i] = proof.libraCommitments[1].x;\n        rhoChallengeElements[i + 1] = proof.libraCommitments[1].y;\n        i += 2;\n        rhoChallengeElements[i] = proof.libraCommitments[2].x;\n        rhoChallengeElements[i + 1] = proof.libraCommitments[2].y;\n        i += 2;\n        rhoChallengeElements[i] = proof.geminiMaskingPoly.x;\n        rhoChallengeElements[i + 1] = proof.geminiMaskingPoly.y;\n\n        i += 2;\n        rhoChallengeElements[i] = Fr.unwrap(proof.geminiMaskingEval);\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\n        (rho,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateGeminiRChallenge(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr geminiR, Fr nextPreviousChallenge)\n    {\n        uint256[] memory gR = new uint256[]((logN - 1) * 2 + 1);\n        gR[0] = Fr.unwrap(prevChallenge);\n\n        for (uint256 i = 0; i < logN - 1; i++) {\n            gR[1 + i * 2] = proof.geminiFoldComms[i].x;\n            gR[2 + i * 2] = proof.geminiFoldComms[i].y;\n        }\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\n\n        (geminiR,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateShplonkNuChallenge(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\n    {\n        uint256[] memory shplonkNuChallengeElements = new uint256[](logN + 1 + 4);\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\n\n        for (uint256 i = 1; i <= logN; i++) {\n            shplonkNuChallengeElements[i] = Fr.unwrap(proof.geminiAEvaluations[i - 1]);\n        }\n\n        uint256 libraIdx = 0;\n        for (uint256 i = logN + 1; i <= logN + 4; i++) {\n            shplonkNuChallengeElements[i] = Fr.unwrap(proof.libraPolyEvals[libraIdx]);\n            libraIdx++;\n        }\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\n        (shplonkNu,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateShplonkZChallenge(Honk.ZKProof memory proof, Fr prevChallenge)\n        internal\n        pure\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\n    {\n        uint256[3] memory shplonkZChallengeElements;\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\n\n        shplonkZChallengeElements[1] = proof.shplonkQ.x;\n        shplonkZChallengeElements[2] = proof.shplonkQ.y;\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\n        (shplonkZ,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function loadProof(bytes calldata proof, uint256 logN) internal pure returns (Honk.ZKProof memory p) {\n        uint256 boundary = 0x0;\n\n        // Pairing point object\n        for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n            p.pairingPointObject[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n        // Commitments\n        p.w1 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w2 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w3 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n\n        // Lookup / Permutation Helper Commitments\n        p.lookupReadCounts = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.lookupReadTags = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w4 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.lookupInverses = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.zPerm = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.libraCommitments[0] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n\n        p.libraSum = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n        // Sumcheck univariates\n        for (uint256 i = 0; i < logN; i++) {\n            for (uint256 j = 0; j < ZK_BATCHED_RELATION_PARTIAL_LENGTH; j++) {\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n                boundary += FIELD_ELEMENT_SIZE;\n            }\n        }\n\n        // Sumcheck evaluations\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        p.libraEvaluation = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n\n        p.libraCommitments[1] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.libraCommitments[2] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.geminiMaskingPoly = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.geminiMaskingEval = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n\n        // Gemini\n        // Read gemini fold univariates\n        for (uint256 i = 0; i < logN - 1; i++) {\n            p.geminiFoldComms[i] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n            boundary += GROUP_ELEMENT_SIZE;\n        }\n\n        // Read gemini a evaluations\n        for (uint256 i = 0; i < logN; i++) {\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        for (uint256 i = 0; i < 4; i++) {\n            p.libraPolyEvals[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        // Shplonk\n        p.shplonkQ = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        // KZG\n        p.kzgQuotient = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n    }\n}\n\n// Field arithmetic libraries\n\nlibrary RelationsLib {\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\n\n    function accumulateRelationEvaluations(\n        Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\n        Fr powPartialEval\n    ) internal pure returns (Fr accumulator) {\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\n\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulateMemoryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateNnfRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\n\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\n    }\n\n    /**\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\n     * editors, and thus is noisy.\n     */\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\n        return p[uint256(_wire)];\n    }\n\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\n    /**\n     * Ultra Arithmetic Relation\n     *\n     */\n\n    function accumulateArithmeticRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        // Relation 0\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\n        {\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\n\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\n            accum = accum + (q_arith - ONE) * wire(p, WIRE.W_4_SHIFT);\n            accum = accum * q_arith;\n            accum = accum * domainSep;\n            evals[0] = accum;\n        }\n\n        // Relation 1\n        {\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\n            accum = accum * (q_arith - Fr.wrap(2));\n            accum = accum * (q_arith - ONE);\n            accum = accum * q_arith;\n            accum = accum * domainSep;\n            evals[1] = accum;\n        }\n    }\n\n    function accumulatePermutationRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr grand_product_numerator;\n        Fr grand_product_denominator;\n\n        {\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\n\n            grand_product_numerator = num;\n        }\n        {\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\n\n            grand_product_denominator = den;\n        }\n\n        // Contribution 2\n        {\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\n\n            acc = acc\n                - (\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\n                        * grand_product_denominator\n                );\n            acc = acc * domainSep;\n            evals[2] = acc;\n        }\n\n        // Contribution 3\n        {\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\n            evals[3] = acc;\n        }\n    }\n\n    function accumulateLogDerivativeLookupRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr write_term;\n        Fr read_term;\n\n        // Calculate the write term (the table accumulation)\n        {\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\n        }\n\n        // Calculate the write term\n        {\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\n\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\n        }\n\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\n\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\n\n        // Inverse calculated correctly relation\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\n        accumulatorNone = accumulatorNone * domainSep;\n\n        // Inverse\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\n\n        Fr read_tag = wire(p, WIRE.LOOKUP_READ_TAGS);\n\n        Fr read_tag_boolean_relation = read_tag * read_tag - read_tag;\n\n        evals[4] = accumulatorNone;\n        evals[5] = accumulatorOne;\n        evals[6] = read_tag_boolean_relation * domainSep;\n    }\n\n    function accumulateDeltaRangeRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr minus_one = ZERO - ONE;\n        Fr minus_two = ZERO - Fr.wrap(2);\n        Fr minus_three = ZERO - Fr.wrap(3);\n\n        // Compute wire differences\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\n\n        // Contribution 6\n        {\n            Fr acc = delta_1;\n            acc = acc * (delta_1 + minus_one);\n            acc = acc * (delta_1 + minus_two);\n            acc = acc * (delta_1 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[7] = acc;\n        }\n\n        // Contribution 7\n        {\n            Fr acc = delta_2;\n            acc = acc * (delta_2 + minus_one);\n            acc = acc * (delta_2 + minus_two);\n            acc = acc * (delta_2 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[8] = acc;\n        }\n\n        // Contribution 8\n        {\n            Fr acc = delta_3;\n            acc = acc * (delta_3 + minus_one);\n            acc = acc * (delta_3 + minus_two);\n            acc = acc * (delta_3 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[9] = acc;\n        }\n\n        // Contribution 9\n        {\n            Fr acc = delta_4;\n            acc = acc * (delta_4 + minus_one);\n            acc = acc * (delta_4 + minus_two);\n            acc = acc * (delta_4 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[10] = acc;\n        }\n    }\n\n    struct EllipticParams {\n        // Points\n        Fr x_1;\n        Fr y_1;\n        Fr x_2;\n        Fr y_2;\n        Fr y_3;\n        Fr x_3;\n        // push accumulators into memory\n        Fr x_double_identity;\n    }\n\n    function accumulateEllipticRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        EllipticParams memory ep;\n        ep.x_1 = wire(p, WIRE.W_R);\n        ep.y_1 = wire(p, WIRE.W_O);\n\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\n\n        Fr q_sign = wire(p, WIRE.Q_L);\n        Fr q_is_double = wire(p, WIRE.Q_M);\n\n        // Contribution 10 point addition, x-coordinate check\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n        Fr x_diff = (ep.x_2 - ep.x_1);\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\n        {\n            // Move to top\n            Fr partialEval = domainSep;\n\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\n            x_add_identity = x_add_identity * x_diff * x_diff;\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\n\n            evals[11] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (ONE - q_is_double);\n        }\n\n        // Contribution 11 point addition, x-coordinate check\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\n        {\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\n            evals[12] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (ONE - q_is_double);\n        }\n\n        // Contribution 10 point doubling, x-coordinate check\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\n        {\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\n\n            // NOTE: pushed into memory (stack >:'( )\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\n\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\n            evals[11] = evals[11] + acc;\n        }\n\n        // Contribution 11 point doubling, y-coordinate check\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\n        {\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\n            evals[12] = evals[12] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\n        }\n    }\n\n    // Parameters used within the Memory Relation\n    // A struct is used to work around stack too deep. This relation has alot of variables\n    struct MemParams {\n        Fr memory_record_check;\n        Fr partial_record_check;\n        Fr next_gate_access_type;\n        Fr record_delta;\n        Fr index_delta;\n        Fr adjacent_values_match_if_adjacent_indices_match;\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\n        Fr access_check;\n        Fr next_gate_access_type_is_boolean;\n        Fr ROM_consistency_check_identity;\n        Fr RAM_consistency_check_identity;\n        Fr timestamp_delta;\n        Fr RAM_timestamp_check_identity;\n        Fr memory_identity;\n        Fr index_is_monotonically_increasing;\n    }\n\n    function accumulateMemoryRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        MemParams memory ap;\n\n        /**\n         * MEMORY\n         *\n         * A RAM memory record contains a tuple of the following fields:\n         *  * i: `index` of memory cell being accessed\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\n         *  * v: `value` of memory cell being accessed\n         *  * a: `access` type of record. read: 0 = read, 1 = write\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\n         *\n         * A ROM memory record contains a tuple of the following fields:\n         *  * i: `index` of memory cell being accessed\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\n         *\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\n         *\n         *  | gate type | i  | v2/t  |  v | a  | r  |\n         *  | --------- | -- | ----- | -- | -- | -- |\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\n         *\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\n         * `w2` to fix its value)\n         *\n         *\n         */\n\n        /**\n         * Memory Record Check\n         * Partial degree: 1\n         * Total degree: 4\n         *\n         * A ROM/ROM access gate can be evaluated with the identity:\n         *\n         * qc + w1 \\eta + w2 \\eta_two + w3 \\eta_three - w4 = 0\n         *\n         * For ROM gates, qc = 0\n         */\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\n\n        /**\n         * Contribution 13 & 14\n         * ROM Consistency Check\n         * Partial degree: 1\n         * Total degree: 4\n         *\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\n         * records that are sorted.\n         *\n         * We apply the following checks for the sorted records:\n         *\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\n         * 2. index values for adjacent records are monotonically increasing\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\n         *\n         */\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\n\n        ap.index_is_monotonically_increasing = ap.index_delta * (ap.index_delta - Fr.wrap(1)); // deg 2\n\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + ONE) * ap.record_delta; // deg 2\n\n        evals[14] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\n            * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5\n        evals[15] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\n            * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5\n\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\n\n        /**\n         * Contributions 15,16,17\n         * RAM Consistency Check\n         *\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\n         * This is validated by requiring `access` to be boolean\n         *\n         * For two adjacent entries in the sorted list if _both_\n         *  A) index values match\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\n         * then\n         *  C) both values must match.\n         * The gate boolean check is\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\n         *\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\n         * with a WRITE operation.\n         */\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\n        ap.access_check = access_type * (access_type - Fr.wrap(1)); // check value is 0 or 1; deg 2 or 8\n\n        // reverse order we could re-use `ap.partial_record_check`  1 -  ((w3' * eta + w2') * eta + w1') * eta\n        // deg 1 or 4\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\n\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation =\n            (ap.index_delta * MINUS_ONE + ONE) * value_delta * (ap.next_gate_access_type * MINUS_ONE + ONE); // deg 3 or 6\n\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\n        // type is  correct, to cover this edge case\n        // deg 2 or 4\n        ap.next_gate_access_type_is_boolean =\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\n\n        // Putting it all together...\n        evals[16] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\n            * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5 or 8\n        evals[17] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4\n        evals[18] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4 or 6\n\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_O)); // deg 3 or 9\n\n        /**\n         * RAM Timestamp Consistency Check\n         *\n         * | w1 | w2 | w3 | w4 |\n         * | index | timestamp | timestamp_check | -- |\n         *\n         * Let delta_index = index_{i + 1} - index_{i}\n         *\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\n         * Else timestamp_check = 0\n         */\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\n        ap.RAM_timestamp_check_identity = (ap.index_delta * MINUS_ONE + ONE) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\n\n        /**\n         * Complete Contribution 12\n         * The complete RAM/ROM memory identity\n         * Partial degree:\n         */\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\n        ap.memory_identity =\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\n\n        // (deg 3 or 9) + (deg 4) + (deg 3)\n        ap.memory_identity = ap.memory_identity * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4 or 10\n        evals[13] = ap.memory_identity;\n    }\n\n    // Constants for the Non-native Field relation\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\n\n    // Parameters used within the Non-Native Field Relation\n    // A struct is used to work around stack too deep. This relation has alot of variables\n    struct NnfParams {\n        Fr limb_subproduct;\n        Fr non_native_field_gate_1;\n        Fr non_native_field_gate_2;\n        Fr non_native_field_gate_3;\n        Fr limb_accumulator_1;\n        Fr limb_accumulator_2;\n        Fr nnf_identity;\n    }\n\n    function accumulateNnfRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        NnfParams memory ap;\n\n        /**\n         * Contribution 12\n         * Non native field arithmetic gate 2\n         * deg 4\n         *\n         *             _                                                                               _\n         *            /   _                   _                               _       14                \\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\n         *            \\_                                                                               _/\n         *\n         *\n         */\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\n        ap.non_native_field_gate_2 =\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\n\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\n\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\n\n        Fr non_native_field_identity =\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\n\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\n        // deg 2\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\n\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\n        // deg 2\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\n\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\n\n        ap.nnf_identity = non_native_field_identity + limb_accumulator_identity;\n        ap.nnf_identity = ap.nnf_identity * (wire(p, WIRE.Q_NNF) * domainSep);\n        evals[19] = ap.nnf_identity;\n    }\n\n    struct PoseidonExternalParams {\n        Fr s1;\n        Fr s2;\n        Fr s3;\n        Fr s4;\n        Fr u1;\n        Fr u2;\n        Fr u3;\n        Fr u4;\n        Fr t0;\n        Fr t1;\n        Fr t2;\n        Fr t3;\n        Fr v1;\n        Fr v2;\n        Fr v3;\n        Fr v4;\n        Fr q_pos_by_scaling;\n    }\n\n    function accumulatePoseidonExternalRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        PoseidonExternalParams memory ep;\n\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\n\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\n        // matrix mul v = M_E * u with 14 additions\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\n        ep.v4 = ep.t1 + ep.t1;\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\n        ep.v2 = ep.t0 + ep.t0;\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\n\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\n\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\n\n        evals[22] = evals[22] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\n\n        evals[23] = evals[23] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\n    }\n\n    struct PoseidonInternalParams {\n        Fr u1;\n        Fr u2;\n        Fr u3;\n        Fr u4;\n        Fr u_sum;\n        Fr v1;\n        Fr v2;\n        Fr v3;\n        Fr v4;\n        Fr s1;\n        Fr q_pos_by_scaling;\n    }\n\n    function accumulatePoseidonInternalRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        PoseidonInternalParams memory ip;\n\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\n        ];\n\n        // add round constants\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\n\n        // apply s-box round\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\n        ip.u2 = wire(p, WIRE.W_R);\n        ip.u3 = wire(p, WIRE.W_O);\n        ip.u4 = wire(p, WIRE.W_4);\n\n        // matrix mul with v = M_I * u 4 muls and 7 additions\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\n\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\n\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\n\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\n\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\n        evals[26] = evals[26] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\n\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\n        evals[27] = evals[27] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\n    }\n\n    function scaleAndBatchSubrelations(\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\n    ) internal pure returns (Fr accumulator) {\n        accumulator = evaluations[0];\n\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\n        }\n    }\n}\n\n// Field arithmetic libraries - prevent littering the code with modmul / addmul\n\nlibrary CommitmentSchemeLib {\n    using FrLib for Fr;\n\n    // Avoid stack too deep\n    struct ShpleminiIntermediates {\n        Fr unshiftedScalar;\n        Fr shiftedScalar;\n        Fr unshiftedScalarNeg;\n        Fr shiftedScalarNeg;\n        // Scalar to be multiplied by [1]\n        Fr constantTermAccumulator;\n        // Accumulator for powers of rho\n        Fr batchingChallenge;\n        // Linear combination of multilinear (sumcheck) evaluations and powers of rho\n        Fr batchedEvaluation;\n        Fr[4] denominators;\n        Fr[4] batchingScalars;\n        // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\n        Fr posInvertedDenominator;\n        // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\n        Fr negInvertedDenominator;\n        // ^{2i} * 1/(z - r^{2^i})\n        Fr scalingFactorPos;\n        // ^{2i+1} * 1/(z + r^{2^i})\n        Fr scalingFactorNeg;\n        // Fold_i(r^{2^i}) reconstructed by Verifier\n        Fr[] foldPosEvaluations;\n    }\n\n    function computeSquares(Fr r, uint256 logN) internal pure returns (Fr[] memory) {\n        Fr[] memory squares = new Fr[](logN);\n        squares[0] = r;\n        for (uint256 i = 1; i < logN; ++i) {\n            squares[i] = squares[i - 1].sqr();\n        }\n        return squares;\n    }\n    // Compute the evaluations A(r^{2}) for l = 0, ..., m-1\n\n    function computeFoldPosEvaluations(\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\n        Fr batchedEvalAccumulator,\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\n        Fr[] memory geminiEvalChallengePowers,\n        uint256 logSize\n    ) internal view returns (Fr[] memory) {\n        Fr[] memory foldPosEvaluations = new Fr[](logSize);\n        for (uint256 i = logSize; i > 0; --i) {\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\n            Fr u = sumcheckUChallenges[i - 1];\n\n            Fr batchedEvalRoundAcc = (\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\n                    - geminiEvaluations[i - 1] * (challengePower * (ONE - u) - u)\n            );\n            // Divide by the denominator\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (ONE - u) + u).invert();\n\n            batchedEvalAccumulator = batchedEvalRoundAcc;\n            foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\n        }\n        return foldPosEvaluations;\n    }\n}\n\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\n\nfunction bytes32ToString(bytes32 value) pure returns (string memory result) {\n    bytes memory alphabet = \"0123456789abcdef\";\n\n    bytes memory str = new bytes(66);\n    str[0] = \"0\";\n    str[1] = \"x\";\n    for (uint256 i = 0; i < 32; i++) {\n        str[2 + i * 2] = alphabet[uint8(value[i] >> 4)];\n        str[3 + i * 2] = alphabet[uint8(value[i] & 0x0f)];\n    }\n    result = string(str);\n}\n\n// Fr utility\n\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\n}\n\n// EC Point utilities\nfunction bytesToG1Point(bytes calldata proofSection) pure returns (Honk.G1Point memory point) {\n    point = Honk.G1Point({\n        x: uint256(bytes32(proofSection[0x00:0x20])) % Q,\n        y: uint256(bytes32(proofSection[0x20:0x40])) % Q\n    });\n}\n\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\n    point.y = (Q - point.y) % Q;\n    return point;\n}\n\n/**\n * Convert the pairing points to G1 points.\n *\n * The pairing points are serialised as an array of 68 bit limbs representing two points\n * The lhs of a pairing operation and the rhs of a pairing operation\n *\n * There are 4 fields for each group element, leaving 8 fields for each side of the pairing.\n *\n * @param pairingPoints The pairing points to convert.\n * @return lhs\n * @return rhs\n */\nfunction convertPairingPointsToG1(Fr[PAIRING_POINTS_SIZE] memory pairingPoints)\n    pure\n    returns (Honk.G1Point memory lhs, Honk.G1Point memory rhs)\n{\n    uint256 lhsX = Fr.unwrap(pairingPoints[0]);\n    lhsX |= Fr.unwrap(pairingPoints[1]) << 68;\n    lhsX |= Fr.unwrap(pairingPoints[2]) << 136;\n    lhsX |= Fr.unwrap(pairingPoints[3]) << 204;\n    lhs.x = lhsX;\n\n    uint256 lhsY = Fr.unwrap(pairingPoints[4]);\n    lhsY |= Fr.unwrap(pairingPoints[5]) << 68;\n    lhsY |= Fr.unwrap(pairingPoints[6]) << 136;\n    lhsY |= Fr.unwrap(pairingPoints[7]) << 204;\n    lhs.y = lhsY;\n\n    uint256 rhsX = Fr.unwrap(pairingPoints[8]);\n    rhsX |= Fr.unwrap(pairingPoints[9]) << 68;\n    rhsX |= Fr.unwrap(pairingPoints[10]) << 136;\n    rhsX |= Fr.unwrap(pairingPoints[11]) << 204;\n    rhs.x = rhsX;\n\n    uint256 rhsY = Fr.unwrap(pairingPoints[12]);\n    rhsY |= Fr.unwrap(pairingPoints[13]) << 68;\n    rhsY |= Fr.unwrap(pairingPoints[14]) << 136;\n    rhsY |= Fr.unwrap(pairingPoints[15]) << 204;\n    rhs.y = rhsY;\n}\n\n/**\n * Hash the pairing inputs from the present verification context with those extracted from the public inputs.\n *\n * @param proofPairingPoints Pairing points from the proof - (public inputs).\n * @param accLhs Accumulator point for the left side - result of shplemini.\n * @param accRhs Accumulator point for the right side - result of shplemini.\n * @return recursionSeparator The recursion separator - generated from hashing the above.\n */\nfunction generateRecursionSeparator(\n    Fr[PAIRING_POINTS_SIZE] memory proofPairingPoints,\n    Honk.G1Point memory accLhs,\n    Honk.G1Point memory accRhs\n) pure returns (Fr recursionSeparator) {\n    // hash the proof aggregated X\n    // hash the proof aggregated Y\n    // hash the accum X\n    // hash the accum Y\n\n    (Honk.G1Point memory proofLhs, Honk.G1Point memory proofRhs) = convertPairingPointsToG1(proofPairingPoints);\n\n    uint256[8] memory recursionSeparatorElements;\n\n    // Proof points\n    recursionSeparatorElements[0] = proofLhs.x;\n    recursionSeparatorElements[1] = proofLhs.y;\n    recursionSeparatorElements[2] = proofRhs.x;\n    recursionSeparatorElements[3] = proofRhs.y;\n\n    // Accumulator points\n    recursionSeparatorElements[4] = accLhs.x;\n    recursionSeparatorElements[5] = accLhs.y;\n    recursionSeparatorElements[6] = accRhs.x;\n    recursionSeparatorElements[7] = accRhs.y;\n\n    recursionSeparator = FrLib.fromBytes32(keccak256(abi.encodePacked(recursionSeparatorElements)));\n}\n\n/**\n * G1 Mul with Separator\n * Using the ecAdd and ecMul precompiles\n *\n * @param basePoint The point to multiply.\n * @param other The other point to add.\n * @param recursionSeperator The separator to use for the multiplication.\n * @return `(recursionSeperator * basePoint) + other`.\n */\nfunction mulWithSeperator(Honk.G1Point memory basePoint, Honk.G1Point memory other, Fr recursionSeperator)\n    view\n    returns (Honk.G1Point memory)\n{\n    Honk.G1Point memory result;\n\n    result = ecMul(recursionSeperator, basePoint);\n    result = ecAdd(result, other);\n\n    return result;\n}\n\n/**\n * G1 Mul\n * Takes a Fr value and a G1 point and uses the ecMul precompile to return the result.\n *\n * @param value The value to multiply the point by.\n * @param point The point to multiply.\n * @return result The result of the multiplication.\n */\nfunction ecMul(Fr value, Honk.G1Point memory point) view returns (Honk.G1Point memory) {\n    Honk.G1Point memory result;\n\n    assembly {\n        let free := mload(0x40)\n        // Write the point into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free       |  point.x\n        // free + 0x20|  point.y\n        mstore(free, mload(point))\n        mstore(add(free, 0x20), mload(add(point, 0x20)))\n        // Write the scalar into memory (one 32 byte word)\n        // Memory layout:\n        // Address    |  value\n        // free + 0x40|  value\n        mstore(add(free, 0x40), value)\n\n        // Call the ecMul precompile, it takes in the following\n        // [point.x, point.y, scalar], and returns the result back into the free memory location.\n        let success := staticcall(gas(), 0x07, free, 0x60, free, 0x40)\n        if iszero(success) {\n            revert(0, 0)\n        }\n        // Copy the result of the multiplication back into the result memory location.\n        // Memory layout:\n        // Address    |  value\n        // result     |  result.x\n        // result + 0x20|  result.y\n        mstore(result, mload(free))\n        mstore(add(result, 0x20), mload(add(free, 0x20)))\n\n        mstore(0x40, add(free, 0x60))\n    }\n\n    return result;\n}\n\n/**\n * G1 Add\n * Takes two G1 points and uses the ecAdd precompile to return the result.\n *\n * @param lhs The left hand side of the addition.\n * @param rhs The right hand side of the addition.\n * @return result The result of the addition.\n */\nfunction ecAdd(Honk.G1Point memory lhs, Honk.G1Point memory rhs) view returns (Honk.G1Point memory) {\n    Honk.G1Point memory result;\n\n    assembly {\n        let free := mload(0x40)\n        // Write lhs into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free       |  lhs.x\n        // free + 0x20|  lhs.y\n        mstore(free, mload(lhs))\n        mstore(add(free, 0x20), mload(add(lhs, 0x20)))\n\n        // Write rhs into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free + 0x40|  rhs.x\n        // free + 0x60|  rhs.y\n        mstore(add(free, 0x40), mload(rhs))\n        mstore(add(free, 0x60), mload(add(rhs, 0x20)))\n\n        // Call the ecAdd precompile, it takes in the following\n        // [lhs.x, lhs.y, rhs.x, rhs.y], and returns their addition back into the free memory location.\n        let success := staticcall(gas(), 0x06, free, 0x80, free, 0x40)\n        if iszero(success) { revert(0, 0) }\n\n        // Copy the result of the addition back into the result memory location.\n        // Memory layout:\n        // Address    |  value\n        // result     |  result.x\n        // result + 0x20|  result.y\n        mstore(result, mload(free))\n        mstore(add(result, 0x20), mload(add(free, 0x20)))\n\n        mstore(0x40, add(free, 0x80))\n    }\n\n    return result;\n}\n\nfunction validateOnCurve(Honk.G1Point memory point) pure {\n    uint256 x = point.x;\n    uint256 y = point.y;\n\n    bool success = false;\n    assembly {\n        let xx := mulmod(x, x, Q)\n        success := eq(mulmod(y, y, Q), addmod(mulmod(x, xx, Q), 3, Q))\n    }\n\n    require(success, \"point is not on the curve\");\n}\n\nfunction pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool decodedResult) {\n    bytes memory input = abi.encodePacked(\n        rhs.x,\n        rhs.y,\n        // Fixed G2 point\n        uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\n        uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\n        uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\n        uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\n        lhs.x,\n        lhs.y,\n        // G2 point from VK\n        uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\n        uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\n        uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\n        uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\n    );\n\n    (bool success, bytes memory result) = address(0x08).staticcall(input);\n    decodedResult = success && abi.decode(result, (bool));\n}\n\n// Field arithmetic libraries - prevent littering the code with modmul / addmul\n\n\n\n\nabstract contract BaseZKHonkVerifier is IVerifier {\n    using FrLib for Fr;\n\n    uint256 immutable $N;\n    uint256 immutable $LOG_N;\n    uint256 immutable $VK_HASH;\n    uint256 immutable $NUM_PUBLIC_INPUTS;\n\n    constructor(uint256 _N, uint256 _logN, uint256 _vkHash, uint256 _numPublicInputs) {\n        $N = _N;\n        $LOG_N = _logN;\n        $VK_HASH = _vkHash;\n        $NUM_PUBLIC_INPUTS = _numPublicInputs;\n    }\n\n    // Errors\n    error ProofLengthWrong();\n    error ProofLengthWrongWithLogN(uint256 logN, uint256 actualLength, uint256 expectedLength);\n    error PublicInputsLengthWrong();\n    error SumcheckFailed();\n    error ShpleminiFailed();\n    error GeminiChallengeInSubgroup();\n    error ConsistencyCheckFailed();\n\n    // Constants for proof length calculation (matching UltraKeccakZKFlavor)\n    uint256 constant NUM_WITNESS_ENTITIES = 8;\n    uint256 constant NUM_ELEMENTS_COMM = 2; // uint256 elements for curve points\n    uint256 constant NUM_ELEMENTS_FR = 1; // uint256 elements for field elements\n    uint256 constant NUM_LIBRA_EVALUATIONS = 4; // libra evaluations\n\n    // Calculate proof size based on log_n (matching UltraKeccakZKFlavor formula)\n    function calculateProofSize(uint256 logN) internal pure returns (uint256) {\n        // Witness and Libra commitments\n        uint256 proofLength = NUM_WITNESS_ENTITIES * NUM_ELEMENTS_COMM; // witness commitments\n        proofLength += NUM_ELEMENTS_COMM * 4; // Libra concat, grand sum, quotient comms + Gemini masking\n\n        // Sumcheck\n        proofLength += logN * ZK_BATCHED_RELATION_PARTIAL_LENGTH * NUM_ELEMENTS_FR; // sumcheck univariates\n        proofLength += NUMBER_OF_ENTITIES * NUM_ELEMENTS_FR; // sumcheck evaluations\n\n        // Libra and Gemini\n        proofLength += NUM_ELEMENTS_FR * 3; // Libra sum, claimed eval, Gemini masking eval\n        proofLength += logN * NUM_ELEMENTS_FR; // Gemini a evaluations\n        proofLength += NUM_LIBRA_EVALUATIONS * NUM_ELEMENTS_FR; // libra evaluations\n\n        // PCS commitments\n        proofLength += (logN - 1) * NUM_ELEMENTS_COMM; // Gemini Fold commitments\n        proofLength += NUM_ELEMENTS_COMM * 2; // Shplonk Q and KZG W commitments\n\n        // Pairing points\n        proofLength += PAIRING_POINTS_SIZE; // pairing inputs carried on public inputs\n\n        return proofLength;\n    }\n\n    uint256 constant SHIFTED_COMMITMENTS_START = 30;\n\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\n\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs)\n        public\n        view\n        override\n        returns (bool verified)\n    {\n        // Calculate expected proof size based on $LOG_N\n        uint256 expectedProofSize = calculateProofSize($LOG_N);\n\n        // Check the received proof is the expected size where each field element is 32 bytes\n        if (proof.length != expectedProofSize * 32) {\n            revert ProofLengthWrongWithLogN($LOG_N, proof.length, expectedProofSize * 32);\n        }\n\n        Honk.VerificationKey memory vk = loadVerificationKey();\n        Honk.ZKProof memory p = ZKTranscriptLib.loadProof(proof, $LOG_N);\n\n        if (publicInputs.length != vk.publicInputsSize - PAIRING_POINTS_SIZE) {\n            revert PublicInputsLengthWrong();\n        }\n\n        // Generate the fiat shamir challenges for the whole protocol\n        ZKTranscript memory t =\n            ZKTranscriptLib.generateTranscript(p, publicInputs, $VK_HASH, $NUM_PUBLIC_INPUTS, $LOG_N);\n\n        // Derive public input delta\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\n            publicInputs,\n            p.pairingPointObject,\n            t.relationParameters.beta,\n            t.relationParameters.gamma, /*pubInputsOffset=*/\n            1\n        );\n\n        // Sumcheck\n        if (!verifySumcheck(p, t)) revert SumcheckFailed();\n\n        if (!verifyShplemini(p, vk, t)) revert ShpleminiFailed();\n\n        verified = true;\n    }\n\n    uint256 constant PERMUTATION_ARGUMENT_VALUE_SEPARATOR = 1 << 28;\n\n    function computePublicInputDelta(\n        bytes32[] memory publicInputs,\n        Fr[PAIRING_POINTS_SIZE] memory pairingPointObject,\n        Fr beta,\n        Fr gamma,\n        uint256 offset\n    ) internal view returns (Fr publicInputDelta) {\n        Fr numerator = Fr.wrap(1);\n        Fr denominator = Fr.wrap(1);\n\n        Fr numeratorAcc = gamma + (beta * FrLib.from(PERMUTATION_ARGUMENT_VALUE_SEPARATOR + offset));\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\n\n        {\n            for (uint256 i = 0; i < $NUM_PUBLIC_INPUTS - PAIRING_POINTS_SIZE; i++) {\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\n\n                numerator = numerator * (numeratorAcc + pubInput);\n                denominator = denominator * (denominatorAcc + pubInput);\n\n                numeratorAcc = numeratorAcc + beta;\n                denominatorAcc = denominatorAcc - beta;\n            }\n\n            for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n                Fr pubInput = pairingPointObject[i];\n\n                numerator = numerator * (numeratorAcc + pubInput);\n                denominator = denominator * (denominatorAcc + pubInput);\n\n                numeratorAcc = numeratorAcc + beta;\n                denominatorAcc = denominatorAcc - beta;\n            }\n        }\n\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\n        publicInputDelta = FrLib.div(numerator, denominator);\n    }\n\n    function verifySumcheck(Honk.ZKProof memory proof, ZKTranscript memory tp) internal view returns (bool verified) {\n        Fr roundTargetSum = tp.libraChallenge * proof.libraSum; // default 0\n        Fr powPartialEvaluation = Fr.wrap(1);\n\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\n        for (uint256 round; round < $LOG_N; ++round) {\n            Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\n            Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\n            if (totalSum != roundTargetSum) revert SumcheckFailed();\n\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\n\n            // Update the round target for the next rounf\n            roundTargetSum = computeNextTargetSum(roundUnivariate, roundChallenge);\n            powPartialEvaluation =\n                powPartialEvaluation * (Fr.wrap(1) + roundChallenge * (tp.gateChallenges[round] - Fr.wrap(1)));\n        }\n\n        // Last round\n        Fr grandHonkRelationSum = RelationsLib.accumulateRelationEvaluations(\n            proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation\n        );\n\n        Fr evaluation = Fr.wrap(1);\n        for (uint256 i = 2; i < $LOG_N; i++) {\n            evaluation = evaluation * tp.sumCheckUChallenges[i];\n        }\n\n        grandHonkRelationSum =\n            grandHonkRelationSum * (Fr.wrap(1) - evaluation) + proof.libraEvaluation * tp.libraChallenge;\n        verified = (grandHonkRelationSum == roundTargetSum);\n    }\n\n    // Return the new target sum for the next sumcheck round\n    function computeNextTargetSum(Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\n        internal\n        view\n        returns (Fr targetSum)\n    {\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000009d80),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000005a0),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000240),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000005a0),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000009d80)\n        ];\n\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\n\n        // Performing Barycentric evaluations\n        // Compute B(x)\n        Fr numeratorValue = Fr.wrap(1);\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\n        }\n\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            denominatorInverses[i] = FrLib.invert(BARYCENTRIC_LAGRANGE_DENOMINATORS[i] * (roundChallenge - Fr.wrap(i)));\n        }\n\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            targetSum = targetSum + roundUnivariates[i] * denominatorInverses[i];\n        }\n\n        // Scale the sum by the value of B(x)\n        targetSum = targetSum * numeratorValue;\n    }\n\n    uint256 constant LIBRA_COMMITMENTS = 3;\n    uint256 constant LIBRA_EVALUATIONS = 4;\n    uint256 constant LIBRA_UNIVARIATES_LENGTH = 9;\n\n    struct PairingInputs {\n        Honk.G1Point P_0;\n        Honk.G1Point P_1;\n    }\n\n    function verifyShplemini(Honk.ZKProof memory proof, Honk.VerificationKey memory vk, ZKTranscript memory tp)\n        internal\n        view\n        returns (bool verified)\n    {\n        CommitmentSchemeLib.ShpleminiIntermediates memory mem; // stack\n\n        // - Compute vector (r, r, ... , r), where n = log_circuit_size\n        Fr[] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR, $LOG_N);\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\n        Fr[] memory scalars = new Fr[](NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3);\n        Honk.G1Point[] memory commitments = new Honk.G1Point[](NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3);\n\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\n\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\n        mem.shiftedScalar =\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\n\n        scalars[0] = Fr.wrap(1);\n        commitments[0] = proof.shplonkQ;\n\n        /* Batch multivariate opening claims, shifted and unshifted\n        * The vector of scalars is populated as follows:\n        * \\f[\n        * \\left(\n        * - \\left(\\frac{1}{z-r} + \\nu \\times \\frac{1}{z+r}\\right),\n        * \\ldots,\n        * - \\rho^{i+k-1} \\times \\left(\\frac{1}{z-r} + \\nu \\times \\frac{1}{z+r}\\right),\n        * - \\rho^{i+k} \\times \\frac{1}{r} \\times \\left(\\frac{1}{z-r} - \\nu \\times \\frac{1}{z+r}\\right),\n        * \\ldots,\n        * - \\rho^{k+m-1} \\times \\frac{1}{r} \\times \\left(\\frac{1}{z-r} - \\nu \\times \\frac{1}{z+r}\\right)\n        * \\right)\n        * \\f]\n        *\n        * The following vector is concatenated to the vector of commitments:\n        * \\f[\n        * f_0, \\ldots, f_{m-1}, f_{\\text{shift}, 0}, \\ldots, f_{\\text{shift}, k-1}\n        * \\f]\n        *\n        * Simultaneously, the evaluation of the multilinear polynomial\n        * \\f[\n        * \\sum \\rho^i \\cdot f_i + \\sum \\rho^{i+k} \\cdot f_{\\text{shift}, i}\n        * \\f]\n        * at the challenge point \\f$ (u_0,\\ldots, u_{n-1}) \\f$ is computed.\n        *\n        * This approach minimizes the number of iterations over the commitments to multilinear polynomials\n        * and eliminates the need to store the powers of \\f$ \\rho \\f$.\n        */\n        mem.batchedEvaluation = proof.geminiMaskingEval;\n        mem.batchingChallenge = tp.rho;\n        mem.unshiftedScalarNeg = mem.unshiftedScalar.neg();\n        mem.shiftedScalarNeg = mem.shiftedScalar.neg();\n\n        scalars[1] = mem.unshiftedScalarNeg;\n        for (uint256 i = 0; i < NUMBER_UNSHIFTED; ++i) {\n            scalars[i + 2] = mem.unshiftedScalarNeg * mem.batchingChallenge;\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i] * mem.batchingChallenge);\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\n        }\n        // g commitments are accumulated at r\n        // For each of the to be shifted commitments perform the shift in place by\n        // adding to the unshifted value.\n        // We do so, as the values are to be used in batchMul later, and as\n        // `a * c + b * c = (a + b) * c` this will allow us to reduce memory and compute.\n        // Applied to w1, w2, w3, w4 and zPerm\n        for (uint256 i = 0; i < NUMBER_TO_BE_SHIFTED; ++i) {\n            uint256 scalarOff = i + SHIFTED_COMMITMENTS_START;\n            uint256 evaluationOff = i + NUMBER_UNSHIFTED;\n\n            scalars[scalarOff] = scalars[scalarOff] + (mem.shiftedScalarNeg * mem.batchingChallenge);\n            mem.batchedEvaluation =\n                mem.batchedEvaluation + (proof.sumcheckEvaluations[evaluationOff] * mem.batchingChallenge);\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\n        }\n\n        commitments[1] = proof.geminiMaskingPoly;\n\n        commitments[2] = vk.qm;\n        commitments[3] = vk.qc;\n        commitments[4] = vk.ql;\n        commitments[5] = vk.qr;\n        commitments[6] = vk.qo;\n        commitments[7] = vk.q4;\n        commitments[8] = vk.qLookup;\n        commitments[9] = vk.qArith;\n        commitments[10] = vk.qDeltaRange;\n        commitments[11] = vk.qElliptic;\n        commitments[12] = vk.qMemory;\n        commitments[13] = vk.qNnf;\n        commitments[14] = vk.qPoseidon2External;\n        commitments[15] = vk.qPoseidon2Internal;\n        commitments[16] = vk.s1;\n        commitments[17] = vk.s2;\n        commitments[18] = vk.s3;\n        commitments[19] = vk.s4;\n        commitments[20] = vk.id1;\n        commitments[21] = vk.id2;\n        commitments[22] = vk.id3;\n        commitments[23] = vk.id4;\n        commitments[24] = vk.t1;\n        commitments[25] = vk.t2;\n        commitments[26] = vk.t3;\n        commitments[27] = vk.t4;\n        commitments[28] = vk.lagrangeFirst;\n        commitments[29] = vk.lagrangeLast;\n\n        // Accumulate proof points\n        commitments[30] = proof.w1;\n        commitments[31] = proof.w2;\n        commitments[32] = proof.w3;\n        commitments[33] = proof.w4;\n        commitments[34] = proof.zPerm;\n        commitments[35] = proof.lookupInverses;\n        commitments[36] = proof.lookupReadCounts;\n        commitments[37] = proof.lookupReadTags;\n\n        /* Batch gemini claims from the prover\n         * place the commitments to gemini a to the vector of commitments, compute the contributions from\n         * a(r) for i=1,  , n1 to the constant term accumulator, add corresponding scalars\n         *\n         * 1. Moves the vector\n         * \\f[\n         * \\left( \\text{com}(A_1), \\text{com}(A_2), \\ldots, \\text{com}(A_{n-1}) \\right)\n         * \\f]\n        * to the 'commitments' vector.\n        *\n        * 2. Computes the scalars:\n        * \\f[\n        * \\frac{\\nu^{2}}{z + r^2}, \\frac{\\nu^3}{z + r^4}, \\ldots, \\frac{\\nu^{n-1}}{z + r^{2^{n-1}}}\n        * \\f]\n        * and places them into the 'scalars' vector.\n        *\n        * 3. Accumulates the summands of the constant term:\n         * \\f[\n         * \\sum_{i=2}^{n-1} \\frac{\\nu^{i} \\cdot A_i(-r^{2^i})}{z + r^{2^i}}\n         * \\f]\n         * and adds them to the 'constant_term_accumulator'.\n         */\n\n        // Add contributions from A(r) and A(-r) to constant_term_accumulator:\n        // Compute the evaluations A(r^{2}) for l = 0, ..., $LOG_N - 1\n        Fr[] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\n            tp.sumCheckUChallenges,\n            mem.batchedEvaluation,\n            proof.geminiAEvaluations,\n            powers_of_evaluation_challenge,\n            $LOG_N\n        );\n\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\n        mem.constantTermAccumulator =\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\n\n        mem.batchingChallenge = tp.shplonkNu.sqr();\n        uint256 boundary = NUMBER_UNSHIFTED + 2;\n\n        // Compute Shplonk constant term contributions from A( r^{2}) for l = 1, ..., m-1;\n        // Compute scalar multipliers for each fold commitment\n        for (uint256 i = 0; i < $LOG_N - 1; ++i) {\n            bool dummy_round = i >= ($LOG_N - 1);\n\n            if (!dummy_round) {\n                // Update inverted denominators\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\n\n                // Compute the scalar multipliers for A( r^{2}) and [A]\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\n                scalars[boundary + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\n\n                // Accumulate the const term contribution given by\n                // v^{2l} * A(r^{2}) /(z-r^{2^l}) + v^{2l+1} * A(-r^{2}) /(z+ r^{2^l})\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\n            }\n            // Update the running power of v\n            mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\n\n            commitments[boundary + i] = proof.geminiFoldComms[i];\n        }\n\n        boundary += $LOG_N - 1;\n\n        // Finalize the batch opening claim\n        mem.denominators[0] = Fr.wrap(1).div(tp.shplonkZ - tp.geminiR);\n        mem.denominators[1] = Fr.wrap(1).div(tp.shplonkZ - SUBGROUP_GENERATOR * tp.geminiR);\n        mem.denominators[2] = mem.denominators[0];\n        mem.denominators[3] = mem.denominators[0];\n\n        mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\n        for (uint256 i = 0; i < LIBRA_EVALUATIONS; i++) {\n            Fr scalingFactor = mem.denominators[i] * mem.batchingChallenge;\n            mem.batchingScalars[i] = scalingFactor.neg();\n            mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu;\n            mem.constantTermAccumulator = mem.constantTermAccumulator + scalingFactor * proof.libraPolyEvals[i];\n        }\n        scalars[boundary] = mem.batchingScalars[0];\n        scalars[boundary + 1] = mem.batchingScalars[1] + mem.batchingScalars[2];\n        scalars[boundary + 2] = mem.batchingScalars[3];\n\n        for (uint256 i = 0; i < LIBRA_COMMITMENTS; i++) {\n            commitments[boundary++] = proof.libraCommitments[i];\n        }\n\n        commitments[boundary] = Honk.G1Point({x: 1, y: 2});\n        scalars[boundary++] = mem.constantTermAccumulator;\n\n        if (!checkEvalsConsistency(proof.libraPolyEvals, tp.geminiR, tp.sumCheckUChallenges, proof.libraEvaluation)) {\n            revert ConsistencyCheckFailed();\n        }\n\n        Honk.G1Point memory quotient_commitment = proof.kzgQuotient;\n\n        commitments[boundary] = quotient_commitment;\n        scalars[boundary] = tp.shplonkZ; // evaluation challenge\n\n        PairingInputs memory pair;\n        pair.P_0 = batchMul(commitments, scalars);\n        pair.P_1 = negateInplace(quotient_commitment);\n\n        // Aggregate pairing points\n        Fr recursionSeparator = generateRecursionSeparator(proof.pairingPointObject, pair.P_0, pair.P_1);\n        (Honk.G1Point memory P_0_other, Honk.G1Point memory P_1_other) =\n            convertPairingPointsToG1(proof.pairingPointObject);\n\n        // Validate the points from the proof are on the curve\n        validateOnCurve(P_0_other);\n        validateOnCurve(P_1_other);\n\n        // accumulate with aggregate points in proof\n        pair.P_0 = mulWithSeperator(pair.P_0, P_0_other, recursionSeparator);\n        pair.P_1 = mulWithSeperator(pair.P_1, P_1_other, recursionSeparator);\n\n        return pairing(pair.P_0, pair.P_1);\n    }\n\n    struct SmallSubgroupIpaIntermediates {\n        Fr[SUBGROUP_SIZE] challengePolyLagrange;\n        Fr challengePolyEval;\n        Fr lagrangeFirst;\n        Fr lagrangeLast;\n        Fr rootPower;\n        Fr[SUBGROUP_SIZE] denominators; // this has to disappear\n        Fr diff;\n    }\n\n    function checkEvalsConsistency(\n        Fr[LIBRA_EVALUATIONS] memory libraPolyEvals,\n        Fr geminiR,\n        Fr[CONST_PROOF_SIZE_LOG_N] memory uChallenges,\n        Fr libraEval\n    ) internal view returns (bool check) {\n        Fr one = Fr.wrap(1);\n        Fr vanishingPolyEval = geminiR.pow(SUBGROUP_SIZE) - one;\n        if (vanishingPolyEval == Fr.wrap(0)) {\n            revert GeminiChallengeInSubgroup();\n        }\n\n        SmallSubgroupIpaIntermediates memory mem;\n        mem.challengePolyLagrange[0] = one;\n        for (uint256 round = 0; round < $LOG_N; round++) {\n            uint256 currIdx = 1 + LIBRA_UNIVARIATES_LENGTH * round;\n            mem.challengePolyLagrange[currIdx] = one;\n            for (uint256 idx = currIdx + 1; idx < currIdx + LIBRA_UNIVARIATES_LENGTH; idx++) {\n                mem.challengePolyLagrange[idx] = mem.challengePolyLagrange[idx - 1] * uChallenges[round];\n            }\n        }\n\n        mem.rootPower = one;\n        mem.challengePolyEval = Fr.wrap(0);\n        for (uint256 idx = 0; idx < SUBGROUP_SIZE; idx++) {\n            mem.denominators[idx] = mem.rootPower * geminiR - one;\n            mem.denominators[idx] = mem.denominators[idx].invert();\n            mem.challengePolyEval = mem.challengePolyEval + mem.challengePolyLagrange[idx] * mem.denominators[idx];\n            mem.rootPower = mem.rootPower * SUBGROUP_GENERATOR_INVERSE;\n        }\n\n        Fr numerator = vanishingPolyEval * Fr.wrap(SUBGROUP_SIZE).invert();\n        mem.challengePolyEval = mem.challengePolyEval * numerator;\n        mem.lagrangeFirst = mem.denominators[0] * numerator;\n        mem.lagrangeLast = mem.denominators[SUBGROUP_SIZE - 1] * numerator;\n\n        mem.diff = mem.lagrangeFirst * libraPolyEvals[2];\n\n        mem.diff = mem.diff\n            + (geminiR - SUBGROUP_GENERATOR_INVERSE)\n                * (libraPolyEvals[1] - libraPolyEvals[2] - libraPolyEvals[0] * mem.challengePolyEval);\n        mem.diff = mem.diff + mem.lagrangeLast * (libraPolyEvals[2] - libraEval) - vanishingPolyEval * libraPolyEvals[3];\n\n        check = mem.diff == Fr.wrap(0);\n    }\n\n    // This implementation is the same as above with different constants\n    function batchMul(Honk.G1Point[] memory base, Fr[] memory scalars)\n        internal\n        view\n        returns (Honk.G1Point memory result)\n    {\n        uint256 limit = NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3;\n\n        // Validate all points are on the curve\n        for (uint256 i = 0; i < limit; ++i) {\n            validateOnCurve(base[i]);\n        }\n\n        bool success = true;\n        assembly {\n            let free := mload(0x40)\n\n            let count := 0x01\n            for {} lt(count, add(limit, 1)) { count := add(count, 1) } {\n                // Get loop offsets\n                let base_base := add(base, mul(count, 0x20))\n                let scalar_base := add(scalars, mul(count, 0x20))\n\n                mstore(add(free, 0x40), mload(mload(base_base)))\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\n                // Add scalar\n                mstore(add(free, 0x80), mload(scalar_base))\n\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\n            }\n\n            // Return the result\n            mstore(result, mload(free))\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\n        }\n\n        require(success, ShpleminiFailed());\n    }\n}\n\ncontract PrivateTransferVerifier is BaseZKHonkVerifier(N, LOG_N, VK_HASH, NUMBER_OF_PUBLIC_INPUTS) {\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\n       return HonkVerificationKey.loadVerificationKey();\n    }\n}\n"
      }
    }
  }
}