{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"15966966662525330895","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_address_public_proof_data","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPublicProofData","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransfer::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"viewing_key","type":{"kind":"field"},"visibility":"private"},{"name":"burn_address_private_proof_data","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPrivateProofData","fields":[{"name":"total_received","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_received_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"shared_secret","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"189327025425157196":{"error_kind":"string","string":"first spend but prev_total_spent != 0"},"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12149997590364146557":{"error_kind":"string","string":"total_received merkle proof invalid"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14666658369005863707":{"error_kind":"string","string":"aggregated burn address amounts do not match target amount"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransfer::{spendFromBurnAddresses, BurnAddressPublicProofData, BurnAddressPrivateProofData, SignatureData};\n\nglobal AMOUNT_BURN_ADDRESSES: u32 = 4; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_address_public_proof_data: pub [BurnAddressPublicProofData; AMOUNT_BURN_ADDRESSES],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData; AMOUNT_BURN_ADDRESSES],\n    amount_burn_addresses: u32\n) {\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        amount,\n        burn_address_public_proof_data,\n        //private\n        pub_key_x_field,      \n        viewing_key,\n        burn_address_private_proof_data,\n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer4In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    //assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"zkwormhole\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_RECEIVED_DOMAIN: Field = 0x52454345495645445F544F54414C; // UTF8(\"total_received\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x5350454E545F544F54414C; // UTF8(\"total_spent\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 3n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\n//global POW_DIFFICULTY: Field =  0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn compute_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\nfn get_private_address(pub_key: Field, shared_secret: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([pub_key,shared_secret, PRIVATE_ADDRESS_TYPE], 3);\n    // Here is some disabled code for a PoW, we can later use shared_secret as a PoW that is derived by the sender to also be a PoW\n    // let pow_hash: Field = Poseidon2::hash([shared_secret, address_hash], 2); \n    // assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: shared_secret results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_received_leaf(private_address: Field, total_received: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_received, TOTAL_RECEIVED_DOMAIN],\n        3,\n    )\n}\n\n// prev_account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_account_note(total_spent: Field, account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, viewing_key, TOTAL_SPENT_DOMAIN], 4)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnAddressPublicProofData {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnAddressPrivateProofData {                \n    //-----very privacy sensitive data -----\n    total_received: Field,              \n    prev_total_spent: Field,                           \n    prev_account_nonce: Field,               \n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n    amount: Field,\n    shared_secret: Field,\n}\n\npub fn spendFromBurnAddresses(\n    root: Field, \n    amount: Field, \n    burn_address_public_proof_data: [BurnAddressPublicProofData],\n    //private\n    pub_key_x_field: Field,      \n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData],\n    amount_burn_addresses: u32\n) {\n    let mut total_spend: Field = 0;\n    for i in 0..burn_address_private_proof_data.len() {\n        if( i < amount_burn_addresses) {\n            let public_data: BurnAddressPublicProofData = burn_address_public_proof_data[i];\n            let private_data: BurnAddressPrivateProofData = burn_address_private_proof_data[i];\n            spendFromBurnAddress(\n                //public\n                root,\n                private_data.amount,\n                public_data.account_note_hash,\n                public_data.account_note_nullifier,\n\n                //private\n                pub_key_x_field,    \n                private_data.shared_secret,\n                viewing_key,\n\n                private_data.total_received,\n                private_data.prev_total_spent,\n                private_data.prev_account_nonce,\n                private_data.prev_account_note_merkle,\n                private_data.total_received_merkle,\n            );\n\n            total_spend = total_spend + private_data.amount;\n\n        }\n    }\n\n    assert(total_spend == amount, \"aggregated burn address amounts do not match target amount\");\n}\n\npub fn spendFromBurnAddress(\n    root: Field,\n    amount: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    pub_key_x_field: Field,\n    shared_secret: Field,\n    viewing_key: Field,\n\n    total_received: Field,\n    prev_total_spent: Field,\n    prev_account_nonce: Field,\n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData\n) {\n    let private_address: Field = get_private_address(pub_key_x_field, shared_secret);\n    let total_received_leaf: Field = hash_total_received_leaf(private_address, total_received);\n\n    let root_total_received: Field = compute_root(total_received_leaf, total_received_merkle);\n    assert(root_total_received == root, \"total_received merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        let prev_account_note_hash: Field = hash_account_note(prev_total_spent, prev_account_nonce, viewing_key);\n        let computed_prev_root: Field = compute_root(prev_account_note_hash, prev_account_note_merkle);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        assert(prev_total_spent == 0, \"first spend but prev_total_spent != 0\");\n    }\n\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    let new_spent_amount: Field = prev_total_spent + amount;\n    assert(lower_then_or_equal(new_spent_amount, total_received), \"spend exceeds total received\");\n\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_account_note(new_spent_amount, current_account_nonce, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}