{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"8669977998191613016","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_address_public_proof_data","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPublicProofData","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransfer::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"shared_secret","type":{"kind":"field"},"visibility":"private"},{"name":"viewing_key","type":{"kind":"field"},"visibility":"private"},{"name":"burn_address_private_proof_data","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPrivateProofData","fields":[{"name":"total_received","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_received_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}}]}},"visibility":"private"}],"return_type":null,"error_types":{"189327025425157196":{"error_kind":"string","string":"first spend but prev_total_spent != 0"},"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12149997590364146557":{"error_kind":"string","string":"total_received merkle proof invalid"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14666658369005863707":{"error_kind":"string","string":"aggregated burn address amounts do not match target amount"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransfer::{spendFromBurnAddresses, BurnAddressPublicProofData, BurnAddressPrivateProofData, SignatureData};\n\nglobal AMOUNT_BURN_ADDRESSES: u32 = 1; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_address_public_proof_data: pub [BurnAddressPublicProofData; AMOUNT_BURN_ADDRESSES],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    shared_secret: Field,\n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData; AMOUNT_BURN_ADDRESSES],\n) {\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        amount,\n        burn_address_public_proof_data,\n        //private\n        pub_key_x_field,      \n        shared_secret,\n        viewing_key,\n        burn_address_private_proof_data,\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer1In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    //assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"zkwormhole\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_RECEIVED_DOMAIN: Field = 0x52454345495645445F544F54414C; // UTF8(\"total_received\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x5350454E545F544F54414C; // UTF8(\"total_spent\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 3n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\n//global POW_DIFFICULTY: Field =  0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn compute_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\nfn get_private_address(pub_key: Field, shared_secret: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([pub_key,shared_secret, PRIVATE_ADDRESS_TYPE], 3);\n    // Here is some disabled code for a PoW, we can later use shared_secret as a PoW that is derived by the sender to also be a PoW\n    // let pow_hash: Field = Poseidon2::hash([shared_secret, address_hash], 2); \n    // assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: shared_secret results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_received_leaf(private_address: Field, total_received: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_received, TOTAL_RECEIVED_DOMAIN],\n        3,\n    )\n}\n\n// prev_account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_account_note(total_spent: Field, account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, viewing_key, TOTAL_SPENT_DOMAIN], 4)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnAddressPublicProofData {\n    amount: Field,\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnAddressPrivateProofData {                \n    //-----very privacy sensitive data -----\n    total_received: Field,              \n    prev_total_spent: Field,                           \n    prev_account_nonce: Field,               \n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n}\n\npub fn spendFromBurnAddresses(\n    root: Field, \n    amount: Field, \n    burn_address_public_proof_data: [BurnAddressPublicProofData],\n    //private\n    pub_key_x_field: Field,      \n    shared_secret: Field,\n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData],\n) {\n    let mut total_spend = 0;\n    for i in 0..burn_address_private_proof_data.len() {\n        let public_data = burn_address_public_proof_data[i];\n        let private_data = burn_address_private_proof_data[i];\n        spendFromBurnAddress(\n            //public\n            root,\n            public_data.amount,\n            public_data.account_note_hash,\n            public_data.account_note_nullifier,\n\n            //private\n            pub_key_x_field,    \n            shared_secret,\n            viewing_key,\n\n            private_data.total_received,\n            private_data.prev_total_spent,\n            private_data.prev_account_nonce,\n            private_data.prev_account_note_merkle,\n            private_data.total_received_merkle,\n        );\n\n        total_spend = total_spend + public_data.amount;\n    }\n\n    assert(total_spend == amount, \"aggregated burn address amounts do not match target amount\");\n}\n\npub fn spendFromBurnAddress(\n    root: Field,\n    amount: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    pub_key_x_field: Field,\n    shared_secret: Field,\n    viewing_key: Field,\n\n    total_received: Field,\n    prev_total_spent: Field,\n    prev_account_nonce: Field,\n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n) {\n    let private_address: Field = get_private_address(pub_key_x_field, shared_secret);\n    let total_received_leaf: Field = hash_total_received_leaf(private_address, total_received);\n\n    let root_total_received: Field = compute_root(total_received_leaf, total_received_merkle);\n    assert(root_total_received == root, \"total_received merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        let prev_account_note_hash: Field = hash_account_note(prev_total_spent, prev_account_nonce, viewing_key);\n        let computed_prev_root: Field = compute_root(prev_account_note_hash, prev_account_note_merkle);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        assert(prev_total_spent == 0, \"first spend but prev_total_spent != 0\");\n    }\n\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    let new_spent_amount: Field = prev_total_spent + amount;\n    assert(lower_then_or_equal(new_spent_amount, total_received), \"spend exceeds total received\");\n\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_account_note(new_spent_amount, current_account_nonce, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}