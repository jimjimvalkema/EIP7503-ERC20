{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"17583482620999544834","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_address_public_proof_data","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPublicProofData","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransfer::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"shared_secret","type":{"kind":"field"},"visibility":"private"},{"name":"viewing_key","type":{"kind":"field"},"visibility":"private"},{"name":"burn_address_private_proof_data","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransfer::BurnAddressPrivateProofData","fields":[{"name":"total_received","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_received_merkle","type":{"kind":"struct","path":"privateTransfer::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"amount","type":{"kind":"field"}}]}},"visibility":"private"}],"return_type":null,"error_types":{"189327025425157196":{"error_kind":"string","string":"first spend but prev_total_spent != 0"},"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12149997590364146557":{"error_kind":"string","string":"total_received merkle proof invalid"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14666658369005863707":{"error_kind":"string","string":"aggregated burn address amounts do not match target amount"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransfer::{spendFromBurnAddresses, BurnAddressPublicProofData, BurnAddressPrivateProofData, SignatureData};\n\nglobal AMOUNT_BURN_ADDRESSES: u32 = 1; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_address_public_proof_data: pub [BurnAddressPublicProofData; AMOUNT_BURN_ADDRESSES],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    shared_secret: Field,\n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData; AMOUNT_BURN_ADDRESSES],\n) {\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        amount,\n        burn_address_public_proof_data,\n        //private\n        pub_key_x_field,      \n        shared_secret,\n        viewing_key,\n        burn_address_private_proof_data,\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer1In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    //assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"zkwormhole\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_RECEIVED_DOMAIN: Field = 0x52454345495645445F544F54414C; // UTF8(\"total_received\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x5350454E545F544F54414C; // UTF8(\"total_spent\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 3n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\n//global POW_DIFFICULTY: Field =  0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn compute_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\nfn get_private_address(pub_key: Field, shared_secret: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([pub_key,shared_secret, PRIVATE_ADDRESS_TYPE], 3);\n    // Here is some disabled code for a PoW, we can later use shared_secret as a PoW that is derived by the sender to also be a PoW\n    // let pow_hash: Field = Poseidon2::hash([shared_secret, address_hash], 2); \n    // assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: shared_secret results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_received_leaf(private_address: Field, total_received: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_received, TOTAL_RECEIVED_DOMAIN],\n        3,\n    )\n}\n\n// prev_account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_account_note(total_spent: Field, account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, viewing_key, TOTAL_SPENT_DOMAIN], 4)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnAddressPublicProofData {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnAddressPrivateProofData {                \n    //-----very privacy sensitive data -----\n    total_received: Field,              \n    prev_total_spent: Field,                           \n    prev_account_nonce: Field,               \n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n    amount: Field\n}\n\npub fn spendFromBurnAddresses(\n    root: Field, \n    amount: Field, \n    burn_address_public_proof_data: [BurnAddressPublicProofData],\n    //private\n    pub_key_x_field: Field,      \n    shared_secret: Field,\n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnAddressPrivateProofData],\n) {\n    let mut total_spend: Field = 0;\n    for i in 0..burn_address_private_proof_data.len() {\n        let public_data: BurnAddressPublicProofData = burn_address_public_proof_data[i];\n        let private_data: BurnAddressPrivateProofData = burn_address_private_proof_data[i];\n        spendFromBurnAddress(\n            //public\n            root,\n            private_data.amount,\n            public_data.account_note_hash,\n            public_data.account_note_nullifier,\n\n            //private\n            pub_key_x_field,    \n            shared_secret,\n            viewing_key,\n\n            private_data.total_received,\n            private_data.prev_total_spent,\n            private_data.prev_account_nonce,\n            private_data.prev_account_note_merkle,\n            private_data.total_received_merkle,\n        );\n\n        total_spend = total_spend + private_data.amount;\n    }\n\n    assert(total_spend == amount, \"aggregated burn address amounts do not match target amount\");\n}\n\npub fn spendFromBurnAddress(\n    root: Field,\n    amount: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    pub_key_x_field: Field,\n    shared_secret: Field,\n    viewing_key: Field,\n\n    total_received: Field,\n    prev_total_spent: Field,\n    prev_account_nonce: Field,\n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n) {\n    let private_address: Field = get_private_address(pub_key_x_field, shared_secret);\n    let total_received_leaf: Field = hash_total_received_leaf(private_address, total_received);\n\n    let root_total_received: Field = compute_root(total_received_leaf, total_received_merkle);\n    assert(root_total_received == root, \"total_received merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        let prev_account_note_hash: Field = hash_account_note(prev_total_spent, prev_account_nonce, viewing_key);\n        let computed_prev_root: Field = compute_root(prev_account_note_hash, prev_account_note_merkle);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        assert(prev_total_spent == 0, \"first spend but prev_total_spent != 0\");\n    }\n\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    let new_spent_amount: Field = prev_total_spent + amount;\n    assert(lower_then_or_equal(new_spent_amount, total_received), \"spend exceeds total received\");\n\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_account_note(new_spent_amount, current_account_nonce, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n}","path":"/home/jimjim/Desktop/schwarzschild/backend/circuits/privateTransfer/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}