{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"7364174676510745366","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_data_public","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPublic","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransferLib::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"burn_data_private","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPrivate","fields":[{"name":"viewing_key","type":{"kind":"field"}},{"name":"pow_nonce","type":{"kind":"field"}},{"name":"total_burned","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"amount_to_spend","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":42,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":42,"type":{"kind":"field"}}}]}},{"name":"total_burned_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":42,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":42,"type":{"kind":"field"}}}]}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7277924040473639006":{"error_kind":"string","string":"total_burned merkle proof invalid"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"10942716740258210273":{"error_kind":"string","string":"prev_account_nonce = 0 but prev_total_spent is not 0."},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17791442556191318216":{"error_kind":"string","string":"aggregated burn address amounts do not match amount to spend"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransferLib::{spendFromBurnAddresses, BurnDataPublic, BurnDataPrivate, SignatureData};\n\n// should not go smaller then 2 because then the fact that someone is consolidating balances leaks\nglobal BURN_ADDRESSES_LEN: u32 = 2; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    chain_id: Field, // pub key word is removed since we don't use cross-chain functionality\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_data_public: pub [BurnDataPublic; BURN_ADDRESSES_LEN],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    burn_data_private: [BurnDataPrivate; BURN_ADDRESSES_LEN],\n    amount_burn_addresses: u32 // always one but still a input to be consistent with other circuits\n) {\n\n    // one signature for all burns. Cheaper, better UX, but you cant spent with different private keys\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        chain_id,\n        amount,\n        burn_data_public,\n        //private\n        burn_data_private,\n        pub_key_x_field,      \n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/EIP7503-ERC20/circuits/privateTransfer2In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"ZKWORMHOLE\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_BURNED_DOMAIN: Field = 0x544f54414c5f4255524e4544; // UTF8(\"TOTAL_BURNED\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x544f54414c5f5350454e44; // UTF8(\"TOTAL_SPEND\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 4n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\nglobal POW_DIFFICULTY: Field =  0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\n// ---------- why max tree depth 42 --------------------\n// const erc20Tps = 35_000;\n// const zkwormholeTps = erc20Tps / 10;\n// const bulkMerkleInserts = 1; // becomes relevant once large reMints emitting multiple commitments are more gas efficient then simple burns. \n// const insertsPerYear = bulkMerkleInserts * zkwormholeTps * 60*60*24*365;\n// const treeDepth = 42;\n// (2**treeDepth) / insertsPerYear\n\n// depth 42 allows for 40 years on a 35_000 tps chain (megaEth recent stress test) if every tx is a burn tx\n// after that, any tokens burned will be actually be burned for real and you will never get them back!\n// any tokens before that are fine. That leaf will always exist and the contract always stores that root.\n// you can burn tokens before the tree is at a depth above 42, and reMint them a 100 years later those will always be there.\n// the ui can warn you, but contract cant prevent it because the contract can't know if your address is a burn address or a normal address!\n// ----------------------------------------------------------\nglobal MAX_TREE_DEPTH: u32 = 42; // TODO make this configurable outside lib\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn merkle_hash_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\n\n// @notice chain_id is not used in this repo but can be used to make this cross-chain like warptoad\n// viewing_key is there so it is committed in the burn address, \n// to prevent spenders from using a different key and pretend they never spent before when ever the create the nullifier at account_nonce=0\nfn hash_blinded_burn_address_data(spending_pub_key_x:Field, chain_id:Field, viewing_key:Field) -> Field {\n    Poseidon2::hash([spending_pub_key_x, viewing_key, chain_id], 3)\n}\n\n// pow_nonce acts both as a PoW to make finding a hash collision between EOA and BurnAddress harder\nfn hash_burn_address(blinded_address_data_hash: Field, pow_nonce: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([blinded_address_data_hash, pow_nonce, PRIVATE_ADDRESS_TYPE], 3);\n    let pow_hash: Field = Poseidon2::hash([pow_nonce, address_hash], 2); \n    assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: pow_nonce results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_burned_leaf(private_address: Field, total_burned: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_burned, TOTAL_BURNED_DOMAIN],\n        3,\n    )\n}\n\n/*\ntotal_spent: total_spend for that specific burn address\nblinded_address_data_hash: this ties this commitment to the chain_id which is crucial for cross-chain warptoad like use cases, also ties it to the rest of the data in that hash\nviewing_key: is already inside blinded_address_data_hash, but is used again here so blinded_address_data_hash is sharable so sender can create burn addresses on the recipients behave\n*/\nfn hash_total_spent_leaf(total_spent: Field, account_nonce: Field, blinded_address_data_hash:Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, blinded_address_data_hash, viewing_key, TOTAL_SPENT_DOMAIN], 5)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// viewing_key is so others cant try and find the pre-image (since this hash is posted onchain)\n// and viewing_key is also committed inside the burn address pre-image, so spender is forced to only use that viewing key. To prevent them using a new one and pretending they never spent before\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    // TODO maybe we can save on memory computing indices on the spot instead?\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnDataPublic {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnDataPrivate {                \n    //-----very privacy sensitive data -----\n    /*blinds note hashes and nullifiers, separate from blinding_pow to support senders making fresh burn account on the recipients behave*/\n    viewing_key: Field,    \n    /*Serves as a PoW to defend against the address collision attack (similar problem to eip-3607) */\n    pow_nonce: Field,\n    // amounts\n    total_burned: Field,              \n    prev_total_spent: Field,  \n    amount_to_spend: Field,                     \n    // inclusion proof\n    prev_account_nonce: Field,               \n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData,\n}\n\npub fn spendFromBurnAddresses(\n    //public\n    root: Field, \n    chain_id: Field,\n    total_amount_to_spent: Field, \n    burn_data_public: [BurnDataPublic],\n    //private\n    burn_data_private: [BurnDataPrivate],\n    spending_pub_key_x: Field,    \n    amount_burn_addresses: u32\n) {\n    let mut amount_verified: Field = 0;\n    for i in 0..burn_data_private.len() {\n        if( i < amount_burn_addresses) {\n            spendFromBurnAddress(\n                //public\n                root,\n                chain_id,\n                burn_data_public[i].account_note_hash,\n                burn_data_public[i].account_note_nullifier,\n\n                //private\n                spending_pub_key_x,\n                burn_data_private[i].viewing_key,\n                burn_data_private[i].pow_nonce,\n                burn_data_private[i].amount_to_spend,\n                burn_data_private[i].total_burned,\n                burn_data_private[i].prev_total_spent,\n                burn_data_private[i].prev_account_nonce,\n                burn_data_private[i].prev_account_note_merkle_data,\n                burn_data_private[i].total_burned_merkle_data,\n            );\n\n            amount_verified = amount_verified + burn_data_private[i].amount_to_spend;\n\n        }\n    }\n\n    assert(amount_verified == total_amount_to_spent, \"aggregated burn address amounts do not match amount to spend\");\n}\n\npub fn spendFromBurnAddress(\n    // public\n    root: Field,\n    chain_id: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    // private, keys\n    spending_pub_key_x: Field,\n    viewing_key: Field,\n    pow_nonce: Field,\n\n    // private balances\n    amount_to_spend: Field,\n    total_burned: Field,\n    prev_total_spent: Field,\n\n    // private inclusion proof\n    prev_account_nonce: Field,\n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData\n) {\n  \n    let blinded_address_data_hash: Field = hash_blinded_burn_address_data(spending_pub_key_x, chain_id, viewing_key );\n    let private_address: Field = hash_burn_address(blinded_address_data_hash, pow_nonce);\n\n    // verify how much is \"burned\"\n    let total_burned_leaf: Field = hash_total_burned_leaf(private_address, total_burned);\n    let root_total_burned: Field = merkle_hash_root(total_burned_leaf, total_burned_merkle_data);\n    assert(root_total_burned == root, \"total_burned merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        // verify how much was spent in total before this tx: verify prev_total_spent\n        let prev_account_note_hash: Field = hash_total_spent_leaf(prev_total_spent, prev_account_nonce,blinded_address_data_hash, viewing_key);\n        let computed_prev_root: Field = merkle_hash_root(prev_account_note_hash, prev_account_note_merkle_data);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        // we have to skip merkle proofs since a previous spent balance does not exist\n\n        // this assert prevents you from effectively burning money on the first tx\n        assert(prev_total_spent == 0, \"prev_account_nonce = 0 but prev_total_spent is not 0.\");\n    }\n\n    // nullify the prev_total_spent, which is inside prev_account_note_hash and tied to prev_account_nonce + viewing_key\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    // check amount spent\n    let new_total_spent: Field = prev_total_spent + amount_to_spend;\n    assert(lower_then_or_equal(new_total_spent, total_burned), \"spend exceeds total received\");\n\n    //\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_total_spent_leaf(new_total_spent, current_account_nonce,blinded_address_data_hash, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n\n}","path":"/home/jimjim/Desktop/EIP7503-ERC20/circuits/privateTransferLib/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}