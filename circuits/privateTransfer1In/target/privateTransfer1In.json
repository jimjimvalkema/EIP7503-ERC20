{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"17106569942762921964","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_data_public","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPublic","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransferLib::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"burn_data_private","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPrivate","fields":[{"name":"viewing_key","type":{"kind":"field"}},{"name":"pow_nonce","type":{"kind":"field"}},{"name":"total_burned","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"amount_to_spend","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_burned_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7277924040473639006":{"error_kind":"string","string":"total_burned merkle proof invalid"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"10942716740258210273":{"error_kind":"string","string":"prev_account_nonce = 0 but prev_total_spent is not 0."},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17791442556191318216":{"error_kind":"string","string":"aggregated burn address amounts do not match amount to spend"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransferLib::{spendFromBurnAddresses, BurnDataPublic, BurnDataPrivate, SignatureData};\n\nglobal BURN_ADDRESSES_LEN: u32 = 1; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    chain_id: Field, // pub key word is removed since we don't use cross-chain functionality\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_data_public: pub [BurnDataPublic; BURN_ADDRESSES_LEN],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    burn_data_private: [BurnDataPrivate; BURN_ADDRESSES_LEN],\n    amount_burn_addresses:u32 // always one but still a input to be consistent with other circuits\n) {\n\n    // one signature for all burns. Cheaper, better UX, but you cant spent with different private keys\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        chain_id,\n        amount,\n        burn_data_public,\n        //private\n        burn_data_private,\n        pub_key_x_field,      \n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransfer1In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"ZKWORMHOLE\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_BURNED_DOMAIN: Field = 0x544f54414c5f4255524e4544; // UTF8(\"TOTAL_BURNED\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x544f54414c5f5350454e44; // UTF8(\"TOTAL_SPEND\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 3n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\nglobal POW_DIFFICULTY: Field =  0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn merkle_hash_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\n\n// @notice chain_id is not used in this repo but can be used to make this cross-chain like warptoad\n// viewing_key is there so it is committed in the burn address, \n// to prevent spenders from using a different key and pretend they never spent before when ever the create the nullifier at account_nonce=0\nfn hash_blinded_burn_address_data(spending_pub_key_x:Field, chain_id:Field, viewing_key:Field) -> Field {\n    Poseidon2::hash([spending_pub_key_x, viewing_key, chain_id], 3)\n}\n\n// pow_nonce acts both as a PoW to make finding a hash collision between EOA and BurnAddress harder\nfn hash_burn_address(blinded_address_data_hash: Field, pow_nonce: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([blinded_address_data_hash, pow_nonce, PRIVATE_ADDRESS_TYPE], 3);\n    let pow_hash: Field = Poseidon2::hash([pow_nonce, address_hash], 2); \n    assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: pow_nonce results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_burned_leaf(private_address: Field, total_burned: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_burned, TOTAL_BURNED_DOMAIN],\n        3,\n    )\n}\n\n/*\ntotal_spent: total_spend for that specific burn address\nblinded_address_data_hash: this ties this commitment to the chain_id which is crucial for cross-chain warptoad like use cases, also ties it to the rest of the data in that hash\nviewing_key: is already inside blinded_address_data_hash, but is used again here so blinded_address_data_hash is sharable so sender can create burn addresses on the recipients behave\n*/\nfn hash_total_spent_leaf(total_spent: Field, account_nonce: Field, blinded_address_data_hash:Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, blinded_address_data_hash, viewing_key, TOTAL_SPENT_DOMAIN], 5)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// viewing_key is so others cant try and find the pre-image (since this hash is posted onchain)\n// and viewing_key is also committed inside the burn address pre-image, so spender is forced to only use that viewing key. To prevent them using a new one and pretending they never spent before\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    // TODO maybe we can save on memory computing indices on the spot instead?\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnDataPublic {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnDataPrivate {                \n    //-----very privacy sensitive data -----\n    /*blinds note hashes and nullifiers, separate from blinding_pow to support senders making fresh burn account on the recipients behave*/\n    viewing_key: Field,    \n    /*Serves as a PoW to defend against the address collision attack (similar problem to eip-3607) */\n    pow_nonce: Field,\n    // amounts\n    total_burned: Field,              \n    prev_total_spent: Field,  \n    amount_to_spend: Field,                     \n    // inclusion proof\n    prev_account_nonce: Field,               \n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData,\n}\n\npub fn spendFromBurnAddresses(\n    //public\n    root: Field, \n    chain_id: Field,\n    total_amount_to_spent: Field, \n    burn_data_public: [BurnDataPublic],\n    //private\n    burn_data_private: [BurnDataPrivate],\n    spending_pub_key_x: Field,    \n    amount_burn_addresses: u32\n) {\n    let mut amount_verified: Field = 0;\n    for i in 0..burn_data_private.len() {\n        if( i < amount_burn_addresses) {\n            spendFromBurnAddress(\n                //public\n                root,\n                chain_id,\n                burn_data_public[i].account_note_hash,\n                burn_data_public[i].account_note_nullifier,\n\n                //private\n                spending_pub_key_x,\n                burn_data_private[i].viewing_key,\n                burn_data_private[i].pow_nonce,\n                burn_data_private[i].amount_to_spend,\n                burn_data_private[i].total_burned,\n                burn_data_private[i].prev_total_spent,\n                burn_data_private[i].prev_account_nonce,\n                burn_data_private[i].prev_account_note_merkle_data,\n                burn_data_private[i].total_burned_merkle_data,\n            );\n\n            amount_verified = amount_verified + burn_data_private[i].amount_to_spend;\n\n        }\n    }\n\n    assert(amount_verified == total_amount_to_spent, \"aggregated burn address amounts do not match amount to spend\");\n}\n\npub fn spendFromBurnAddress(\n    // public\n    root: Field,\n    chain_id: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    // private, keys\n    spending_pub_key_x: Field,\n    viewing_key: Field,\n    pow_nonce: Field,\n\n    // private balances\n    amount_to_spend: Field,\n    total_burned: Field,\n    prev_total_spent: Field,\n\n    // private inclusion proof\n    prev_account_nonce: Field,\n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData\n) {\n  \n    let blinded_address_data_hash: Field = hash_blinded_burn_address_data(spending_pub_key_x, chain_id, viewing_key );\n    let private_address: Field = hash_burn_address(blinded_address_data_hash, pow_nonce);\n\n    // verify how much is \"burned\"\n    let total_burned_leaf: Field = hash_total_burned_leaf(private_address, total_burned);\n    let root_total_burned: Field = merkle_hash_root(total_burned_leaf, total_burned_merkle_data);\n    assert(root_total_burned == root, \"total_burned merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        // verify how much was spent in total before this tx: verify prev_total_spent\n        let prev_account_note_hash: Field = hash_total_spent_leaf(prev_total_spent, prev_account_nonce,blinded_address_data_hash, viewing_key);\n        let computed_prev_root: Field = merkle_hash_root(prev_account_note_hash, prev_account_note_merkle_data);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        // we have to skip merkle proofs since a previous spent balance does not exist\n\n        // this assert prevents you from effectively burning money on the first tx\n        assert(prev_total_spent == 0, \"prev_account_nonce = 0 but prev_total_spent is not 0.\");\n    }\n\n    // nullify the prev_total_spent, which is inside prev_account_note_hash and tied to prev_account_nonce + viewing_key\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    // check amount spent\n    let new_total_spent: Field = prev_total_spent + amount_to_spend;\n    assert(lower_then_or_equal(new_total_spent, total_burned), \"spend exceeds total received\");\n\n    //\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_total_spent_leaf(new_total_spent, current_account_nonce,blinded_address_data_hash, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransferLib/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}