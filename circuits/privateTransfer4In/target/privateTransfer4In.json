{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"8574813876284704095","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_data_public","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPublic","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransferLib::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"burn_data_private","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPrivate","fields":[{"name":"viewing_key","type":{"kind":"field"}},{"name":"pow_nonce","type":{"kind":"field"}},{"name":"total_burned","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"amount_to_spend","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_burned_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7277924040473639006":{"error_kind":"string","string":"total_burned merkle proof invalid"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"10942716740258210273":{"error_kind":"string","string":"prev_account_nonce = 0 but prev_total_spent is not 0."},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17791442556191318216":{"error_kind":"string","string":"aggregated burn address amounts do not match amount to spend"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"tZ3djvTIcW3fZa51wYz/0KscGIYsy8YAA8mQpQMcGHr300ySscY2uqbUPbrxbLf74ypGBaNyd2Vu/9cP//qHf/nrv//zj3/8tz/95w+//T//9cO//PnHn3768d//+ac//f53f/nxT3/8+Ol//XCc/2PFD7+V3/yw+off6m9+kOP6z7r+I9d/9PqPXf/x6z+x/2Mfv7n+9vHvn2v5h87rP/XDb+O6cl5Xzo9flOcX198+/rfn9fzzX/78hz+c/5efvcCPl/0fv/vzH/74lx9++8e//vTTb374v7/76a/7l/7zP373x/3fv/zuzx//1+M3P/zhj//68d+PC/7bjz/94VR/+w3/+vj8n651mNz//EOHzyVWvXuNar2vUN38+3z337fG/e/b8wv/vo7nDkris39vn//7MLv/fbh+5d/Xev591Zf+/fMG5qFfuP/s5/47qL//9x6oFz1whE4L6M/eQXv7Hax5BZ2fvYKXXehrXsHn9/DqCnLUcwUx/+wKS160kXs+feSpnz0Ib1+i5IuXCC6RX7uEvXOJV9VUnaGgVl95PzRjrtD6pXfU5zVYrE/f0f78Ek4t3etnl1jvXyKnrzwlv3aJebw8f9YUf88lquZG+ogvXYIp6+1fvETNoDwO+8ol4tCaS3h97RLVzyXW0V+6xGLir/jajcgxQ19kfe0SMTci9aUbce9n3oTKp5fQ9eLD4+NT//n0WfVpLfTFvFkZ/jypJZ++qaqfX0LnWbdFb4b89wu8+AyVXE97S+rx6SX81W3kfAx+fKR+eol48TloPiuZ+soF1iEz9H6+GPufl3jxaW4fw/KppfXP1iP9fiX6eDpztXxeiVdtJeu5xMfY/LSt7MUl5LCnuWV9PnpNvtlWpt9uK7Nvt5X5N9vq1QXebKuz3t9sq5eVeK+tXvbE8qcUIsfxWU/48c2e8PXtnnD5dk+4frMnXl3gzZ5w/3ZPvKzEr9ATcsycEPt0feUvZqaUPDcipZ96SH/xUSzBJUI/tXFxvBp4x/NRLId8fon1aq2prI0+W/i/fg3jHeSIT9186D/yNaxg8P9sSfL3lHJNZ379El7fvYTMUlVUPv3TQNRLH6X4qPWlS9jCSMmvcAn/2iVkHnQz++IlxuOb97dv5KuXSG6k6ruX8ONrl/DFJX429P7HJTK/+5y+fA3zkH08K5++pdnffA2vx+78xUXi83lV69VHkM5ttNVXLvHm5K7vTs3Xr+GtyV3+j3wN703uX7jE+vYl3prcLy/x3uTu49uT++Ul3pvc71/Cv3aJtyb3L1zincn99o189RJvTe53L/Ficr+8xHuTu787NV+/hrcm9zrWP3J0p46Xy6jPX4R++yF7fY33nrK/4xr+xWu89Zz90jXeedDev5cvX+OtR+3ta7x41l5f472Hbb36OuWtRv+FV/He47bsm6/ipU22eq4gfnz+TcZ68edJl/mq0qXj02KsF8vOyPm7Q+TPl1v1d7yOkGed4aH+/WuYfvEaOd8ORX/xGp42X1LlF++ljrlGHfGl9vD5TkQ8vvYHW68Z6LE+/4pJXv2l8uP7RvYjqL/4AvT9q0R89SptcxVb9mtcRfTLd8RX5Jrrq1dR+zWu0vqzO6qvXqXyV7iK6zFXcf3yVcTeucrLrzx0vq9I+/xv0+vV9z+Sx5i4Oj7/WlHzm3/gXq++QnrzL9wfbfDtP3EvO775N+6XV3jzj9zr1ZdIb/6V+3U1foVv1Expr/78q/OX3wOt+b74Y57459d4/RXl3MrxsyfF5e+5xvydYB35xWvIbDpa8rMG+/o18mvX+G/L1OPTa7z6SmkdxUB9safBv/td5/Lvf9n5sZD+/mPv3/268+UV3n3s/ftfeL6uxq/w2Pt6Xka6frqoen2J2beT8fnK/+Ul0maXSOnnwydeNajG86Z8fFJ+/vkY390nssLe/Mve8XmDxqv2Ut7Wn/918H9d47tbRV5e4d0mj+9vFnldjRWstcu/W430r72vbw6v/P7X8iu/+738u1d4UYv8/lf7K+P7nZHyjx1/xebo9s8XxK++ZHp31VPH91c9r6/x3qrn5TXeXPW8f4382jXeXPWUf3/VU/HdD4TK7w+Oqu8PjurvDo5XV3j3se/1/cf+ZTV+hce+o+axb/vKkqVkthqX+Jf2xhZ/Mi3Xz1cs/apBe2ybdn0+fPrbjr5/BUff33f0cnzX0b+8wptNLsev4Oj7H+voy432qi+tyytyzj7l8SV3UDlfkVTGp8/J3mT3aUHZqmuH++fXeNGiH4vxeVCOzzfQvb4G3/zrR49+8Ro915D1+etYr/4S/t5mQFkvF09vbUt5eY0396XIt794+oVX8dbOFHn5Dcf3X8V7e1N+6Rrr+9d4a3fK62u8tz1FZH37q/PX13jvq/O/4xr+xWu89dX5L13jna/O37+XL1/jra/O377Gi6/OX1/jva/ORY/vPrWvX8VbX52Lyrdnx8t5/tYuQ1H7/jx/ecrpzXmu356kr1/Fe/P81VdMv8KreHOe/8I11vev8d48V/v+PLfvb4V6fY035/n71/AvXuO9eW7f3wr1/r18+RrvzfN3r/Fqntv3t0KJf3uS2ve3QonbP3Sev7f1UDy+/7y9vMabz9v71/AvXuO95+0XrvHW8/b2vXz5Gu89bx7ff95eXuPN5y2+uyH/F17Fe89bfPegyGtPLbPHTX9+1P1/vYrvH7CTPL6/Bsvvn9KT/PYcze+f09t1/we+ijfXYPn9o3q/cI331mD5/cN68vKbpjc/E15e483PhPev4V+8xnufCb9wjbc+E96+ly9f473PhHev8eoz4eU13vxMqG87p9ev4r3PhP62s4/vn9yT/hX+Rtq/wt9I+9uTtH+Fv5F2/ENfxZvzvH+Fv5H2r/A30v7+30j1+P7fSF9f4715/ndcw794jbfm+S9d4515/v69fPkab83zt6/xYp6/vsZ781zXdyfpL7yKt+a5fvuQ0+t5/p6n1lffNb37vL28xpvP2/vX8C9e473n7Reu8dbz9va9fPka7z1v717j1fP28hpvPm/y3YP2v/Aq3nvexL/9Kl58bV8TmVn1s7TKv+eb/55q9rE+3yEjr5z9e5t6VV5MjvfC3/Rd7/b5pl7Vl5/1b23q1VffNL2X//YyS+/NALhX3ya8mwD3shrvbep9txrpX3tficaVn5+v/F/XqF/hfX21N28Splq+2KFv5hO+Ol/5bkChfbtD7dvvqv0KPW7fjx57Xc/vb+HqY4JyP3rka2GkOj0er44NvrzEPKxh60vZrmGzgyvsf+xF+6eP/+13v//xz/89PN2qP276Nz9YH/d/zyT04xRymthT6CPsEf6IMz19/6t8RD3i47r28UD7cTxineerTyGP0EfY+X6dwh8R5y2cIh9x5rDnKT6ufC5hfR2PWOcW81PII/QMFD+FPcLPHaSniHNL6CnyEXVuwTtF3+JMeT8/i/xMkL+EPOLjyufWWz9z5C/hZ8VOxhkmf6vcD8ipalSf6gTqMeqs9tJTySgdZafyU/mo2LP8VDmqRvWj7Bi1RskoHWWjfNQwbBg2DBuGD8OH4cPwYfgwfBg+DB+GD8OHEcOIYcQwYhgxjBhGDCOGEcOIYeQw8mScre0po3TUyTi/v/D0UTEqR9WoflQdo4ZRw6hhlI3yUcOoYdQwahg9jP0UX0pGbcbZiW2jhtExKkfVqL5VHA8jjjVKRukoG+WjYlSOqlF9v6pYx0Nba5SM0lE2ahhrGGsYaxjrqVXI3IfMfcjch8x9yFOrkKdWITEqR9WoqZUOQ4ehw9Bh6NRK5z507kPnPnTuQ6dWNrWyqZVNrWxqZVMrG4YNw4Zhw7Cplc99+NyHz3343IdPrXxq5VMrn1r51MqnVjGMGEYMI4YRU6uY+4i5j5j7iLmPmFrl1Gqe85jnPOY5j5xazXMe85zHPOcxz3nMcx7znEfNfdTcR8191NRqnvOoqVVNrWpqVVOrec5jnvOY5zx6GD216rmPnvvouY+e++inVnk8tcpjjZJROspGPYyc5zznOc95zvN4apXrGLVGySgd9dQq11OrXDEqR9Wop1Y5z3nOc57znOc85yk2au5D5j5k7kPmPmRqpVMrnVrp1EqnVjq1muc85znPec5znvPUqZXNfdjch8192NyHTa1samVTK5ta2dTKplbznOc85znPec5znj618rkPn/vwuQ+f+/CpVUytYmoVU6uYWsXUap7znOc85znPec4zplY595FzHzn3kXMfObXKqVVOrXJqlVOrnFrNc57znOc85znPedbUquY+5vM85/M85/M8a2rVU6ueWvXUqqdWPbWa5zznOc95znOe8+ynVjWf5zWf5zWf5zWf53U8tarjqVUdMSpH1ainVjXPec1zXvOc1zzntWyUj4pROapGPbUqeWpVskbJKB1lo4Yxz3nNc17znJdMrebzvObzvObzvObzvHRqpVMrnVrp1EqnVjq1mue85jmvec5rnvOyqdV8ntd8ntd8ntd8npdNrXxq5VMrn1r51MqnVvOc1zznNc95zXNePrWaz/Oaz/Oaz/Oaz/OKqVVMrWJqFVOrmFrF1Gqe85rnvOY5r3nOa9btNZ/nNZ/nNZ/nNZ/nlVOrmlrNur1m3V6zbq9Zt9c85zXPec1zXvOc16zbaz7Paz7Paz7Paz7Pa9btNev2mnV7zbq9Zt1es27vec57nvOe57znOe9Zt/d8nvd8nvd8nvd8nves23vW7T3r9p51e8+6vWfd3vOc9zznPc95z3Pes27v+Tzv+Tzv+Tzv+TzvWbf3rNt71u096/aedXvPur3nOe95znue857nvGfd3vN53vN53vN53vN53rNu71m396zbe9btPev2nnV7z3Pe85z3POc9z3nPur3n87zn87zn87zn87xn3d6zbu9Zt/es23vW7T3r9p7nvOc573nOe57znnV7z+d5z+d5z+d5z+d5z7q9Z93es27vWbf3rNt71u09z3nPc97znPc85z3r9p7P857P857P857P8551e8+6vWfd3rNu71m396zbe57znue85znvec571u09n+c9n+c9n+c9n+c96/aPPz89xfqQCylIRRryIX3I4KeJLGTP7y5oC9qCNp/uH9KQ0ObB/5CbplsWctPslNfDf8mFFKQiDenIQCaykNAUmkJTaApNoSk0habQFJpCM2gGzaAZNINm0AyaQTNoBs2hOTSH5tAcmkNzaA7NoTm0gBbQAlpAC2jXpIgtA7lptWUhe37hGheXXPML18C4pPILhnR+IZDJLxSy5xeuwXFJaAXtmh2XNCS0glbcW3FvBa2hXTNkv5yG1tCae2toDa25t4bWQ1vHVHIdi58KUvkF46eODH4h+Wkh531ba+5tLWh7lpyHUT6kIg150s7vPT5kIBNZyJN2/v8V+rjsgTxpun9hz5JbnjTfr2HPkls6EppAE2h7llxSoe1ZcktBKtKQ0PYsuWUioSm0PUtuuZDQDJpB27PkloGEtmfJLXukQ3Noe5bcUpHQHJpD27PkloWEtmfJLRcSWkDbs+SWdElAC2gBLeiS5H1LaHuW3JIuSWgJLemSpEsSWkIraEWXFO9bQSt6suiSglbQii4puqShNbSG1nRJ8741tKYnmy5paD00OQ7kQg5NDkUa0pGBHJochZwukQVtQVuCVCS0BW1BW4ksJDQ5kAsJTaCJIR0JTaAJNJkuEWaJKDQVpCKhKTQNZCKhKTSDZgvJ+2bQzJCOhGbQrJB0iUNzaA7N6RJmiTg0DyRd4tAcWtAlQZcEtIAW0IIuYZZIQAt6MuiShJbQki5JuiShJbSElnQJs0QSWtGTRZcUtIJWdEnRJQWtoBW0okuYJdLQmp5suqShNbSmS5ouaWg9ND0O5EIKcmh6GNKRQ9MjkYWcLtEFbUFb0JYiDQltBTKR0BY0OZALCU2gCTRxZCChSSGnS1ShKTQVpCKhKTSFpoksJDQ7kAsJzaCZIadLlHWJGjSDZnQJs0QdmguSLnFoDs3pEqdLWJeoQwtoQZcwSzSgBT0ZdElAC2hBlwRdwrpEE1pCS7qEWaIJLenJpEsSWkIruqToEtYlWtAKWtElzBItaEVPFl3S0Bpa0yVNl7Au0YbW0JouYZZoD82OA7mQQ7NDkYZ05NDsSGQhp0uMWWIL2hKkIqHhcQyPY3gcY11ieBzD45gspCCh4XEMj2N4HMPjGB7H8DjGusTwOIbHMTyOMUsMj2N4HMPjGB7H8DiGxzE8jrEuMTyO4XEMj2PMEsPjGB7H8DiGxzE8juFxDI9jrEsMj2N4HMPjGLPE8DiGxzE8juFxDI9jeBzD4xjrEsPjGB7H8DjGLDE8juFxDI9jeBzD4xgex/A4xrrE8DiGxzE8jjFLDI9jeBzD4xgex/A4hscxPI6xLjE8juFxDI9jzBLD4xgex/A4hscxPI7jcRyP46xLHI/jeBzH4zizxPE4jsdxPI7jcRyP43gcx+M46xLH4zgex/E4zixxPI7jcRyP43gcx+M4HsfxOM66xPE4jsdxPI4zSxyP43gcx+M4HsfxOI7HcTyOsy5xPI7jcRyP48wSx+M4HsfxOI7HcTyO43Ecj+OsSxyP43gcx+M4s8TxOI7HcTyO43Ecj+N4HMfjOOsSx+M4HsfxOM4scTyO43Ecj+N4HMfjOB7H8TjOusTxOI7HcTyOM0scj+N4HMfjOB7H8TiOx3E8jrMucTyO43Ecj+PMEsfjOB7H8TjXFsu4fteRJ+3c8r6uXZa3LORJO/c0r2uj5S1P2vn/BHZdWy1vqciTdv5/wlzXbstbBjKRheyRe5acu6HXtefyliftTPJf167LW56089DuuvZd3jKQ0Ba0BW3PkltC27Pkloo0pCOh7Vlyy0JCU2h7ltxSkNAUmkLbs+SWiYS2Z8kl9yy5JTSDtmfJLXnfDJpBM2h7ltyyRzq0PUtuKUhoDs3pEqdLHJpDc2hBlwTvW0Dbs+SWdElAC2hBlwRdEtASWkJLuiR53xJa0pNJlyS0hJZ0SdElBa2gFbSiS4r3raAVPVl0SUFraE2XNF3S0BpaQ2u6pHnfGlpPT16bOW85tGs75y0VacihXVs6b5nIQs77dm3rvGhrIQUJbUFbjgwktAVtQZMDuZDQRJGGhCbQJJGFhKbQFJoKUpHQ1JGBhKbQdLrk2vR5S2gGzaCZIXnfDJolspDQHJrTJU6XODSH5tCcLmGWXNtAL5rTk0GXBLSAFnRJ0CUBLaAFtKBLmCXXltCLlvRk0iUJLaElXZJ0SUJLaAmt6BJmybU99KIVPVl0SUEraEWXFF1S0BpaQ2u6hFlybRW9aE1PNl3S0BpaT5dcG0ZvObRry+gtFWlIRw7t2jd6y0JCW9DWQgoS2oK2oK1AJhLamp68NpHeEppAE0UaEppAE2hSyHnfru2kF00XUpDQFJo6MpDQFJpCswPJ+2bQTJGGhGbQLJGFhObQHJrTJcySa5vpRXNH0iUOzaE5XRJ0CeuSa7vpLaEFXcIsubacXrSgJ4MuCWgJLemSpEtYl1xbT28JLekSZsm1/fSiJT1ZdElBK2hFlxRdwrrk2oZ6S2hFlzBLrq2oF63pyaZLGlpDa7qk6RLWJdeW1FsO7dqUesuFHNq1L/WWhhxa43Eaj9N4nGZd0nicxuNcG1RvqUhoeJzG4zQep/E4jcdpPE6zLmk8TuNxGo/TzJLG4zQep/E4jcdpPE7jcRqP06xLGo/TeJzG4zSzpPE4jcdpPE7jcRqP03icxuM065LG4zQep/E4zSxpPE7jcRqP03icxuM0HqfxOM26pPE4jcdpPE4zSxqP03icxuM0HqfxOI3HaTxOsy5pPE7jcRqP08ySxuM0HqfxOI3HaTxO43Eaj9OsSxqP03icxuM0s6TxOI3HaTxO43Eaj9N4nMbjNOuSxuM0HqfxOM0saTxOj8eRYzyOHONx5BiPI8d4HDnG48gx6xI5xuPIMR5HjvE4cswskWNBG48jx3gcORa0BW08jhzjceRY0Ba0BW08jhwzS+QQaONx5BiPI4dAE2jjceQYjyOHQFNoCm08jhwzS+RQaONx5BiPI4dCU2jjceQYjyOHQTNoBm08jhzG+2bQxuPIMR5HDoPm0JwucbrEoTk0h+Z0ifO+OTSnJ4MuCWgBLeiSoEsCWkALaEGXBO9bQkt6MumShJbQki5JuiShJbSEVnRJ8b4VtKIniy7Zs6Sv3w3kft98y0L2mTOhpzxnyUdpt1yn7C0FqUhD+pk9eGwZyETWKS9E78jCD7n3vT5yIU/ayi0VedLOve6y970+MpAn7dybL3vf6yNP2hlKInvf6yMX8qSpbqnIk6b75ZyzRHS/hnOWPPKknQkcsve9PvKk2Qafs+SRC3nSzLZU5EnzDT5nySMDedJ8v5xzljzypPl+OecseeTaGaFbClKRtrOCtnRk7NydLXPn7mxZyB55zhLJ/RrOWfLIk5b7YucseaQhT1rtN+ucJY88abXLd86SR/bIc5ZI71d2zpJHnrTeL+ecJbJbee97feRJ612Sc5Y8Ms98wA0+Z8kje+Q5S/TYb9Y5Sx4pZ7TNBp+z5JGG9FPul3POkkfm/n+ztWUhT5rsd/6cJY9cyJMm+806Z8kj9/O27+KcJXq15zlLHpnIk2bXP+uR5yx55Emz/baUXDEzsre93spG+ai4Mmdkb3m9/21d0TKyN7zGrtU5Q261rlCZDyWj9MqXkb3XNfb1zvFxq7iSZWRvdL1VXdkysre5brV3uZ4xM7I3ue6ZuPe43kqvgBnZO1xv5VeyjOz9rbfKUXWlzMje3HqpvfbYTXHtbb3lOXl3U1x7W295Tt5jw/fa45bn5N2dcO1tvWUhzzm/m+La23rLk3bmpMi1t/WWijSkIwOZyEL2yL32uCU0habQFJpCU2gKTaEpNINm0AyaQTNoBs2gGTSDZtAcmkNzaA7NoTm0OZQnMqfyROZYnsicvxWZg3kiczJPZI7miczZPJE5nCcyp/NEAlpAC2hzEldkjuiJJLSEltASWkKbg3oic1JPrr2t+xNT5kyuSEGbU7kicyxXZM7liszBXJGCVtAK2hzOFSkq2VSyubfm3pp7myO6InNGV6SpZFPJppJzTld0DuqKzkld0TmqKzpndUXnsK7onN8TneO6onNeV3QO7IrOiV3ROb8nOuf3ROf8nuic2hWdY7uiC9qCtqAtaHN2V1S4N+HehHsT7m0O8IrOCV7ROcIrOmd4RecQr6hQSYWm0BSaQlMqqdybcm/KvSn3plTSqKRRSaOSRiWNSho0g2bQDJpRSefenHtz7s25N6eSTiWZJcosUWaJOpVkliizRJklyixRZokySzS4t+DegnsLKsks0aSSSSWTSiaVZJYos0SZJZrQkkoW91bcW3Fvxb0VlSwqWVSyqGRRyaKSzBJlliizRJkl2lSyubfm3pp7a+5tzgKLzVlgsTkLLDZngcXmLLDYnAUWY5YYs8SYJcYssTkLLDYxH2KT8yE2QR9icxZYbCJ9xCbTR2xCfcQm1UdsYn3EJtdHjFlizBJjlhizxCbcR0y4N+HehHsT7k2opFJJpZJKJZVKKpVklhizxJglxiwxpZLGvRn3ZtybcW9GJY1KGpU0KmlU0qgks8SYJcYsMWaJOZV07s25N+fenHtzKhlUMqhkUMmgkkElmSXGLDFmiTFLLKhkcm+sS4x1ibEusaSSSSWTSiaVTCqZVJJZYswSY5YYs8SKSrIuMdYlxrrEWJdYUcmmkk0lm0o2lWwqySwxZokxS4xZYpMTJM66xFmXOOsSZ13iExYkPmlB4pMrID65AuKTKyA+iUHizBJnljizxJklPrkC4qxLnHWJsy5x1iU+2UHiEx4kPulB4hMfJD75QeITICTOLHFmiTNLnFniQiVZlzjrEmdd4qxLXKmkUkmlkkollUoqlWSWOLPEmSXOLHGjkqxLnHWJsy5x1iVuVNKppFNJp5JOJZ1KMkucWeLMEmeWOB7HWZc46xJnXeKsSzyoZFBJPI7jcRyP43gcZ5Y4s8SZJc4sISpUyAoVwkKFtFAhLlQcj+N4HBJDhchQITNUCA0VZ5YQGyrkhgrBoUJyqBAdKmSHCuGh4qxLiA8V8kOFAFEhQVSIEBUyRIUQUSFFVIgRFXJEhSBRIUlUiBIVskSFMFEhTVSIExXyRIVAUSFRVIgUFTJFhVBRIVVUiBUVckWFYFEhWVSIFhWyRYVwUSFdVIgXFfJFhYBRIWFUiBgVMkaFkFEhZVSIGRVyRoWgUSFpVIgaFbJGhbBRIW1UiBsV8kaFwFEhcVSIHBUyR4XQUSF1VIgdFXJHheBRIXlUiB4VskeF8FEhfVSIHxXyR4UAUiGBVIggFTJIhRBSIYVUiCEVckiFIFIhiVSIIhWySIUwUiGNVIgjFfJIhUBSIZFUiCQVMkmFUFIhlVSIJRVySYVgUiGZVIgmFbJJhXBSIZ1UiCeVYF0SrEuCdQkRpRLMkmCWBLOEmFIJ1iXJLElmyR1VqlsqctNsS0cGMpGF7JHXLLnkQgpSkdAWtAVtQVvQFjSBJtAEmkATaAJNoAk0gSbQFJpCU2gKTaEpNIWm0BSaQrtmSWy5abWl8FPlp8ZPnZ8GP01+Wsgeec2SS0K7ZskldS52zZLrp85Pg58mP4V2zZL904B2zZLrp9ACWkALaAHtOgu8+/c6C3zJ54SP5Jy5kZwzN5Jz5kZyzgJLzpkbufa26vULgXxO+Mi1t/WWPbKgFbSCNmduJAvanAWWnDM3knPmRnLO3EgWtD6QCwmtoU2ugOTkCkg2tIbW0CZXQGpyBaTmLLBce1tvqcih1ZwFlppcAanJFZCas8BSB7QFbXIFpCZXQGpBu87vXdKR0Ba0yRWQmlwBKYEm0ATa5ApITa6AlEC7zu9dMpHQBNrkCkhNroCUQlNoCm1yBaQmV0BKoWkhp0vKoBm0yRWQmlwBKYNm0Aza5ApIGe+bQfMDSZc4NIfmdInTJQ7NoTk0p0uC9y2gBT0ZdElAC2hBlwRdEtACWkJLuiR53xJa0pNJlyS0hJZ0SdIlBa2gFbSiS5glVdCKniy6pKAVtKZLmi5paA2toTVdwiyphtb05OQKSM9ZYOk5Cyw9uQLSkysgPWeBpecssPScBZaeXAFpZkkf0NaBXEhoC9rkCkhProD0gragLWiTKyDNLGmBJoJUJDSBNrkC0pMrIC3QBJpCm1wBaWZJKzQ1pCOhKbTJFZCeXAFpg2bQDNrkCkgzS9qgWSATCc2gOV3idIlDc2gOzekSZkk7NC8kXRLQAlrQJUGXBLSAFtCCLmGWdEBLejLpEtYlndCSLkm6JKEltISWdAmzpAta0ZNFlxS0glZ0SdElrEu6oDW0pkuYJd3Qmp5suqShNbSmSyZXQI9Zl+gxeUd6TK6AHpMroMfMEj0m70ivva23TGSBgDa5AnpMroAeC9qCtqBNroAeM0v0WNBWIXukQBNokyugx+QK6CHQBJpAm1wBPWaW6CHQ9EAuJDSFNrkCekyugB4KTaEptMkV0MN43wyaCVKR0Aza5AroMbkCehg0g+bQnC5x3jeH5oakSxyaQ3O6xOmSgBbQAlrQJcH7FtCCngy6JKAFtKRLki5JaAktoSVdkrxvCS3pyaRLClpBK7qk6JKCVtAKWtElxftW0JqebLqkoTW0pkuaLmloDa2hjcfRxSxZ43F0jcfRNR5H13gcXeNxdI3H0TUeR9esS3Qd0Ba08Ti6mCVrQRuPo2s8jpLpqmS6Kpmuusbj6BJoAk2gjcfRxSwh01XXeBxd43GUTFcl01XXeBxd43GUTFcl01XJdNU1HkcXs4RMV13jcXSNx1EyXZVMV13jcXSNx1EyXZVMVyXTVdd4HF3MEjJddY3H0eV0iUNzaE6XOF3i0ByaQ3O6hFlCpquuoCeDLgloAS3okqBLAlpAS2hJlzBLyHTVlfRk0iUJLaElXZJ0SUEraAWt6BJmCZmuuoqeLLqkoBW0pkuaLmloDa2hNV3CLCHTVVfTk+NxlExXJdNVZTyOyngcJdNVyXRVMl1VxuOoMEvIdFUZj6MyHkfJdFUyXVXG46iMx1EyXZVMVyXTVWU8jgqzhExXlfE4KuNxlExXJdNVZTyOyngcJdNVyXRVMl1VxuOoMEvIdFUZj6MyHkfJdFUyXVXG46iMx1EyXZVMVyXTVWU8jgqzhExXlfE4KuNx9Nr3Gtfv9sg9S858G732vd5SkCft3Get177X3C9yz5JbBvI5T6QyZ4FV5iywypwFVpkzNypz5kZlzgKrzFlgvfa9nvk2eu17veVznkhlzgLrte/1kgktoSW0OXOjktDmLLDKnAVWmTM3KnPmRiWhzVlgvfa93hJaQZuzwCqTK6BS0ApaQZuzwCqTK6DS0OYssF77Xm8JraHNWWCV5n1raHMWWHXOAqvOWWDVyRVQnbPAqnMWWK99r7ccms5ZYNU5C6w6uQKqC9qCtqDNWWDVyRVQXdDmLLBe+15vCW1Bm7PAqpMroCrQBJpAm7PAqpMroCrQ5iywXvteL6nQFNqcBVadXAFVhabQFNqcBVadXAFVhTZngfXa93pLaAZtzgKrTq6AqkEzaAbN6BLnfXNocxZYr32vt4Tm0JwuYZaoQ3NoAS3okuB9C2hBTwZdEtACWtAlQZcktISW0JIuYZZoQkt6MumShJbQii4puqSgFbSCVnQJs0QLWtGTRZc0tIbWdEnTJQ2toTW0pkuYJTpngdXmLLBe+15vOTSbs8BqcxZYbXIF1OYssNqcBVabs8BqcxZYjVliC9qcBdZr3+stoS1ocxZYbXIF1Ba0BU2gzVlgNWaJCbQ5C6zXvtdbQhNocxZYbXIF1BSaQlNocxZYjVliCm3OAuu17/WW0BTanAVWm1wBNYNm0AzanAVWY5aYQZuzwHrte72kQ3NoTpc4XeLQHJpDc7qEWWIOLejJoEtYl1hAC7ok6JKAFtACWtAlzBJLaElPJl2S0BJa0iVJl7AusYRW0IouYZZYQSt6suiSglbQii4puoR1iTW0htZ0CbPEGlrTk02XNLTJO1KfvCP1yRVQZ13ik3ekPnlH6pMroM4s8ck7Up+8I732vV5yQVvQJu9IfXIF1FmX+IK2oE2ugDqzxBe0yTvSa9/rLaEJtMk7Up9cAXXWJS7QBNrkCqgzS1yhTd6RXvtebwlNoU3ekfrkCqizLnGFZtAmV0CdWeIGbfKO9Nr3ektoBm3yjtSNLmFd4g7NoTldwixxhzZ5R3rte70lNDyO43Ecj+OsSxyP43gcD7qEWeJ4HMfjOB7H8TiOx3E8juNxnHWJ43Ecj+N4HGeWOB7H8TiOx3E8juNxHI/jeBxnXeJ4HMfjOB7HmSWOx3E8juNxHI/jeBzH4zgex1mXOB4n8DiBxwlmSeBxAo8TeBwyXZVMVyXTVcl0VTJdlUxXDTxO4HGCWUKmq5LpqoHHIdNVyXRVMl018DhkuiqZrkqmq5LpqsEsIdNVyXTVwOOQ6apkuiqZrhp4HDJdlUxXJdNVyXTVYJaQ6apkumrgcch0VTJdlUxXDTwOma5KpquS6apkumowS8h0VTJdNfA4ZLoqma5KpqsGHodMVyXTVcl0VTJdNZglZLoqma4aeBwyXZVMVyXTVQOPQ6arkumqZLoqma4azBIyXZVMVw08DpmuSqarkumqgcch01XJdFUyXZVMVw1mCZmuSqarBh6HTFcl01XJdNXA45DpqmS6KpmuSqarBrOETFcl01UTj0Omq5LpqmS6auJxyHRVMl2VTFcl01WTWUKmq5LpqonHIdNVyXRVMl018ThkuiqZrkqmq5LpqsksIdNVyXTVxOOQ6apkuiqZrpp4HDJdlUxXJdNVyXTVZJaQ6apkumrica59r339bo+8ZolvuZByR93o3ve6o25073vdSTa6970+MpCJrDvURve+11vujJJbrjvqRve+1x1qo3vf6yMN6Xe+je59r4/MO9RG977XR/bIc5bsfBvd+14fKXeoje59r480pN/5Nrr3vT4y76gb3fted76N7n2vtzxnyc630b3v9ZFyh9ro3vf6SEP6nW+je9/rI/MOtdG97/WRPfKcJTvfRve+10fKnW+je9/rI+0OtdG97/WRgcw730b3vtdH9h11o3vf6w610b3v9ZGC1DvfRve+10f6HWqje9/rIxNZd76N7n2vl9z7Xneoje59r48UpN75Nrr3vT7S76gb3fted76N7n2vj6w730b3vtdbnrNkh9ro3vf6SEHqnW+je9/rI/0OtdG97/WRiaw730b3vtdbnrNk59vo3vf6SLlDbXTve32kIf3Ot9G97/WReUfd6N73ukNtdO97veU5Sx657lAb3fteH6lIu6NudO971f0ly973+shE1pV2o3vb66V22tGl1ii5snB0b3m9Ln5OEd/Ec4jELuY5Q26VVwKO7t2ut+orC0f3Xtf9zcze6noruRJwdG90vZVdCTi6t7neKq4sHN2bXPfQ3Htcb9VXAo7uHa63Wlfuje79rbfSUXYl4Oje3Hqrc/JeXbPXHrc8J+/VNXvtccm99jg2fK89bnnO+atV9trjloY85/zVNXvtccuTtva977XHLXvkXnvcciEFqUhDOjKQ0ApaQWtoDa2hNbSG1tAaWkNraD20a2/rLRdSkIo0pCMDmchCQlvQFrQ5v6c95/e05/ye9pzf057ze9pzfk97zu9pz/k97Tm/pz3n97QFmkATaHN+T3vO72kLNIEm0BSaQpvze9pzfk97zgLrtbf1ltDmLLD2nAXWnrPA2nN+T9ugGTSDNmeBtY1KGpU07s24N+PerjM3+0XOWWBtp5JOJZ1KOpV0aA7NoTm0oJLBvQX3FtxbcG9BJYNKBpUMKhlUMqlkQktoCS2hJZVM7i25t+TeknsrKllUsqhkUcmikkUlC1pBK2gFralkc2/NvTX31txbU8mmkk0lm0rOWWA7JqPEjjm/Z8ecBbZjzgLbMWeB7ZizwHbMWWA75iywHXMW2I7JKLFrb+v5Iu2Ys8B2zCyxY2aJHTNL7JiMEjsWtAVtQVvQZpbYIdybcG/CvQn3Jj4vcmaJHXMW2I45C2yHUEmlkgpNoSk0haZUUrk35d6Ue1PuzaikUUmjkkYljUoalTRoBs2gGTSnks69Offm3Jtzb04lnUo6lXQq6VQyqGRAC2gBLaAFlQzuLbi34N6Ce0sqmVQyqWRSyaSSSSUTWkJLaAmtqGRxb8W9FfdW3FtRyaKSRSWLShaVbCrZ0BpaQ2toTSWbe2vurbm3OQts197W/SLX5B3ZmrwjW5N3ZGvyjmxNRoktZslilixmyWKWrMkosTUZJbYmo8TWZJTYmowSu/a2Xi9y8o5sTd6Rrck7sjV5R7Ymo8QWs2QxSxazZDFL1mSU2BLuTbg34d6Ee1MqqVRSqaRSSaWSSiWZJYtZspgli1myjEoa92bcm3Fvxr0ZlTQqaVTSqKRRSaeSzJLFLFnMksUsWU4lnXtz7s25N+fegkoGlQwqGVQyqGRQSWbJYpYsZslilqykksm9JfeW3Ftyb0klk0omlUwqmVSyqCSzZDFLFrNkMUtWUcni3op7K+6tuLemkk0lm0o2lWwq2VSSWbKYJYtZspglMrkCJqxLhHWJsC4R1iXX3tb9ImXyjkwm78hk8o5MJu/IZDJKTJglwiwRZokwS2Q8jgnrEmFdIqxLhHXJtbf1epGTd2QyHsdkPI7JeByT8TgmzBJhlgizRJglolSSdYmwLhHWJcK6RJRKKpVUKqlUUqmkUUlmiTBLhFkizBIxKsm6RFiXCOsSYV0iTiWdSjqVdCrpVNKpJLNEmCXCLCHT1ch0NTJdjUxXI9PVyHQ1CSoZVDKoZFDJoJJJJZklZLoama5GpquR6WpkuhqZriasS4R1iRSVLCpZVLKoZFHJopLMEjJdjUxXI9PVyHQ1Ml2NTFcj09WEdYk0lWwq2VSyqSQeR/E4ZLoama5GpquR6WpkuhqZrkamq5Hpasq6RPE4ZLoama5GpquR6WqKxyHT1ch0NTJdjUxXI9PVyHQ1Ml2NTFdT1iWKxyHT1ch0NTJdjUxXUzwOma5GpquR6WpkuhqZrkamq5HpamS6mrIuUTwOma5GpquR6Wpkupricch0NWVdoqxLlHUJma6mzBJlliizRFmXKOsSZZYos+TOdNUte+Q1S2zLhRSkIg3pyEAmspA9MqEltISW0BJaQktoCS2hJbSCVtAKWkEraAWtoBW0glbQGlpDa2gNraE1tGuWxJabVlsWP+3np3ema2y5+KnwU+WnhnRkIBNZyJ6LXbNk//SaJddPhZ8qP4V2zZLrp9CuWXL9FNqCJtAEmkC7zgLrloZ8ztyYzZkbszlzYzbn98zmzI3ZnLmxa2+r7l/Ys+SWz5kbszlzYzZnbswUmkJTaHPmxsygzZkbszlzYzZnbszmzI2ZQZszN2Zz5sbMoBm0yRUwm1wBM4fm0Bza5AqYzfk9M4c2uQJmkytgFtAC2uQKmE2ugFlAC2gBbXIFzOb8nllAm1wBs8kVMEtoCW1yBcySLkloCS2hJV1SvG8FbXIFzIouKWgFreiSoksKWkFraE2XNO9bQ2t6sumShtbQmi6ZXAHzOQtsPrkC5pMrYD65AuZzfs98cgXMJ1fAfHIFzCdXwPyANrkC5pMrYL6gLWgL2uQKmM/5PfMFbXIFzCdXwFygCbTJFTCfXAFzgSbQBNrkCpjP+T1zgTa5AuaTK2Cu0BTa5AqYT66AuUJTaAptcgXMmSVu0CZXwHxyBcwNmkGbXAHzyRUwN2gGzaE5XcIscYc2uQLmTpc4NIfmdInTJQEtoAW0oEuYJR7Qgp4MuiSgBbSkS5IuSWgJLaElXcIs8YSW9GTSJQWtoBVdUnRJQStoBa3oEmaJF7SmJ5suaWgNremSpksaWkNraJMrYMEsickVsJhcAYvJFbCYXAGLyRWwmFwBi8kVsJizwBYHtAVtcgUsmCWxoE2ugMXkClgsaAva5ApYTK6AhUATaAJtcgUsmCUh0CZXwGJyBSxYl4RAm1wBi8kVsFBoCk2hTa6ABbMkFNrkClhMroCFQTNokytgMbkCFqxLwqAZtMkVsGCWhEGbXAELp0scmkNzusTpEtYl4dAcmtMlzJIIaEFPBl0S0AJa0CVBl7AuiYCW0JIuYZZEQkt6MumShJbQki5JuoR1SRS0glZ0CbMkClrRk0WXFLSC1nRJ0yWsS6KhNbSmS5gl0dCanpxcAcvJFbCcXAHLyRWwnFwBS9YlObkClpMrYDm5ApbMkjygTa6A5eQKWC5oC9rkClhOroAl65Jc0Ba0yRWwZJakQJtcAcvJFbAUaHicxOMkHidZlyQeJ/E4ObkClsySxOMkHifxOInHSTxO4nESj5OsSxKPk3icxOMksyTxOInHSTxO4nESj5N4nMTjJOuSxOMkHifxOMksSTxO4nESj5N4nMTjJB4n8TjJuiTxOInHSTxOMksSj5N4nMTjkOlqicdJPE7icZJ1SeJxEo+TeJxkliQeJ/E4icdJPE7icRKPk3gcMl0t8TiJx0k8TjJLEo+TeJzE4yQeJ/E4icdJPA6ZrlZ4nMLjFB6nmCWFxyk8TuFxCo9TeJzC4xQeh0xXKzxO4XEKj1PMksLjFB6n8DiFxyk8TuFxCo9DpqsVHqfwOIXHKWZJ4XEKj1N4nMLjFB6n8DiFxyHT1QqPU3icwuMUs6TwOIXHKTxO4XEKj1N4nMLjkOlqhccpPE7hcYpZUnicwuMUHqfwOIXHKTxO4XHIdLXC4xQep/A4xSwpPE7hcQqPU3icwuMUHqfwOGS6WuFxCo9TeJxilhQep/A4hccpPE7hcQqPU3gcMl2t8DiFxyk8TjFLCo9TeJzC4xQep/A4hccpPA6ZrlZ4nMLjFB6nmSWNx2k8TuNxrn2vcf2uI0/amXpj177XWxbypJ37rO3a93qm3ti17/WWgnxO+FjPmRvrOXNjPWdurOfMjfWc37OeMzfWc+bGrn2vZwCOXfteb/mcubGeMzfWc+bGWqAJNIE2Z26sFdqcubGeMzfWc+bGes7cWCu0OXNjPWdurBWaQptcAevJFbA2aAbNoE2ugPWc37M2aJMrYD25AtYOzaFNroC18745NIfm0CZXwHrO71k7tMkVsJ5cAeuAFtCCLgm6JKAFtIAWdEnyviW0yRWwTrokoSW0pEuSLkloCa2gFV1SvG8FrejJoksKWkEruqTokobW0Bpa0yXN+9bQmp5suqShTa6AH5Mr4MfkCvgxZ4H9mFwBPyZXwI/JFfBjzu/5MbkCfkyugB+TK+DHgragTa6AHzNL/FjQFrQFbXIF/Jjze34saJMr4MfkCvgh0ATa5Ar4MbkCfgg0gSbQJlfAj5klfii0yRXwY3IF/FBoCm1yBfyYXAE/FJpCM2iTK+CH8b4ZtMkV8GNyBfwwaAZtcgX8MLrEoTk0h+Z0ifO+ObTJFfDD6RKH5tCCLgm6JKAFtIAWdEnwvgW0oCeDLkloCS3pkqRLElpCS2hJlyTvW0IrerLokoJW0IouKbqkoBW0glZ0SfO+NbSmJ5suaWgNremSpksa2uQK+JpcAV+TK+CLWbImV8DX5Ar4mlwBX5Mr4GtyBXxNroCvyRXwtaAtaAva5Ar4YpasBW1yBXxNroCvBW1Bm1yBD7mQ0ASaQJtcAV/MkiXQJlfA1+QK+FJoCm1yBXxNroAvhabQFNrkCvhiliyFNrkCviZXwJdBM2iTK+BrcgV8GTSDZtCMLmGWLIc2uQK+nC5xaA7N6RKnSxyaQwtoQZcwS1ZAC3oy6JKAFtCCLgm6JKEltISWdAmzZCW0pCeTLkloCa3okqJLClpBK2hFlzBLVkErerLokobW0JouabqkoTW0htZ0CbNkTa6Ay+QKuEyugMvkCrhMroDL5Aq4TK6AC+sSmVwBl8kVcJlcARdmiSxokyvgMrkCLgvagjYex2U8jgvrElnQBNrkCrgwS0SgjcdxGY/jItAE2ngcl/E4LqxLRKEptPE4LswSUWjjcVzG47goNIU2HsdlPI4L6xIxaAZtPI4Ls0QM2ngcF6NLHJpDc7rE6RLWJeLQHJrTJcwScWhBTwZdEtACWtAlQZewLpGAFtCCLmGWSEJLejLpkoSW0JIuSbqEdYkktIJWdAmzRApa0ZNFlxS0glZ0SdElrEukoTW0pkuYJdLQmp5suqSh4XEUj6N4HDJdXfE4isdRPI4ySxSPo3gcxeMoHkfxOIrHUTwOma6ueBzF4ygeR5klisdRPI7icRSPo3gcxeMoHodMV1c8juJxFI+jzBLF4ygeR/E4isdRPI7icRSPQ6arKx5H8TiKx1FmieJxFI+jeBzF4ygeR/E4isch09UVj6N4HMXjKLNE8TiKx1E8juJxFI+jeBzF45Dp6orHUTyO4nGUWaJ4HMXjKB5H8TiKx1E8juJxyHR1xeMoHkfxOMosUTyO4nEUj6N4HMXjKB5H8ThkurricRSPo3gcZZYoHkfxOIrHufa99vW7jtzvm2+ZyLqzcHzve91ZOL73ve6oG9/7Xh8pSEXanXrje9/rIwOZdxaO732vO/XG977XW56z5JHrDsDxve/1kXqn3vje9/pIR8YdgON73+sj60698b3v9ZbnLHnkugNwfO97faTeWTi+973uABzf+14fGXcAju99r4+sO/XG977XW56z5JHrDsDxve/1kXqn3vje9/pIR8YdgON73+sj6w7A8b3v9ZY7peRMvfG97/WRgtQ7AMf3vtdH+p2F43vf60698b3v9ZGF7DsAx/e+10euO/XG977XRyrS7gAc3/teHxl36o3vfa+PLGTfATi+970+ct1ZOL73ve4AHN/7Xh9pdwCO732vj4w79cb3vtdHFrLvABzf+14fue7UG9/7Xh+pSLsDcHzve31k3AE4vve9PrLu1Bvf+15vec6SR647AMf3vtdH6p2F43vfq17tec6SRwYy79Qb3/teH9kjz1mys3B873vdqTe+970+UpGGdGRcGTi+t73eqkb1rfae1/107C2vG7l3vJ4JOb43vJ65OL73u97Kr1wc37tdb5VXQo7vva5xXa8fdU6P3WN7o+ut5MrF8b3N9VZ2JeT43uS6R+ne43qrvHJxfO9wvVVfaTi+97feao2SKxfH9+bWW52Td/fStbf1lufk3b107W295Tnnjw3fa49L7rXHbqBrb+stBXnO+d1L197WW560te99rz1umchC9si99rjlQgpSkYaEZtAMmkEzaA7NoTk0h+bQHJpDc2gOzaEFtIAW0AJaQAtoAS2gBbSANuf33CdXwH1yBdzn/J77nN9zn/N77nN+z33O77nP+T33Ob/nXtAKWkGb83vuc37PvaAVtIJW0AranN9zn/N7fu1t3R+0197WW0Kbs8Duc37Pfc7vuc/5Pfc5C+wxZ4E95vyex5zf85jz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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransferLib::{spendFromBurnAddresses, BurnDataPublic, BurnDataPrivate, SignatureData};\n\n// why only 4?\nglobal BURN_ADDRESSES_LEN: u32 = 4; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    chain_id: Field, // pub key word is removed since we don't use cross-chain functionality\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_data_public: pub [BurnDataPublic; BURN_ADDRESSES_LEN],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    burn_data_private: [BurnDataPrivate; BURN_ADDRESSES_LEN],\n    amount_burn_addresses:u32 // always one but still a input to be consistent with other circuits\n) {\n\n    // one signature for all burns. Cheaper, better UX, but you cant spent with different private keys\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        chain_id,\n        amount,\n        burn_data_public,\n        //private\n        burn_data_private,\n        pub_key_x_field,      \n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransfer4In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"ZKWORMHOLE\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_BURNED_DOMAIN: Field = 0x544f54414c5f4255524e4544; // UTF8(\"TOTAL_BURNED\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x544f54414c5f5350454e44; // UTF8(\"TOTAL_SPEND\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 4n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\nglobal POW_DIFFICULTY: Field =  0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn merkle_hash_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\n\n// @notice chain_id is not used in this repo but can be used to make this cross-chain like warptoad\n// viewing_key is there so it is committed in the burn address, \n// to prevent spenders from using a different key and pretend they never spent before when ever the create the nullifier at account_nonce=0\nfn hash_blinded_burn_address_data(spending_pub_key_x:Field, chain_id:Field, viewing_key:Field) -> Field {\n    Poseidon2::hash([spending_pub_key_x, viewing_key, chain_id], 3)\n}\n\n// pow_nonce acts both as a PoW to make finding a hash collision between EOA and BurnAddress harder\nfn hash_burn_address(blinded_address_data_hash: Field, pow_nonce: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([blinded_address_data_hash, pow_nonce, PRIVATE_ADDRESS_TYPE], 3);\n    let pow_hash: Field = Poseidon2::hash([pow_nonce, address_hash], 2); \n    assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: pow_nonce results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_burned_leaf(private_address: Field, total_burned: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_burned, TOTAL_BURNED_DOMAIN],\n        3,\n    )\n}\n\n/*\ntotal_spent: total_spend for that specific burn address\nblinded_address_data_hash: this ties this commitment to the chain_id which is crucial for cross-chain warptoad like use cases, also ties it to the rest of the data in that hash\nviewing_key: is already inside blinded_address_data_hash, but is used again here so blinded_address_data_hash is sharable so sender can create burn addresses on the recipients behave\n*/\nfn hash_total_spent_leaf(total_spent: Field, account_nonce: Field, blinded_address_data_hash:Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, blinded_address_data_hash, viewing_key, TOTAL_SPENT_DOMAIN], 5)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// viewing_key is so others cant try and find the pre-image (since this hash is posted onchain)\n// and viewing_key is also committed inside the burn address pre-image, so spender is forced to only use that viewing key. To prevent them using a new one and pretending they never spent before\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    // TODO maybe we can save on memory computing indices on the spot instead?\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnDataPublic {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnDataPrivate {                \n    //-----very privacy sensitive data -----\n    /*blinds note hashes and nullifiers, separate from blinding_pow to support senders making fresh burn account on the recipients behave*/\n    viewing_key: Field,    \n    /*Serves as a PoW to defend against the address collision attack (similar problem to eip-3607) */\n    pow_nonce: Field,\n    // amounts\n    total_burned: Field,              \n    prev_total_spent: Field,  \n    amount_to_spend: Field,                     \n    // inclusion proof\n    prev_account_nonce: Field,               \n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData,\n}\n\npub fn spendFromBurnAddresses(\n    //public\n    root: Field, \n    chain_id: Field,\n    total_amount_to_spent: Field, \n    burn_data_public: [BurnDataPublic],\n    //private\n    burn_data_private: [BurnDataPrivate],\n    spending_pub_key_x: Field,    \n    amount_burn_addresses: u32\n) {\n    let mut amount_verified: Field = 0;\n    for i in 0..burn_data_private.len() {\n        if( i < amount_burn_addresses) {\n            spendFromBurnAddress(\n                //public\n                root,\n                chain_id,\n                burn_data_public[i].account_note_hash,\n                burn_data_public[i].account_note_nullifier,\n\n                //private\n                spending_pub_key_x,\n                burn_data_private[i].viewing_key,\n                burn_data_private[i].pow_nonce,\n                burn_data_private[i].amount_to_spend,\n                burn_data_private[i].total_burned,\n                burn_data_private[i].prev_total_spent,\n                burn_data_private[i].prev_account_nonce,\n                burn_data_private[i].prev_account_note_merkle_data,\n                burn_data_private[i].total_burned_merkle_data,\n            );\n\n            amount_verified = amount_verified + burn_data_private[i].amount_to_spend;\n\n        }\n    }\n\n    assert(amount_verified == total_amount_to_spent, \"aggregated burn address amounts do not match amount to spend\");\n}\n\npub fn spendFromBurnAddress(\n    // public\n    root: Field,\n    chain_id: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    // private, keys\n    spending_pub_key_x: Field,\n    viewing_key: Field,\n    pow_nonce: Field,\n\n    // private balances\n    amount_to_spend: Field,\n    total_burned: Field,\n    prev_total_spent: Field,\n\n    // private inclusion proof\n    prev_account_nonce: Field,\n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData\n) {\n  \n    let blinded_address_data_hash: Field = hash_blinded_burn_address_data(spending_pub_key_x, chain_id, viewing_key );\n    let private_address: Field = hash_burn_address(blinded_address_data_hash, pow_nonce);\n\n    // verify how much is \"burned\"\n    let total_burned_leaf: Field = hash_total_burned_leaf(private_address, total_burned);\n    let root_total_burned: Field = merkle_hash_root(total_burned_leaf, total_burned_merkle_data);\n    assert(root_total_burned == root, \"total_burned merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        // verify how much was spent in total before this tx: verify prev_total_spent\n        let prev_account_note_hash: Field = hash_total_spent_leaf(prev_total_spent, prev_account_nonce,blinded_address_data_hash, viewing_key);\n        let computed_prev_root: Field = merkle_hash_root(prev_account_note_hash, prev_account_note_merkle_data);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        // we have to skip merkle proofs since a previous spent balance does not exist\n\n        // this assert prevents you from effectively burning money on the first tx\n        assert(prev_total_spent == 0, \"prev_account_nonce = 0 but prev_total_spent is not 0.\");\n    }\n\n    // nullify the prev_total_spent, which is inside prev_account_note_hash and tied to prev_account_nonce + viewing_key\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    // check amount spent\n    let new_total_spent: Field = prev_total_spent + amount_to_spend;\n    assert(lower_then_or_equal(new_total_spent, total_burned), \"spend exceeds total received\");\n\n    //\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_total_spent_leaf(new_total_spent, current_account_nonce,blinded_address_data_hash, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransferLib/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}