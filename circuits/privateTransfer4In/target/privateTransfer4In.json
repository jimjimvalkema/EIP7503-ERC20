{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"10403532059934785734","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"chain_id","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_data_public","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPublic","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransferLib::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"burn_data_private","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPrivate","fields":[{"name":"viewing_key","type":{"kind":"field"}},{"name":"pow_nonce","type":{"kind":"field"}},{"name":"total_burned","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"amount_to_spend","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":42,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":42,"type":{"kind":"field"}}}]}},{"name":"total_burned_merkle_data","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":42,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":42,"type":{"kind":"field"}}}]}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7277924040473639006":{"error_kind":"string","string":"total_burned merkle proof invalid"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"10942716740258210273":{"error_kind":"string","string":"prev_account_nonce = 0 but prev_total_spent is not 0."},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17791442556191318216":{"error_kind":"string","string":"aggregated burn address amounts do not match amount to spend"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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lBglRovRYrQYLUaL0WK0GC1Gi9FibDG2GFuMLcYWY4uxxdgPxtnae0vNU82D8fgOI2dJmZRLhVRKlZQYI8Y8GXUcUkvqyajDpUIqpUqqpbbUyfjoxFqHlBjLpFwqpFJKjCXGEmPNU9khtaR0H6b7MN2H5fNVWT1p1lJbSrVy1crFcDFcDBfDVSvXfbjuw3UfrvsI1SpUq1CtQrUK1SpUqxAjxAgxQoxUrVL3kbqP1H2k7iNVq1StUrVK1SpVq1KtSowSo8QoMUq1Kt1H6T5K91G6j1atWrVq1apVq1atWrVqMVqMFqPF2KrV1n1s3cfWfWzdx1attmql57z0nJee8xrVSs956TkvPeel57z0nJee8xrdx+g+5nkffTxr1XrO+zAplwqplCpdpaW2lBjrkFpSJuVSIfWsVa9nrXq11JZ61qrtkBJDz3nrOW89520ppfsw3YfpPkz34aqVq1auWrlq5aqVq1Z6zlvPees5bz3nHapV6D5C9xG6j9B9hGoVqlWoVqFahWqVqpWe89Zz3nrOW895p2qVuo/UfaTuI3UfpVqValWqValWpVqVaqXnvPWct57z1nPerVq17qN1H637aN1Hq1atWrVq1apVq1ZbtdJz3nrOW8956znvrVpt3cfWfWzdx9Z9jGo1qtWoVqNajWo1qpWe89Zz3nrOW8/5Pg6pJWVSLhVSz1rt41mrfbTUlnrWaq9DSgw951vP+dZzvldKlVRLbSndhz1rte1Zq20m5VIhlVJi6Dnfes63nvPtqpU+z7c+z7c+z7c+z7erVq5auWrlqpWrVqFa6Tnfes63nvOt53yHaqXP863P863P863P852qVapWqVqlapWqVapWes63nvOt53zrOd+lWunzfOvzfOvzfOvzfJdqVapVqValWpVq1aqVnvOt53zrOd96znerVvo83/o83/o83/o831u12qrVVq22arVVq61a6Tnfes63nvOt53xr3b71eb71eb71eb71eb5HtRrVSuv2rXX71rp9tG4fPeej53z0nI+e89G6ffR5Pvo8H32ejz7PR+v20bp9tG4frdtH6/bRun30nI+e89FzPnrOR+v20ef56PN89Hk++jwfrdtH6/bRun20bh+t20fr9tFzPnrOR8/56DkfrdtHn+ejz/PR5/no83y0bh+t20fr9tG6fbRuH63bR8/56DkfPeej53y0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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransferLib::{spendFromBurnAddresses, BurnDataPublic, BurnDataPrivate, SignatureData};\n\n// should not go smaller then 2 because then the fact that someone is consolidating balances leaks\nglobal BURN_ADDRESSES_LEN: u32 = 4; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    chain_id: Field, // pub key word is removed since we don't use cross-chain functionality\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_data_public: pub [BurnDataPublic; BURN_ADDRESSES_LEN],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    burn_data_private: [BurnDataPrivate; BURN_ADDRESSES_LEN],\n    amount_burn_addresses: u32 // always one but still a input to be consistent with other circuits\n) {\n\n    // one signature for all burns. Cheaper, better UX, but you cant spent with different private keys\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        chain_id,\n        amount,\n        burn_data_public,\n        //private\n        burn_data_private,\n        pub_key_x_field,      \n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/EIP7503-ERC20/circuits/privateTransfer4In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"ZKWORMHOLE\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_BURNED_DOMAIN: Field = 0x544f54414c5f4255524e4544; // UTF8(\"TOTAL_BURNED\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x544f54414c5f5350454e44; // UTF8(\"TOTAL_SPEND\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 4n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\nglobal POW_DIFFICULTY: Field =  0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\n// ---------- why max tree depth 42 --------------------\n// const erc20Tps = 35_000;\n// const zkwormholeTps = erc20Tps / 10;\n// const bulkMerkleInserts = 1; // becomes relevant once large reMints emitting multiple commitments are more gas efficient then simple burns. \n// const insertsPerYear = bulkMerkleInserts * zkwormholeTps * 60*60*24*365;\n// const treeDepth = 42;\n// (2**treeDepth) / insertsPerYear\n\n// depth 42 allows for 40 years on a 35_000 tps chain (megaEth recent stress test) if every tx is a burn tx\n// after that, any tokens burned will be actually be burned for real and you will never get them back!\n// any tokens before that are fine. That leaf will always exist and the contract always stores that root.\n// you can burn tokens before the tree is at a depth above 42, and reMint them a 100 years later those will always be there.\n// the ui can warn you, but contract cant prevent it because the contract can't know if your address is a burn address or a normal address!\n// ----------------------------------------------------------\nglobal MAX_TREE_DEPTH: u32 = 42; // TODO make this configurable outside lib\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn merkle_hash_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\n\n// @notice chain_id is not used in this repo but can be used to make this cross-chain like warptoad\n// viewing_key is there so it is committed in the burn address, \n// to prevent spenders from using a different key and pretend they never spent before when ever the create the nullifier at account_nonce=0\nfn hash_blinded_burn_address_data(spending_pub_key_x:Field, chain_id:Field, viewing_key:Field) -> Field {\n    Poseidon2::hash([spending_pub_key_x, viewing_key, chain_id], 3)\n}\n\n// pow_nonce acts both as a PoW to make finding a hash collision between EOA and BurnAddress harder\nfn hash_burn_address(blinded_address_data_hash: Field, pow_nonce: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([blinded_address_data_hash, pow_nonce, PRIVATE_ADDRESS_TYPE], 3);\n    let pow_hash: Field = Poseidon2::hash([pow_nonce, address_hash], 2); \n    assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: pow_nonce results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_burned_leaf(private_address: Field, total_burned: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_burned, TOTAL_BURNED_DOMAIN],\n        3,\n    )\n}\n\n/*\ntotal_spent: total_spend for that specific burn address\nblinded_address_data_hash: this ties this commitment to the chain_id which is crucial for cross-chain warptoad like use cases, also ties it to the rest of the data in that hash\nviewing_key: is already inside blinded_address_data_hash, but is used again here so blinded_address_data_hash is sharable so sender can create burn addresses on the recipients behave\n*/\nfn hash_total_spent_leaf(total_spent: Field, account_nonce: Field, blinded_address_data_hash:Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, blinded_address_data_hash, viewing_key, TOTAL_SPENT_DOMAIN], 5)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// viewing_key is so others cant try and find the pre-image (since this hash is posted onchain)\n// and viewing_key is also committed inside the burn address pre-image, so spender is forced to only use that viewing key. To prevent them using a new one and pretending they never spent before\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    // TODO maybe we can save on memory computing indices on the spot instead?\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnDataPublic {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnDataPrivate {                \n    //-----very privacy sensitive data -----\n    /*blinds note hashes and nullifiers, separate from blinding_pow to support senders making fresh burn account on the recipients behave*/\n    viewing_key: Field,    \n    /*Serves as a PoW to defend against the address collision attack (similar problem to eip-3607) */\n    pow_nonce: Field,\n    // amounts\n    total_burned: Field,              \n    prev_total_spent: Field,  \n    amount_to_spend: Field,                     \n    // inclusion proof\n    prev_account_nonce: Field,               \n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData,\n}\n\npub fn spendFromBurnAddresses(\n    //public\n    root: Field, \n    chain_id: Field,\n    total_amount_to_spent: Field, \n    burn_data_public: [BurnDataPublic],\n    //private\n    burn_data_private: [BurnDataPrivate],\n    spending_pub_key_x: Field,    \n    amount_burn_addresses: u32\n) {\n    let mut amount_verified: Field = 0;\n    for i in 0..burn_data_private.len() {\n        if( i < amount_burn_addresses) {\n            spendFromBurnAddress(\n                //public\n                root,\n                chain_id,\n                burn_data_public[i].account_note_hash,\n                burn_data_public[i].account_note_nullifier,\n\n                //private\n                spending_pub_key_x,\n                burn_data_private[i].viewing_key,\n                burn_data_private[i].pow_nonce,\n                burn_data_private[i].amount_to_spend,\n                burn_data_private[i].total_burned,\n                burn_data_private[i].prev_total_spent,\n                burn_data_private[i].prev_account_nonce,\n                burn_data_private[i].prev_account_note_merkle_data,\n                burn_data_private[i].total_burned_merkle_data,\n            );\n\n            amount_verified = amount_verified + burn_data_private[i].amount_to_spend;\n\n        }\n    }\n\n    assert(amount_verified == total_amount_to_spent, \"aggregated burn address amounts do not match amount to spend\");\n}\n\npub fn spendFromBurnAddress(\n    // public\n    root: Field,\n    chain_id: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    // private, keys\n    spending_pub_key_x: Field,\n    viewing_key: Field,\n    pow_nonce: Field,\n\n    // private balances\n    amount_to_spend: Field,\n    total_burned: Field,\n    prev_total_spent: Field,\n\n    // private inclusion proof\n    prev_account_nonce: Field,\n    prev_account_note_merkle_data: MerkleData,\n    total_burned_merkle_data: MerkleData\n) {\n  \n    let blinded_address_data_hash: Field = hash_blinded_burn_address_data(spending_pub_key_x, chain_id, viewing_key );\n    let private_address: Field = hash_burn_address(blinded_address_data_hash, pow_nonce);\n\n    // verify how much is \"burned\"\n    let total_burned_leaf: Field = hash_total_burned_leaf(private_address, total_burned);\n    let root_total_burned: Field = merkle_hash_root(total_burned_leaf, total_burned_merkle_data);\n    assert(root_total_burned == root, \"total_burned merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        // verify how much was spent in total before this tx: verify prev_total_spent\n        let prev_account_note_hash: Field = hash_total_spent_leaf(prev_total_spent, prev_account_nonce,blinded_address_data_hash, viewing_key);\n        let computed_prev_root: Field = merkle_hash_root(prev_account_note_hash, prev_account_note_merkle_data);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        // we have to skip merkle proofs since a previous spent balance does not exist\n\n        // this assert prevents you from effectively burning money on the first tx\n        assert(prev_total_spent == 0, \"prev_account_nonce = 0 but prev_total_spent is not 0.\");\n    }\n\n    // nullify the prev_total_spent, which is inside prev_account_note_hash and tied to prev_account_nonce + viewing_key\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    // check amount spent\n    let new_total_spent: Field = prev_total_spent + amount_to_spend;\n    assert(lower_then_or_equal(new_total_spent, total_burned), \"spend exceeds total received\");\n\n    //\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_total_spent_leaf(new_total_spent, current_account_nonce,blinded_address_data_hash, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n\n}","path":"/home/jimjim/Desktop/EIP7503-ERC20/circuits/privateTransferLib/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}