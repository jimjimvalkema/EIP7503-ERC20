{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"17923789094063681103","abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"signature_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"burn_address_public_proof_data","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPublic","fields":[{"name":"account_note_hash","type":{"kind":"field"}},{"name":"account_note_nullifier","type":{"kind":"field"}}]}},"visibility":"public"},{"name":"signature_data","type":{"kind":"struct","path":"privateTransferLib::SignatureData","fields":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"viewing_key","type":{"kind":"field"},"visibility":"private"},{"name":"burn_address_private_proof_data","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"privateTransferLib::BurnDataPrivate","fields":[{"name":"total_received","type":{"kind":"field"}},{"name":"prev_total_spent","type":{"kind":"field"}},{"name":"prev_account_nonce","type":{"kind":"field"}},{"name":"prev_account_note_merkle","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"total_received_merkle","type":{"kind":"struct","path":"privateTransferLib::MerkleData","fields":[{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices","type":{"kind":"array","length":40,"type":{"kind":"integer","sign":"unsigned","width":1}}},{"name":"siblings","type":{"kind":"array","length":40,"type":{"kind":"field"}}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"shared_secret","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"amount_burn_addresses","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"189327025425157196":{"error_kind":"string","string":"first spend but prev_total_spent != 0"},"1787045411737359460":{"error_kind":"string","string":"account note hash mismatch"},"7960777075148875133":{"error_kind":"string","string":"spend exceeds total received"},"9204627695454606589":{"error_kind":"string","string":"invalid signature"},"11253596570166707052":{"error_kind":"string","string":"nullifier mismatch"},"12149997590364146557":{"error_kind":"string","string":"total_received merkle proof invalid"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"14666658369005863707":{"error_kind":"string","string":"aggregated burn address amounts do not match target amount"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"17816918312947582266":{"error_kind":"string","string":"prev account note merkle proof invalid"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\npub fn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use privateTransferLib::{spendFromBurnAddresses, BurnDataPublic, BurnDataPrivate, SignatureData};\n\n// why only 4?\nglobal BURN_ADDRESSES_LEN: u32 = 4; \nfn main(\n    //----- public inputs\n    root: pub Field,\n    amount: pub Field,\n    signature_hash: pub [u8;32],\n    burn_address_public_proof_data: pub [BurnDataPublic; BURN_ADDRESSES_LEN],\n    // --- private inputs ---\n    signature_data: SignatureData,      \n    viewing_key: Field,\n    burn_address_private_proof_data: [BurnDataPrivate; BURN_ADDRESSES_LEN],\n    amount_burn_addresses:u32 // always one but still a input to be consistent with other circuits\n) {\n    let valid_signature: bool = std::ecdsa_secp256k1::verify_signature(\n        signature_data.public_key_x,\n        signature_data.public_key_y,\n        signature_data.signature,\n        signature_hash,\n    );\n    assert(valid_signature, \"invalid signature\");\n\n    // slice off the first byte so it fits in the field\n    let mut small_pub_key_x: [u8; 32] = signature_data.public_key_x;\n    small_pub_key_x[0] = 0;\n    let pub_key_x_field: Field = Field::from_be_bytes(small_pub_key_x);\n\n    spendFromBurnAddresses(\n        root,\n        amount,\n        burn_address_public_proof_data,\n        //private\n        burn_address_private_proof_data,\n        pub_key_x_field,      \n        viewing_key,\n        amount_burn_addresses\n    )\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransfer4In/src/main.nr"},"51":{"source":"use dep::poseidon::poseidon2::Poseidon2;\n//use dep::poseidon::{poseidon};\n\n//use dep::keccak256::keccak256;\nuse dep::std::field::{bytes32_to_field, bn254::{\n    //assert_lt, \n    gt\n}};\nuse binary_merkle_root::binary_merkle_root;\n\n// domain separators\nglobal PRIVATE_ADDRESS_TYPE: Field = 0x5a4b574f524d484f4c45; // UTF8(\"ZKWORMHOLE\").toHex() [...new TextEncoder().encode(\"zkwormhole\")].map(b=>b.toString(16)).join('')\nglobal TOTAL_RECEIVED_DOMAIN: Field = 0x52454345495645445F544F54414C; // UTF8(\"total_received\").toHex()\nglobal TOTAL_SPENT_DOMAIN: Field = 0x5350454E545F544F54414C; // UTF8(\"total_spent\").toHex()\n// @TODO find out what number would be secure enough!\n// const POW_LEADING_ZEROS = 3n;\n// const POW_DIFFICULTY    = 16n ** (64n - POW_LEADING_ZEROS) - 1n;\n//global POW_DIFFICULTY: Field =  0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;//0x000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // find a nonce that result in a hash that is hash < POW_DIFFICULTY\n\nglobal MAX_TREE_DEPTH: u32 = 40;\n\nfn merkle_hasher(leaves: [Field; 2]) -> Field {\n    Poseidon2::hash(leaves, 2)\n}\n\nfn compute_root(\n    leaf: Field,\n    merkle_data: MerkleData,\n) -> Field {\n    binary_merkle_root(\n        merkle_hasher,\n        leaf,\n        merkle_data.depth,\n        merkle_data.indices,\n        merkle_data.siblings,\n    )\n}\n\nfn get_private_address(pub_key: Field, shared_secret: Field ) -> Field {\n    let address_hash: Field = Poseidon2::hash([pub_key,shared_secret, PRIVATE_ADDRESS_TYPE], 3);\n    // Here is some disabled code for a PoW, we can later use shared_secret as a PoW that is derived by the sender to also be a PoW\n    // let pow_hash: Field = Poseidon2::hash([shared_secret, address_hash], 2); \n    // assert_lt(pow_hash, POW_DIFFICULTY); //\"pow failed: shared_secret results in hash that is not < POW_DIFFICULTY\"\n\n    // replace last 12 bytes with zero since address is only 20 bytes (noir doesn't support a nicer method hence whacky for loop)\n    let mut address_bytes: [u8;32] = address_hash.to_be_bytes();\n    for index in 0..12 {\n        address_bytes[index] = 0;\n    }\n    \n    bytes32_to_field(address_bytes)\n}\n\nfn hash_total_received_leaf(private_address: Field, total_received: Field) -> Field {\n    Poseidon2::hash(\n        [private_address, total_received, TOTAL_RECEIVED_DOMAIN],\n        3,\n    )\n}\n\n// prev_account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_account_note(total_spent: Field, account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([total_spent, account_nonce, viewing_key, TOTAL_SPENT_DOMAIN], 4)\n}\n\n// account_nonce makes sure the hash is never the same even when the total_spent is not different\n// secret is so others cant try and find the pre-image (since this hash is posted onchain)\nfn hash_nullifier(account_nonce: Field, viewing_key: Field) -> Field {\n    Poseidon2::hash([account_nonce, viewing_key], 2)\n}\n\nfn lower_then_or_equal(a: Field, b: Field) -> bool {\n    !gt(a, b)\n}\n\npub struct SignatureData {\n    pub public_key_x: [u8; 32],\n    pub public_key_y: [u8; 32],\n    pub signature: [u8; 64],\n}\n\npub struct MerkleData {\n    depth: u32,\n    indices: [u1; MAX_TREE_DEPTH],\n    siblings: [Field; MAX_TREE_DEPTH],\n}\n\n\npub struct BurnDataPublic {\n    account_note_hash: Field,       \n    account_note_nullifier: Field,                   \n}\n\npub struct BurnDataPrivate {                \n    //-----very privacy sensitive data -----\n    total_received: Field,              \n    prev_total_spent: Field,                           \n    prev_account_nonce: Field,               \n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData,\n    amount: Field,\n    shared_secret: Field,\n}\n\npub fn spendFromBurnAddresses(\n    root: Field, \n    amount: Field, \n    burn_data_public: [BurnDataPublic],\n    //private\n    burn_data_private: [BurnDataPrivate],\n    pub_key_x_field: Field,      \n    viewing_key: Field,\n    amount_burn_addresses: u32\n) {\n    let mut total_spend: Field = 0;\n    for i in 0..burn_data_private.len() {\n        if( i < amount_burn_addresses) {\n            spendFromBurnAddress(\n                //public\n                root,\n                burn_data_public[i].account_note_hash,\n                burn_data_public[i].account_note_nullifier,\n\n                //private\n                pub_key_x_field,\n                viewing_key,\n                burn_data_private[i].amount,\n                burn_data_private[i].total_received,\n                burn_data_private[i].prev_total_spent,\n                burn_data_private[i].shared_secret,\n                burn_data_private[i].prev_account_nonce,\n                burn_data_private[i].prev_account_note_merkle,\n                burn_data_private[i].total_received_merkle,\n            );\n\n            total_spend = total_spend + burn_data_private[i].amount;\n\n        }\n    }\n\n    assert(total_spend == amount, \"aggregated burn address amounts do not match target amount\");\n}\n\npub fn spendFromBurnAddress(\n    root: Field,\n    account_note_hash: Field,\n    account_note_nullifier: Field,\n\n    pub_key_x_field: Field,\n    viewing_key: Field,\n\n    amount: Field,\n    total_received: Field,\n    prev_total_spent: Field,\n    shared_secret: Field,\n    prev_account_nonce: Field,\n    prev_account_note_merkle: MerkleData,\n    total_received_merkle: MerkleData\n) {\n    let private_address: Field = get_private_address(pub_key_x_field, shared_secret);\n    let total_received_leaf: Field = hash_total_received_leaf(private_address, total_received);\n\n    let root_total_received: Field = compute_root(total_received_leaf, total_received_merkle);\n    assert(root_total_received == root, \"total_received merkle proof invalid\");\n\n    if prev_account_nonce != 0 {\n        let prev_account_note_hash: Field = hash_account_note(prev_total_spent, prev_account_nonce, viewing_key);\n        let computed_prev_root: Field = compute_root(prev_account_note_hash, prev_account_note_merkle);\n        assert(computed_prev_root == root, \"prev account note merkle proof invalid\");\n    } else {\n        assert(prev_total_spent == 0, \"first spend but prev_total_spent != 0\");\n    }\n\n    let computed_nullifier: Field = hash_nullifier(prev_account_nonce, viewing_key);\n    assert(computed_nullifier == account_note_nullifier, \"nullifier mismatch\");\n\n    let new_spent_amount: Field = prev_total_spent + amount;\n    assert(lower_then_or_equal(new_spent_amount, total_received), \"spend exceeds total received\");\n\n    let current_account_nonce: Field = prev_account_nonce + 1;\n    let computed_account_note_hash: Field = hash_account_note(new_spent_amount, current_account_nonce, viewing_key);\n    assert(computed_account_note_hash == account_note_hash, \"account note hash mismatch\");\n}","path":"/home/jimjim/Desktop/schwarzschild/circuits/privateTransferLib/src/lib.nr"},"52":{"source":"// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n","path":"/home/jimjim/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"},"62":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/jimjim/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}