{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-af6780c6b44f63be1beb35b2aff4c30f4bb4eee1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/leanIMTPoseidon2.sol": "project/contracts/leanIMTPoseidon2.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 20
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/",
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/"
      ]
    },
    "sources": {
      "npm/zk-kit-lean-imt-custom-hash@2.1.1/Constants.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
      },
      "npm/zk-kit-lean-imt-custom-hash@2.1.1/InternalLeanIMT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nstruct LeanIMTData {\n    // Tracks the current number of leaves in the tree.\n    uint256 size;\n    // Represents the current depth of the tree, which can increase as new leaves are inserted.\n    uint256 depth;\n    // A mapping from each level of the tree to the node value of the last even position at that level.\n    // Used for efficient inserts, updates and root calculations.\n    mapping(uint256 => uint256) sideNodes;\n    // A mapping from leaf values to their respective indices in the tree.\n    // This facilitates checks for leaf existence and retrieval of leaf positions.\n    mapping(uint256 => uint256) leaves;\n}\n\n// packing these inputs in a structs saves space on the stack\n// it adds some gas but without it _insertMany went over the stack limit\nstruct Hasher {\n    function(uint256[2] memory) view returns (uint256) func;\n    uint256 limit;\n}\n\nerror WrongSiblingNodes();\nerror LeafGreaterThanHasherLimit();\nerror LeafCannotBeZero();\nerror LeafAlreadyExists();\nerror LeafDoesNotExist();\n\n/// @title Lean Incremental binary Merkle tree.\n/// @dev The LeanIMT is an optimized version of the BinaryIMT.\n/// This implementation eliminates the use of zeroes, and make the tree depth dynamic.\n/// When a node doesn't have the right child, instead of using a zero hash as in the BinaryIMT,\n/// the node's value becomes that of its left child. Furthermore, rather than utilizing a static tree depth,\n/// it is updated based on the number of leaves in the tree. This approach\n/// results in the calculation of significantly fewer hashes, making the tree more efficient.\nlibrary InternalLeanIMT {\n    /// @dev Inserts a new leaf into the incremental merkle tree.\n    /// The function ensures that the leaf is valid according to the\n    /// constraints of the tree and then updates the tree's structure accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the new leaf to be inserted into the tree.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new hash of the node after the leaf has been inserted.\n    function _insert(LeanIMTData storage self, uint256 leaf, Hasher memory hasher) internal returns (uint256) {\n        if (leaf >= hasher.limit) {\n            revert LeafGreaterThanHasherLimit();\n        } else if (leaf == 0) {\n            revert LeafCannotBeZero();\n        } else if (_has(self, leaf)) {\n            revert LeafAlreadyExists();\n        }\n\n        uint256 index = self.size;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        // A new insertion can increase a tree's depth by at most 1,\n        // and only if the number of leaves supported by the current\n        // depth is less than the number of leaves to be supported after insertion.\n        if (2 ** treeDepth < index + 1) {\n            ++treeDepth;\n        }\n\n        self.depth = treeDepth;\n\n        uint256 node = leaf;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            if ((index >> level) & 1 == 1) {\n                node = hasher.func([self.sideNodes[level], node]);\n            } else {\n                self.sideNodes[level] = node;\n            }\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        self.size = ++index;\n\n        self.sideNodes[treeDepth] = node;\n        self.leaves[leaf] = index;\n\n        return node;\n    }\n\n    /// @dev Inserts many leaves into the incremental merkle tree.\n    /// The function ensures that the leaves are valid according to the\n    /// constraints of the tree and then updates the tree's structure accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaves: The values of the new leaves to be inserted into the tree.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The root after the leaves have been inserted.\n    function _insertMany(\n        LeanIMTData storage self,\n        uint256[] calldata leaves,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        // Cache tree size to optimize gas\n        uint256 treeSize = self.size;\n\n        // Check that all the new values are correct to be added.\n        for (uint256 i = 0; i < leaves.length; ) {\n            if (leaves[i] >= hasher.limit) {\n                revert LeafGreaterThanHasherLimit();\n            } else if (leaves[i] == 0) {\n                revert LeafCannotBeZero();\n            } else if (_has(self, leaves[i])) {\n                revert LeafAlreadyExists();\n            }\n\n            self.leaves[leaves[i]] = treeSize + 1 + i;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Array to save the nodes that will be used to create the next level of the tree.\n        uint256[] memory currentLevelNewNodes;\n\n        currentLevelNewNodes = leaves;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        // Calculate the depth of the tree after adding the new values.\n        // Unlike the 'insert' function, we need a while here as\n        // N insertions can increase the tree's depth more than once.\n        while (2 ** treeDepth < treeSize + leaves.length) {\n            ++treeDepth;\n        }\n\n        self.depth = treeDepth;\n\n        // First index to change in every level.\n        uint256 currentLevelStartIndex = treeSize;\n\n        // Size of the level used to create the next level.\n        uint256 currentLevelSize = treeSize + leaves.length;\n\n        // The index where changes begin at the next level.\n        uint256 nextLevelStartIndex = currentLevelStartIndex >> 1;\n\n        // The size of the next level.\n        uint256 nextLevelSize = ((currentLevelSize - 1) >> 1) + 1;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            // The number of nodes for the new level that will be created,\n            // only the new values, not the entire level.\n            uint256[] memory nextLevelNewNodes = new uint256[](nextLevelSize - nextLevelStartIndex);\n            for (uint256 i = 0; i < (nextLevelSize - nextLevelStartIndex); ) {\n                // packing left and right node in one array saves on the stack size\n                uint256[2] memory hasherInput;\n\n                // Assign the left node using the saved path or the position in the array.\n                if ((i + nextLevelStartIndex) * 2 < currentLevelStartIndex) {\n                    hasherInput[0] = self.sideNodes[level];\n                } else {\n                    hasherInput[0] = currentLevelNewNodes[(i + nextLevelStartIndex) * 2 - currentLevelStartIndex];\n                }\n\n                // Assign the right node if the value exists.\n                if ((i + nextLevelStartIndex) * 2 + 1 < currentLevelSize) {\n                    hasherInput[1] = currentLevelNewNodes[(i + nextLevelStartIndex) * 2 + 1 - currentLevelStartIndex];\n                }\n\n                uint256 parentNode;\n\n                // Assign the parent node.\n                // If it has a right child the result will be the hash(leftNode, rightNode) if not,\n                // it will be the leftNode.\n                if (hasherInput[1] != 0) {\n                    parentNode = hasher.func(hasherInput);\n                } else {\n                    parentNode = hasherInput[0];\n                }\n\n                nextLevelNewNodes[i] = parentNode;\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Update the `sideNodes` variable.\n            // If `currentLevelSize` is odd, the saved value will be the last value of the array\n            // if it is even and there are more than 1 element in `currentLevelNewNodes`, the saved value\n            // will be the value before the last one.\n            // If it is even and there is only one element, there is no need to save anything because\n            // the correct value for this level was already saved before.\n            if (currentLevelSize & 1 == 1) {\n                self.sideNodes[level] = currentLevelNewNodes[currentLevelNewNodes.length - 1];\n            } else if (currentLevelNewNodes.length > 1) {\n                self.sideNodes[level] = currentLevelNewNodes[currentLevelNewNodes.length - 2];\n            }\n\n            currentLevelStartIndex = nextLevelStartIndex;\n\n            // Calculate the next level startIndex value.\n            // It is the position of the parent node which is pos/2.\n            nextLevelStartIndex >>= 1;\n\n            // Update the next array that will be used to calculate the next level.\n            currentLevelNewNodes = nextLevelNewNodes;\n\n            currentLevelSize = nextLevelSize;\n\n            // Calculate the size of the next level.\n            // The size of the next level is (currentLevelSize - 1) / 2 + 1.\n            nextLevelSize = ((nextLevelSize - 1) >> 1) + 1;\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        // Update tree size\n        self.size = treeSize + leaves.length;\n\n        // Update tree root\n        self.sideNodes[treeDepth] = currentLevelNewNodes[0];\n\n        return currentLevelNewNodes[0];\n    }\n\n    /// @dev Updates the value of an existing leaf and recalculates hashes\n    /// to maintain tree integrity.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param oldLeaf: The value of the leaf that is to be updated.\n    /// @param newLeaf: The new value that will replace the oldLeaf in the tree.\n    /// @param siblingNodes: An array of sibling nodes that are necessary to recalculate the path to the root.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new hash of the updated node after the leaf has been updated.\n    function _update(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256 newLeaf,\n        uint256[] calldata siblingNodes,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        if (newLeaf >= hasher.limit) {\n            revert LeafGreaterThanHasherLimit();\n        } else if (!_has(self, oldLeaf)) {\n            revert LeafDoesNotExist();\n        } else if (_has(self, newLeaf)) {\n            revert LeafAlreadyExists();\n        }\n\n        uint256 index = _indexOf(self, oldLeaf);\n        uint256 node = newLeaf;\n        uint256 oldRoot = oldLeaf;\n\n        uint256 lastIndex = self.size - 1;\n        uint256 i = 0;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            if ((index >> level) & 1 == 1) {\n                if (siblingNodes[i] >= hasher.limit) {\n                    revert LeafGreaterThanHasherLimit();\n                }\n\n                node = hasher.func([siblingNodes[i], node]);\n                oldRoot = hasher.func([siblingNodes[i], oldRoot]);\n\n                unchecked {\n                    ++i;\n                }\n            } else {\n                if (index >> level != lastIndex >> level) {\n                    if (siblingNodes[i] >= hasher.limit) {\n                        revert LeafGreaterThanHasherLimit();\n                    }\n\n                    if (self.sideNodes[level] == oldRoot) {\n                        self.sideNodes[level] = node;\n                    }\n\n                    node = hasher.func([node, siblingNodes[i]]);\n                    oldRoot = hasher.func([oldRoot, siblingNodes[i]]);\n\n                    unchecked {\n                        ++i;\n                    }\n                } else {\n                    self.sideNodes[level] = node;\n                }\n            }\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        if (oldRoot != _root(self)) {\n            revert WrongSiblingNodes();\n        }\n\n        self.sideNodes[treeDepth] = node;\n\n        if (newLeaf != 0) {\n            self.leaves[newLeaf] = self.leaves[oldLeaf];\n        }\n\n        self.leaves[oldLeaf] = 0;\n\n        return node;\n    }\n\n    /// @dev Removes a leaf from the tree by setting its value to zero.\n    /// This function utilizes the update function to set the leaf's value\n    /// to zero and update the tree's state accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param oldLeaf: The value of the leaf to be removed.\n    /// @param siblingNodes: An array of sibling nodes required for updating the path to the root after removal.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new root hash of the tree after the leaf has been removed.\n    function _remove(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256[] calldata siblingNodes,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        return _update(self, oldLeaf, 0, siblingNodes, hasher);\n    }\n\n    /// @dev Checks if a leaf exists in the tree.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the leaf to check for existence.\n    /// @return A boolean value indicating whether the leaf exists in the tree.\n    function _has(LeanIMTData storage self, uint256 leaf) internal view returns (bool) {\n        return self.leaves[leaf] != 0;\n    }\n\n    /// @dev Retrieves the index of a given leaf in the tree.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the leaf whose index is to be found.\n    /// @return The index of the specified leaf within the tree. If the leaf is not present, the function\n    /// reverts with a custom error.\n    function _indexOf(LeanIMTData storage self, uint256 leaf) internal view returns (uint256) {\n        if (self.leaves[leaf] == 0) {\n            revert LeafDoesNotExist();\n        }\n\n        return self.leaves[leaf] - 1;\n    }\n\n    /// @dev Retrieves the root of the tree from the 'sideNodes' mapping using the\n    /// current tree depth.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @return The root hash of the tree.\n    function _root(LeanIMTData storage self) internal view returns (uint256) {\n        return self.sideNodes[self.depth];\n    }\n}\n"
      },
      "project/contracts/leanIMTPoseidon2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {InternalLeanIMT, LeanIMTData, Hasher} from \"zk-kit-lean-imt-custom-hash/InternalLeanIMT.sol\";\nimport {SNARK_SCALAR_FIELD} from \"zk-kit-lean-imt-custom-hash/Constants.sol\";\n\nlibrary leanIMTPoseidon2 {\n    // TODO\n    address internal constant POSEIDON2_ADDRESS = 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C; // yul-recompile-200: 0xb41072641808e6186eF5246fE1990e46EB45B65A gas: 62572, huff: 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C gas:39 627, yul-lib: 0x925e05cfb89f619BE3187Bf13D355A6D1864D24D,\n    // Hasher internal constant HASHER = Hasher(_hasher, SNARK_SCALAR_FIELD); constants on types that are function is not implemented yet in solidity (caused by HASHER.func)\n\n    // The function used for hashing. Passed as a function parameter in functions from InternalLazyIMT\n    function _hasher(uint256[2] memory leaves) internal view returns (uint256) {\n        (, bytes memory result) = POSEIDON2_ADDRESS.staticcall(abi.encode(leaves));\n        return uint256(bytes32(result));\n    }\n\n    using InternalLeanIMT for *;\n\n    function insert(LeanIMTData storage self, uint256 leaf) public returns (uint256) {\n        return InternalLeanIMT._insert(self, leaf, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function insertMany(LeanIMTData storage self, uint256[] calldata leaves) public returns (uint256) {\n        return InternalLeanIMT._insertMany(self, leaves, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function update(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256 newLeaf,\n        uint256[] calldata siblingNodes\n    ) public returns (uint256) {\n        return InternalLeanIMT._update(self, oldLeaf, newLeaf, siblingNodes, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function remove(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256[] calldata siblingNodes\n    ) public returns (uint256) {\n        return InternalLeanIMT._remove(self, oldLeaf, siblingNodes, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function has(LeanIMTData storage self, uint256 leaf) public view returns (bool) {\n        return InternalLeanIMT._has(self, leaf);\n    }\n\n    function indexOf(LeanIMTData storage self, uint256 leaf) public view returns (uint256) {\n        return InternalLeanIMT._indexOf(self, leaf);\n    }\n\n    function root(LeanIMTData storage self) public view returns (uint256) {\n        return InternalLeanIMT._root(self);\n    }\n}\n"
      }
    }
  }
}