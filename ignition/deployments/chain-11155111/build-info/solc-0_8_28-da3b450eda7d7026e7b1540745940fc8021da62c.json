{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-da3b450eda7d7026e7b1540745940fc8021da62c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/WormholeToken.sol": "project/contracts/WormholeToken.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 20
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/",
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/",
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/",
        "project/:zk-kit-lean-imt-custom-hash/=npm/zk-kit-lean-imt-custom-hash@2.1.1/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC5267.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC5267.sol)\n\npragma solidity >=0.4.16;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/EIP712.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP-712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP-712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    // slither-disable-next-line constable-states\n    string private _nameFallback;\n    // slither-disable-next-line constable-states\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP-712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /// @inheritdoc IERC5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/cryptography/MessageHashUtils.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[ERC-191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an ERC-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Variant of {toDataWithIntendedValidatorHash-address-bytes} optimized for cases where `data` is a bytes32.\n     */\n    function toDataWithIntendedValidatorHash(\n        address validator,\n        bytes32 messageHash\n    ) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, hex\"19_00\")\n            mstore(0x02, shl(96, validator))\n            mstore(0x16, messageHash)\n            digest := keccak256(0x00, 0x36)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (ERC-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/Math.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/math/SignedMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Panic.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ShortStrings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        assembly (\"memory-safe\") {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {toShortStringWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {toShortStringWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/StorageSlot.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Strings.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(add(buffer, 0x20), length)\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(add(buffer, 0x20), offset))\n        }\n    }\n}\n"
      },
      "npm/zk-kit-lean-imt-custom-hash@2.1.1/Constants.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
      },
      "npm/zk-kit-lean-imt-custom-hash@2.1.1/InternalLeanIMT.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nstruct LeanIMTData {\n    // Tracks the current number of leaves in the tree.\n    uint256 size;\n    // Represents the current depth of the tree, which can increase as new leaves are inserted.\n    uint256 depth;\n    // A mapping from each level of the tree to the node value of the last even position at that level.\n    // Used for efficient inserts, updates and root calculations.\n    mapping(uint256 => uint256) sideNodes;\n    // A mapping from leaf values to their respective indices in the tree.\n    // This facilitates checks for leaf existence and retrieval of leaf positions.\n    mapping(uint256 => uint256) leaves;\n}\n\n// packing these inputs in a structs saves space on the stack\n// it adds some gas but without it _insertMany went over the stack limit\nstruct Hasher {\n    function(uint256[2] memory) view returns (uint256) func;\n    uint256 limit;\n}\n\nerror WrongSiblingNodes();\nerror LeafGreaterThanHasherLimit();\nerror LeafCannotBeZero();\nerror LeafAlreadyExists();\nerror LeafDoesNotExist();\n\n/// @title Lean Incremental binary Merkle tree.\n/// @dev The LeanIMT is an optimized version of the BinaryIMT.\n/// This implementation eliminates the use of zeroes, and make the tree depth dynamic.\n/// When a node doesn't have the right child, instead of using a zero hash as in the BinaryIMT,\n/// the node's value becomes that of its left child. Furthermore, rather than utilizing a static tree depth,\n/// it is updated based on the number of leaves in the tree. This approach\n/// results in the calculation of significantly fewer hashes, making the tree more efficient.\nlibrary InternalLeanIMT {\n    /// @dev Inserts a new leaf into the incremental merkle tree.\n    /// The function ensures that the leaf is valid according to the\n    /// constraints of the tree and then updates the tree's structure accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the new leaf to be inserted into the tree.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new hash of the node after the leaf has been inserted.\n    function _insert(LeanIMTData storage self, uint256 leaf, Hasher memory hasher) internal returns (uint256) {\n        if (leaf >= hasher.limit) {\n            revert LeafGreaterThanHasherLimit();\n        } else if (leaf == 0) {\n            revert LeafCannotBeZero();\n        } else if (_has(self, leaf)) {\n            revert LeafAlreadyExists();\n        }\n\n        uint256 index = self.size;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        // A new insertion can increase a tree's depth by at most 1,\n        // and only if the number of leaves supported by the current\n        // depth is less than the number of leaves to be supported after insertion.\n        if (2 ** treeDepth < index + 1) {\n            ++treeDepth;\n        }\n\n        self.depth = treeDepth;\n\n        uint256 node = leaf;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            if ((index >> level) & 1 == 1) {\n                node = hasher.func([self.sideNodes[level], node]);\n            } else {\n                self.sideNodes[level] = node;\n            }\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        self.size = ++index;\n\n        self.sideNodes[treeDepth] = node;\n        self.leaves[leaf] = index;\n\n        return node;\n    }\n\n    /// @dev Inserts many leaves into the incremental merkle tree.\n    /// The function ensures that the leaves are valid according to the\n    /// constraints of the tree and then updates the tree's structure accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaves: The values of the new leaves to be inserted into the tree.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The root after the leaves have been inserted.\n    function _insertMany(\n        LeanIMTData storage self,\n        uint256[] calldata leaves,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        // Cache tree size to optimize gas\n        uint256 treeSize = self.size;\n\n        // Check that all the new values are correct to be added.\n        for (uint256 i = 0; i < leaves.length; ) {\n            if (leaves[i] >= hasher.limit) {\n                revert LeafGreaterThanHasherLimit();\n            } else if (leaves[i] == 0) {\n                revert LeafCannotBeZero();\n            } else if (_has(self, leaves[i])) {\n                revert LeafAlreadyExists();\n            }\n\n            self.leaves[leaves[i]] = treeSize + 1 + i;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Array to save the nodes that will be used to create the next level of the tree.\n        uint256[] memory currentLevelNewNodes;\n\n        currentLevelNewNodes = leaves;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        // Calculate the depth of the tree after adding the new values.\n        // Unlike the 'insert' function, we need a while here as\n        // N insertions can increase the tree's depth more than once.\n        while (2 ** treeDepth < treeSize + leaves.length) {\n            ++treeDepth;\n        }\n\n        self.depth = treeDepth;\n\n        // First index to change in every level.\n        uint256 currentLevelStartIndex = treeSize;\n\n        // Size of the level used to create the next level.\n        uint256 currentLevelSize = treeSize + leaves.length;\n\n        // The index where changes begin at the next level.\n        uint256 nextLevelStartIndex = currentLevelStartIndex >> 1;\n\n        // The size of the next level.\n        uint256 nextLevelSize = ((currentLevelSize - 1) >> 1) + 1;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            // The number of nodes for the new level that will be created,\n            // only the new values, not the entire level.\n            uint256[] memory nextLevelNewNodes = new uint256[](nextLevelSize - nextLevelStartIndex);\n            for (uint256 i = 0; i < (nextLevelSize - nextLevelStartIndex); ) {\n                // packing left and right node in one array saves on the stack size\n                uint256[2] memory hasherInput;\n\n                // Assign the left node using the saved path or the position in the array.\n                if ((i + nextLevelStartIndex) * 2 < currentLevelStartIndex) {\n                    hasherInput[0] = self.sideNodes[level];\n                } else {\n                    hasherInput[0] = currentLevelNewNodes[(i + nextLevelStartIndex) * 2 - currentLevelStartIndex];\n                }\n\n                // Assign the right node if the value exists.\n                if ((i + nextLevelStartIndex) * 2 + 1 < currentLevelSize) {\n                    hasherInput[1] = currentLevelNewNodes[(i + nextLevelStartIndex) * 2 + 1 - currentLevelStartIndex];\n                }\n\n                uint256 parentNode;\n\n                // Assign the parent node.\n                // If it has a right child the result will be the hash(leftNode, rightNode) if not,\n                // it will be the leftNode.\n                if (hasherInput[1] != 0) {\n                    parentNode = hasher.func(hasherInput);\n                } else {\n                    parentNode = hasherInput[0];\n                }\n\n                nextLevelNewNodes[i] = parentNode;\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Update the `sideNodes` variable.\n            // If `currentLevelSize` is odd, the saved value will be the last value of the array\n            // if it is even and there are more than 1 element in `currentLevelNewNodes`, the saved value\n            // will be the value before the last one.\n            // If it is even and there is only one element, there is no need to save anything because\n            // the correct value for this level was already saved before.\n            if (currentLevelSize & 1 == 1) {\n                self.sideNodes[level] = currentLevelNewNodes[currentLevelNewNodes.length - 1];\n            } else if (currentLevelNewNodes.length > 1) {\n                self.sideNodes[level] = currentLevelNewNodes[currentLevelNewNodes.length - 2];\n            }\n\n            currentLevelStartIndex = nextLevelStartIndex;\n\n            // Calculate the next level startIndex value.\n            // It is the position of the parent node which is pos/2.\n            nextLevelStartIndex >>= 1;\n\n            // Update the next array that will be used to calculate the next level.\n            currentLevelNewNodes = nextLevelNewNodes;\n\n            currentLevelSize = nextLevelSize;\n\n            // Calculate the size of the next level.\n            // The size of the next level is (currentLevelSize - 1) / 2 + 1.\n            nextLevelSize = ((nextLevelSize - 1) >> 1) + 1;\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        // Update tree size\n        self.size = treeSize + leaves.length;\n\n        // Update tree root\n        self.sideNodes[treeDepth] = currentLevelNewNodes[0];\n\n        return currentLevelNewNodes[0];\n    }\n\n    /// @dev Updates the value of an existing leaf and recalculates hashes\n    /// to maintain tree integrity.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param oldLeaf: The value of the leaf that is to be updated.\n    /// @param newLeaf: The new value that will replace the oldLeaf in the tree.\n    /// @param siblingNodes: An array of sibling nodes that are necessary to recalculate the path to the root.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new hash of the updated node after the leaf has been updated.\n    function _update(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256 newLeaf,\n        uint256[] calldata siblingNodes,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        if (newLeaf >= hasher.limit) {\n            revert LeafGreaterThanHasherLimit();\n        } else if (!_has(self, oldLeaf)) {\n            revert LeafDoesNotExist();\n        } else if (_has(self, newLeaf)) {\n            revert LeafAlreadyExists();\n        }\n\n        uint256 index = _indexOf(self, oldLeaf);\n        uint256 node = newLeaf;\n        uint256 oldRoot = oldLeaf;\n\n        uint256 lastIndex = self.size - 1;\n        uint256 i = 0;\n\n        // Cache tree depth to optimize gas\n        uint256 treeDepth = self.depth;\n\n        for (uint256 level = 0; level < treeDepth; ) {\n            if ((index >> level) & 1 == 1) {\n                if (siblingNodes[i] >= hasher.limit) {\n                    revert LeafGreaterThanHasherLimit();\n                }\n\n                node = hasher.func([siblingNodes[i], node]);\n                oldRoot = hasher.func([siblingNodes[i], oldRoot]);\n\n                unchecked {\n                    ++i;\n                }\n            } else {\n                if (index >> level != lastIndex >> level) {\n                    if (siblingNodes[i] >= hasher.limit) {\n                        revert LeafGreaterThanHasherLimit();\n                    }\n\n                    if (self.sideNodes[level] == oldRoot) {\n                        self.sideNodes[level] = node;\n                    }\n\n                    node = hasher.func([node, siblingNodes[i]]);\n                    oldRoot = hasher.func([oldRoot, siblingNodes[i]]);\n\n                    unchecked {\n                        ++i;\n                    }\n                } else {\n                    self.sideNodes[level] = node;\n                }\n            }\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        if (oldRoot != _root(self)) {\n            revert WrongSiblingNodes();\n        }\n\n        self.sideNodes[treeDepth] = node;\n\n        if (newLeaf != 0) {\n            self.leaves[newLeaf] = self.leaves[oldLeaf];\n        }\n\n        self.leaves[oldLeaf] = 0;\n\n        return node;\n    }\n\n    /// @dev Removes a leaf from the tree by setting its value to zero.\n    /// This function utilizes the update function to set the leaf's value\n    /// to zero and update the tree's state accordingly.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param oldLeaf: The value of the leaf to be removed.\n    /// @param siblingNodes: An array of sibling nodes required for updating the path to the root after removal.\n    /// @param hasher: A struct that contains the function used for hashing and it's limit (ex the SNARK_SCALAR_FIELD limit in poseidon)\n    /// @return The new root hash of the tree after the leaf has been removed.\n    function _remove(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256[] calldata siblingNodes,\n        Hasher memory hasher\n    ) internal returns (uint256) {\n        return _update(self, oldLeaf, 0, siblingNodes, hasher);\n    }\n\n    /// @dev Checks if a leaf exists in the tree.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the leaf to check for existence.\n    /// @return A boolean value indicating whether the leaf exists in the tree.\n    function _has(LeanIMTData storage self, uint256 leaf) internal view returns (bool) {\n        return self.leaves[leaf] != 0;\n    }\n\n    /// @dev Retrieves the index of a given leaf in the tree.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @param leaf: The value of the leaf whose index is to be found.\n    /// @return The index of the specified leaf within the tree. If the leaf is not present, the function\n    /// reverts with a custom error.\n    function _indexOf(LeanIMTData storage self, uint256 leaf) internal view returns (uint256) {\n        if (self.leaves[leaf] == 0) {\n            revert LeafDoesNotExist();\n        }\n\n        return self.leaves[leaf] - 1;\n    }\n\n    /// @dev Retrieves the root of the tree from the 'sideNodes' mapping using the\n    /// current tree depth.\n    /// @param self: A storage reference to the 'LeanIMTData' struct.\n    /// @return The root hash of the tree.\n    function _root(LeanIMTData storage self) internal view returns (uint256) {\n        return self.sideNodes[self.depth];\n    }\n}\n"
      },
      "project/contracts/ERC20WithWormHoleMerkleTree.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/ERC20.sol)\n\n// from openzeppelin 5.2.0 but _updateMerkleTree is added inside _update. In order to make it track incoming balances of the recipient in a merkle tree\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {SNARK_SCALAR_FIELD} from \"zk-kit-lean-imt-custom-hash/Constants.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20WithWormHoleMerkleTree is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n\n    function _updateBalanceInMerkleTree(address _to, uint256 _newBalance) virtual internal;\n    function _updateBalanceInMerkleTree(address _to, uint256 _newBalance, uint256[] memory _accountNoteHashes) virtual internal;\n    function _updateBalanceInMerkleTree(address[] memory _to, uint256[] memory _newBalance, uint256[] memory _accountNoteHashes) virtual internal;\n    function _insertManyInMerkleTree(uint256[] memory _accountNoteHashes) virtual internal;\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            uint256 newBalance;\n            newBalance = _balances[to] + value;\n            require(newBalance < SNARK_SCALAR_FIELD, \"balance can't go over the FIELD LIMIT\");\n\n            _balances[to] = newBalance;\n\n            // we only care about `to` since zkwormhole accounts can only receive from the public not spend\n            // so the _balances[to] number goes up only :D\n            _updateBalanceInMerkleTree(to, newBalance);\n        }\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     * \n     * Same as _update but added _accountNoteHash so it use insertMany to save on gas and _totalSupply doesn't increase\n     */\n    function _reMint(address to, uint256 value, uint256[] memory _accountNoteHashes) internal virtual {\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n            _insertManyInMerkleTree(_accountNoteHashes);\n        } else {\n            uint256 newBalance;\n            newBalance = _balances[to] + value;\n\n            _balances[to] = newBalance;\n            require(newBalance < SNARK_SCALAR_FIELD, \"balance can't go over the FIELD LIMIT\");\n\n            // we only care about `to` since zkwormhole accounts can only receive from the public not spend\n            // so the _balances[to] number goes up only :D\n            // this inserts both _accountNoteHash and poseidon2(to, newBalance)\n            _updateBalanceInMerkleTree(to, newBalance, _accountNoteHashes);\n        }\n        emit Transfer(address(0), to, value);\n    }\n\n    function _reMintBulk(address[] memory recipients, uint256[] memory amounts, uint256[] memory _accountNoteHashes) internal virtual {\n        uint256[] memory newBalances = new uint256[](amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            address to = recipients[i];\n            uint256 value = amounts[i];\n            if (to == address(0)) {\n                unchecked {\n                    // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                    _totalSupply -= value;\n                }\n                _insertManyInMerkleTree(_accountNoteHashes);\n            } else {\n                uint256 newBalance;\n                newBalance = _balances[to] + value;\n                _balances[to] = newBalance;\n                require(newBalance < SNARK_SCALAR_FIELD, \"balance can't go over the FIELD LIMIT\");\n\n                // we only care about `to` since zkwormhole accounts can only receive from the public not spend\n                // so the _balances[to] number goes up only :D\n                // this inserts both _accountNoteHash and poseidon2(to, newBalance)\n                newBalances[i] = newBalance;\n            }\n            emit Transfer(address(0), to, value);\n        }\n        _updateBalanceInMerkleTree(recipients, newBalances, _accountNoteHashes);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "project/contracts/leanIMTPoseidon2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {InternalLeanIMT, LeanIMTData, Hasher} from \"zk-kit-lean-imt-custom-hash/InternalLeanIMT.sol\";\nimport {SNARK_SCALAR_FIELD} from \"zk-kit-lean-imt-custom-hash/Constants.sol\";\n\nlibrary leanIMTPoseidon2 {\n    // TODO\n    address internal constant POSEIDON2_ADDRESS = 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C; // yul-recompile-200: 0xb41072641808e6186eF5246fE1990e46EB45B65A gas: 62572, huff: 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C gas:39 627, yul-lib: 0x925e05cfb89f619BE3187Bf13D355A6D1864D24D,\n    // Hasher internal constant HASHER = Hasher(_hasher, SNARK_SCALAR_FIELD); constants on types that are function is not implemented yet in solidity (caused by HASHER.func)\n\n    // The function used for hashing. Passed as a function parameter in functions from InternalLazyIMT\n    function _hasher(uint256[2] memory leaves) internal view returns (uint256) {\n        (, bytes memory result) = POSEIDON2_ADDRESS.staticcall(abi.encode(leaves));\n        return uint256(bytes32(result));\n    }\n\n    using InternalLeanIMT for *;\n\n    function insert(LeanIMTData storage self, uint256 leaf) public returns (uint256) {\n        return InternalLeanIMT._insert(self, leaf, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function insertMany(LeanIMTData storage self, uint256[] calldata leaves) public returns (uint256) {\n        return InternalLeanIMT._insertMany(self, leaves, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function update(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256 newLeaf,\n        uint256[] calldata siblingNodes\n    ) public returns (uint256) {\n        return InternalLeanIMT._update(self, oldLeaf, newLeaf, siblingNodes, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function remove(\n        LeanIMTData storage self,\n        uint256 oldLeaf,\n        uint256[] calldata siblingNodes\n    ) public returns (uint256) {\n        return InternalLeanIMT._remove(self, oldLeaf, siblingNodes, Hasher(_hasher, SNARK_SCALAR_FIELD));\n    }\n\n    function has(LeanIMTData storage self, uint256 leaf) public view returns (bool) {\n        return InternalLeanIMT._has(self, leaf);\n    }\n\n    function indexOf(LeanIMTData storage self, uint256 leaf) public view returns (uint256) {\n        return InternalLeanIMT._indexOf(self, leaf);\n    }\n\n    function root(LeanIMTData storage self) public view returns (uint256) {\n        return InternalLeanIMT._root(self);\n    }\n}\n"
      },
      "project/contracts/privateTransfer2InVerifier.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec\npragma solidity >=0.8.21;\n\nuint256 constant N = 65536;\nuint256 constant LOG_N = 16;\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 54;\nuint256 constant VK_HASH = 0x06124fb99630549f56e6818093e73b2d8316c791752a34ba4a9536886ef4db45;\nlibrary HonkVerificationKey {\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\n            circuitSize: uint256(65536),\n            logCircuitSize: uint256(16),\n            publicInputsSize: uint256(54),\n            ql: Honk.G1Point({ \n               x: uint256(0x181461fb1c52968c7de6e179d9956147be2b54d21ff82fb26ff921e37dfef85d),\n               y: uint256(0x0af24c317fc447d649e045e38f5f9a06ac8d2ab3fa1665849d3aa2b7209bcc62)\n            }),\n            qr: Honk.G1Point({ \n               x: uint256(0x0cf22169cbd1374d096147e435b8d0c776dbdc61565b39208a76cf0371141fc2),\n               y: uint256(0x1475bd36b4388a0fb71f52197b641e3291e1a3a3afbccc2fedcc20a7db0c7aa1)\n            }),\n            qo: Honk.G1Point({ \n               x: uint256(0x184f17fa4258edb538421cbf03fbdd1b91e1468f4f8e2fe87b16254b0025b61f),\n               y: uint256(0x0b9a7888786c2660cdd4e35de837ca8860dc850c0c44e1c4360a90edaed90ddd)\n            }),\n            q4: Honk.G1Point({ \n               x: uint256(0x305963abd0b0c15ef0744b6fca6472c82184eb89f4fbc4104840332f080fcd91),\n               y: uint256(0x108a87c2078eba09a64306215576521545e2770ed65970f1c60075fe7e503f30)\n            }),\n            qm: Honk.G1Point({ \n               x: uint256(0x22414a7412089f8c07b5fce2e7ebe04423abf5688e0422323786e5ee1a9539d8),\n               y: uint256(0x1b82d0ee68d90846e457aeb048e9b9fc8ae5524e76095921970110d4b935071f)\n            }),\n            qc: Honk.G1Point({ \n               x: uint256(0x141a84c010fe02f76c24829fc97e271be859635042be99b57b0e0fa651f49620),\n               y: uint256(0x253ae70579318b0e7152a0a28adfedb3d55aeb461a3b0ebe3b96cdbc4dda7d0a)\n            }),\n            qLookup: Honk.G1Point({ \n               x: uint256(0x24d0f449b180092ef9c3a2678475fdfced47efe5681f854a39d9c65f8f727f0d),\n               y: uint256(0x29ef64a2132c56d60e4ab08eb9159711a603fdee2fe3b79a8c0b520dc4194118)\n            }),\n            qArith: Honk.G1Point({ \n               x: uint256(0x28165ef9971b35846f09184021ecb0b01baee0c51cc00d219013914c89c7d51e),\n               y: uint256(0x113cc8fb88578b45b4f3dcaffb0e5937998765099c92e40eaf2bb8518e4eaa21)\n            }),\n            qDeltaRange: Honk.G1Point({ \n               x: uint256(0x0b7bda196b2c3aa2e91b568e5869dcc4988705303d59f377acb4f962d984de17),\n               y: uint256(0x194d36c2ec20572034e9b42a5864db22f0b902c8e25615c0fd2a17ebb4b7d9d3)\n            }),\n            qElliptic: Honk.G1Point({ \n               x: uint256(0x26a47833f67aa0bf40779ebd4eea4dcb4481795dd64de4e46765caf7c3d80669),\n               y: uint256(0x1ff4b997fc36fa70f36ba9423fac6d56aac133f078fe52ecd3532de4bf585201)\n            }),\n            qMemory: Honk.G1Point({ \n               x: uint256(0x29bb7120c559069b0f66eec974be919a5fc7287e2cbeb90430b811930fc0b469),\n               y: uint256(0x25603853ddf8d3656bbfaaedd5dc3ca479a3c8d97b1e0b1ec3174da20befadd9)\n            }),\n            qNnf: Honk.G1Point({ \n               x: uint256(0x00c3e009e94e6ede245e447a35586f17f3d6812aafe010f723c6874fe0dc47a6),\n               y: uint256(0x23768b1f8febd659f481bb5f3f2e038d91fce401a9e0d703d6fc0069cdfc982b)\n            }),\n            qPoseidon2External: Honk.G1Point({ \n               x: uint256(0x1e077c4241e2d874e96e8783b9d82d10138f1ce75c23c173d2cf6c47e3f807ca),\n               y: uint256(0x0cdd674286a8fc4a03dc123a002763d33b5a826af459bb420efc7bca9f376f85)\n            }),\n            qPoseidon2Internal: Honk.G1Point({ \n               x: uint256(0x24ede699b24b76f075de13cc3157bfce2286e4a8331c7058b1ab2d65afac667c),\n               y: uint256(0x2a5700b4eb02f78ccb14e8f608ccb8e0ca09ef8fa9bdabb9fe2ddeb592e2712b)\n            }),\n            s1: Honk.G1Point({ \n               x: uint256(0x2fd324553735bb6434c778081a67878b5d06ac7cd36af8b477f64ce4ccb5ab9b),\n               y: uint256(0x0cd56d7375f355f88deb3d0e3aeb0ed98039979a49739076e86dda1a9444aa66)\n            }),\n            s2: Honk.G1Point({ \n               x: uint256(0x2916d5eec87ef3d55c906737f512b828e10f5391e93ecc6e89c46b3a87b87c78),\n               y: uint256(0x2f0b360bd1b63c0a6ce3d28134e9c77db175f8acdb664fa2453799d35408b685)\n            }),\n            s3: Honk.G1Point({ \n               x: uint256(0x2ecc5b6f2268ff38ee0c5af9d37f290976dcbbb7673060b4c54fe4eabe7ef4b4),\n               y: uint256(0x28728dceeb816f68c9e7bd16db59c4611ff5b1e062ad7d6aeeee7a589cd045e8)\n            }),\n            s4: Honk.G1Point({ \n               x: uint256(0x2f494a4bcf7af8b1e700cfb494ba3c7b339eb5a2a46b4bae919262b4aca25876),\n               y: uint256(0x0321bcacd6740828db5c7421e286e25c893c7cd09f77b8f94dd86d8c708d1392)\n            }),\n            t1: Honk.G1Point({ \n               x: uint256(0x14ae420101645265884749693f070e2da7c5a6ec8fdd80fa707643760b955527),\n               y: uint256(0x1f5f701b22efb7b78438b902ae849d4a4ed48e182f2be23e9bc26e3929ccda9e)\n            }),\n            t2: Honk.G1Point({ \n               x: uint256(0x1f474dbaee36fb48fad5626ba1922d5b3711af9bf5d4da7d896fa222b66cbacb),\n               y: uint256(0x2a0e8e7e10bb83718dc7418e9cf125e9428f1a5925c07173e7fd033e7fc236d1)\n            }),\n            t3: Honk.G1Point({ \n               x: uint256(0x24107ddc4ff3ec5e10ea25a2e0045fefdfc10773d034fdb0a16977146e77befe),\n               y: uint256(0x258a58b1e0b10af41d2577394fd49c980a44660f7ea97f549da0fc05be23de91)\n            }),\n            t4: Honk.G1Point({ \n               x: uint256(0x0c7b77a29a80540b5d3d6de3f79be677c00b97d3a60fc34729529ab108bae1b9),\n               y: uint256(0x1e21f5dbb6b1bfcb4848ca8888db7d24b77f6d93ebe201a9f6a66bfd3b5f8a04)\n            }),\n            id1: Honk.G1Point({ \n               x: uint256(0x1f996b7442a162eafd9d64ad2feb3d6cc4dad500a46010ba789e6b9088374afd),\n               y: uint256(0x0b64281db8e789185a430bff7e941cf04dce0ad10ba2f85ea4253257c7f7af03)\n            }),\n            id2: Honk.G1Point({ \n               x: uint256(0x26d31a297d1a50106943cfa83b271e571907d8c4afd531a7fec51c7ab331d9b9),\n               y: uint256(0x221685d753e2dcc2deb5a530b515caed9cf64ee1803a01dc168635d09e083e30)\n            }),\n            id3: Honk.G1Point({ \n               x: uint256(0x1c5b750d14a8c50c2acf9a465b6de1f8be7734ec6270cf85f369df7151f0f86d),\n               y: uint256(0x2933ab5437f8db7af72bd552f9ae3e3a9e3ae3d8d41cfc841ec6d76a58515474)\n            }),\n            id4: Honk.G1Point({ \n               x: uint256(0x0df18b57ad2adc84f1622efedf9ba2d0036e032a1c757607e9ddb4920b1363d5),\n               y: uint256(0x1f0e6cb45ddef06317bb9659eebef3400b70cbcb590313a43644d805a9bc95ea)\n            }),\n            lagrangeFirst: Honk.G1Point({ \n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\n            }),\n            lagrangeLast: Honk.G1Point({ \n               x: uint256(0x1798c8c10d9ef5a3ad58f3fabfe22eb7da2ddcf8921bb90b38676b49195baaa3),\n               y: uint256(0x24f9d3512866ac09ceb0c8118061ec31125953650fe5a8ae3dfe2cd4923a7870)\n            })\n        });\n        return vk;\n    }\n}\n\npragma solidity ^0.8.27;\n\ninterface IVerifier {\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external returns (bool);\n}\n\ntype Fr is uint256;\n\nusing {add as +} for Fr global;\nusing {sub as -} for Fr global;\nusing {mul as *} for Fr global;\n\nusing {exp as ^} for Fr global;\nusing {notEqual as !=} for Fr global;\nusing {equal as ==} for Fr global;\n\nuint256 constant SUBGROUP_SIZE = 256;\nuint256 constant MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\nuint256 constant P = MODULUS;\nFr constant SUBGROUP_GENERATOR = Fr.wrap(0x07b0c561a6148404f086204a9f36ffb0617942546750f230c893619174a57a76);\nFr constant SUBGROUP_GENERATOR_INVERSE = Fr.wrap(0x204bd3277422fad364751ad938e2b5e6a54cf8c68712848a692c553d0329f5d6);\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\nFr constant ONE = Fr.wrap(1);\nFr constant ZERO = Fr.wrap(0);\n// Instantiation\n\nlibrary FrLib {\n    function from(uint256 value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(value % MODULUS);\n        }\n    }\n\n    function fromBytes32(bytes32 value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(uint256(value) % MODULUS);\n        }\n    }\n\n    function toBytes32(Fr value) internal pure returns (bytes32) {\n        unchecked {\n            return bytes32(Fr.unwrap(value));\n        }\n    }\n\n    function invert(Fr value) internal view returns (Fr) {\n        uint256 v = Fr.unwrap(value);\n        uint256 result;\n\n        // Call the modexp precompile to invert in the field\n        assembly {\n            let free := mload(0x40)\n            mstore(free, 0x20)\n            mstore(add(free, 0x20), 0x20)\n            mstore(add(free, 0x40), 0x20)\n            mstore(add(free, 0x60), v)\n            mstore(add(free, 0x80), sub(MODULUS, 2)) \n            mstore(add(free, 0xa0), MODULUS)\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\n            if iszero(success) {\n                revert(0, 0)\n            }\n            result := mload(0x00)\n            mstore(0x40, add(free, 0x80))\n        }\n\n        return Fr.wrap(result);\n    }\n\n    function pow(Fr base, uint256 v) internal view returns (Fr) {\n        uint256 b = Fr.unwrap(base);\n        uint256 result;\n\n        // Call the modexp precompile to invert in the field\n        assembly {\n            let free := mload(0x40)\n            mstore(free, 0x20)\n            mstore(add(free, 0x20), 0x20)\n            mstore(add(free, 0x40), 0x20)\n            mstore(add(free, 0x60), b)\n            mstore(add(free, 0x80), v) \n            mstore(add(free, 0xa0), MODULUS)\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\n            if iszero(success) {\n                revert(0, 0)\n            }\n            result := mload(0x00)\n            mstore(0x40, add(free, 0x80))\n        }\n\n        return Fr.wrap(result);\n    }\n\n    function div(Fr numerator, Fr denominator) internal view returns (Fr) {\n        unchecked {\n            return numerator * invert(denominator);\n        }\n    }\n\n    function sqr(Fr value) internal pure returns (Fr) {\n        unchecked {\n            return value * value;\n        }\n    }\n\n    function unwrap(Fr value) internal pure returns (uint256) {\n        unchecked {\n            return Fr.unwrap(value);\n        }\n    }\n\n    function neg(Fr value) internal pure returns (Fr) {\n        unchecked {\n            return Fr.wrap(MODULUS - Fr.unwrap(value));\n        }\n    }\n}\n\n// Free functions\nfunction add(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction mul(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction sub(Fr a, Fr b) pure returns (Fr) {\n    unchecked {\n        return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\n    }\n}\n\nfunction exp(Fr base, Fr exponent) pure returns (Fr) {\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\n    // Implement exponent with a loop as we will overflow otherwise\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\n        base = base * base;\n    }\n    return base;\n}\n\nfunction notEqual(Fr a, Fr b) pure returns (bool) {\n    unchecked {\n        return Fr.unwrap(a) != Fr.unwrap(b);\n    }\n}\n\nfunction equal(Fr a, Fr b) pure returns (bool) {\n    unchecked {\n        return Fr.unwrap(a) == Fr.unwrap(b);\n    }\n}\n\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\n\nuint256 constant NUMBER_OF_SUBRELATIONS = 28;\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\nuint256 constant ZK_BATCHED_RELATION_PARTIAL_LENGTH = 9;\nuint256 constant NUMBER_OF_ENTITIES = 41;\nuint256 constant NUMBER_UNSHIFTED = 36;\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\nuint256 constant PAIRING_POINTS_SIZE = 16;\n\nuint256 constant FIELD_ELEMENT_SIZE = 0x20;\nuint256 constant GROUP_ELEMENT_SIZE = 0x40;\n\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\nuint256 constant NUMBER_OF_ALPHAS = NUMBER_OF_SUBRELATIONS - 1;\n\n// ENUM FOR WIRES\nenum WIRE {\n    Q_M,\n    Q_C,\n    Q_L,\n    Q_R,\n    Q_O,\n    Q_4,\n    Q_LOOKUP,\n    Q_ARITH,\n    Q_RANGE,\n    Q_ELLIPTIC,\n    Q_MEMORY,\n    Q_NNF,\n    Q_POSEIDON2_EXTERNAL,\n    Q_POSEIDON2_INTERNAL,\n    SIGMA_1,\n    SIGMA_2,\n    SIGMA_3,\n    SIGMA_4,\n    ID_1,\n    ID_2,\n    ID_3,\n    ID_4,\n    TABLE_1,\n    TABLE_2,\n    TABLE_3,\n    TABLE_4,\n    LAGRANGE_FIRST,\n    LAGRANGE_LAST,\n    W_L,\n    W_R,\n    W_O,\n    W_4,\n    Z_PERM,\n    LOOKUP_INVERSES,\n    LOOKUP_READ_COUNTS,\n    LOOKUP_READ_TAGS,\n    W_L_SHIFT,\n    W_R_SHIFT,\n    W_O_SHIFT,\n    W_4_SHIFT,\n    Z_PERM_SHIFT\n}\n\nlibrary Honk {\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    struct VerificationKey {\n        // Misc Params\n        uint256 circuitSize;\n        uint256 logCircuitSize;\n        uint256 publicInputsSize;\n        // Selectors\n        G1Point qm;\n        G1Point qc;\n        G1Point ql;\n        G1Point qr;\n        G1Point qo;\n        G1Point q4;\n        G1Point qLookup; // Lookup\n        G1Point qArith; // Arithmetic widget\n        G1Point qDeltaRange; // Delta Range sort\n        G1Point qMemory; // Memory\n        G1Point qNnf; // Non-native Field\n        G1Point qElliptic; // Auxillary\n        G1Point qPoseidon2External;\n        G1Point qPoseidon2Internal;\n        // Copy cnstraints\n        G1Point s1;\n        G1Point s2;\n        G1Point s3;\n        G1Point s4;\n        // Copy identity\n        G1Point id1;\n        G1Point id2;\n        G1Point id3;\n        G1Point id4;\n        // Precomputed lookup table\n        G1Point t1;\n        G1Point t2;\n        G1Point t3;\n        G1Point t4;\n        // Fixed first and last\n        G1Point lagrangeFirst;\n        G1Point lagrangeLast;\n    }\n\n    struct RelationParameters {\n        // challenges\n        Fr eta;\n        Fr etaTwo;\n        Fr etaThree;\n        Fr beta;\n        Fr gamma;\n        // derived\n        Fr publicInputsDelta;\n    }\n\n    struct Proof {\n        // Pairing point object\n        Fr[PAIRING_POINTS_SIZE] pairingPointObject;\n        // Free wires\n        G1Point w1;\n        G1Point w2;\n        G1Point w3;\n        G1Point w4;\n        // Lookup helpers - Permutations\n        G1Point zPerm;\n        // Lookup helpers - logup\n        G1Point lookupReadCounts;\n        G1Point lookupReadTags;\n        G1Point lookupInverses;\n        // Sumcheck\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\n        // Shplemini\n        G1Point[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\n        G1Point shplonkQ;\n        G1Point kzgQuotient;\n    }\n\n    struct ZKProof {\n        // Pairing point object\n        Fr[PAIRING_POINTS_SIZE] pairingPointObject;\n        // Commitments to wire polynomials\n        G1Point w1;\n        G1Point w2;\n        G1Point w3;\n        G1Point w4;\n        // Commitments to logup witness polynomials\n        G1Point lookupReadCounts;\n        G1Point lookupReadTags;\n        G1Point lookupInverses;\n        // Commitment to grand permutation polynomial\n        G1Point zPerm;\n        G1Point[3] libraCommitments;\n        // Sumcheck\n        Fr libraSum;\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\n        Fr libraEvaluation;\n        // ZK\n        G1Point geminiMaskingPoly;\n        Fr geminiMaskingEval;\n        // Shplemini\n        G1Point[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\n        Fr[4] libraPolyEvals;\n        G1Point shplonkQ;\n        G1Point kzgQuotient;\n    }\n}\n\n// ZKTranscript library to generate fiat shamir challenges, the ZK transcript only differest\nstruct ZKTranscript {\n    // Oink\n    Honk.RelationParameters relationParameters;\n    Fr[NUMBER_OF_ALPHAS] alphas;\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\n    // Sumcheck\n    Fr libraChallenge;\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\n    // Shplemini\n    Fr rho;\n    Fr geminiR;\n    Fr shplonkNu;\n    Fr shplonkZ;\n    // Derived\n    Fr publicInputsDelta;\n}\n\nlibrary ZKTranscriptLib {\n    function generateTranscript(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize,\n        uint256 logN\n    ) external pure returns (ZKTranscript memory t) {\n        Fr previousChallenge;\n        (t.relationParameters, previousChallenge) =\n            generateRelationParametersChallenges(proof, publicInputs, vkHash, publicInputsSize, previousChallenge);\n\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\n\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge, logN);\n        (t.libraChallenge, previousChallenge) = generateLibraChallenge(previousChallenge, proof);\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge, logN);\n\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\n\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge, logN);\n\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge, logN);\n\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\n        return t;\n    }\n\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        uint256 hi = challengeU256 >> 128;\n        first = FrLib.fromBytes32(bytes32(lo));\n        second = FrLib.fromBytes32(bytes32(hi));\n    }\n\n    function generateRelationParametersChallenges(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize,\n        Fr previousChallenge\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\n            generateEtaChallenge(proof, publicInputs, vkHash, publicInputsSize);\n\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\n    }\n\n    function generateEtaChallenge(\n        Honk.ZKProof memory proof,\n        bytes32[] calldata publicInputs,\n        uint256 vkHash,\n        uint256 publicInputsSize\n    ) internal pure returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge) {\n        bytes32[] memory round0 = new bytes32[](1 + publicInputsSize + 6);\n        round0[0] = bytes32(vkHash);\n\n        for (uint256 i = 0; i < publicInputsSize - PAIRING_POINTS_SIZE; i++) {\n            round0[1 + i] = bytes32(publicInputs[i]);\n        }\n        for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n            round0[1 + publicInputsSize - PAIRING_POINTS_SIZE + i] = FrLib.toBytes32(proof.pairingPointObject[i]);\n        }\n\n        // Create the first challenge\n        // Note: w4 is added to the challenge later on\n        round0[1 + publicInputsSize] = bytes32(proof.w1.x);\n        round0[1 + publicInputsSize + 1] = bytes32(proof.w1.y);\n        round0[1 + publicInputsSize + 2] = bytes32(proof.w2.x);\n        round0[1 + publicInputsSize + 3] = bytes32(proof.w2.y);\n        round0[1 + publicInputsSize + 4] = bytes32(proof.w3.x);\n        round0[1 + publicInputsSize + 5] = bytes32(proof.w3.y);\n\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\n        (eta, etaTwo) = splitChallenge(previousChallenge);\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\n\n        (etaThree,) = splitChallenge(previousChallenge);\n    }\n\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\n    {\n        bytes32[7] memory round1;\n        round1[0] = FrLib.toBytes32(previousChallenge);\n        round1[1] = bytes32(proof.lookupReadCounts.x);\n        round1[2] = bytes32(proof.lookupReadCounts.y);\n        round1[3] = bytes32(proof.lookupReadTags.x);\n        round1[4] = bytes32(proof.lookupReadTags.y);\n        round1[5] = bytes32(proof.w4.x);\n        round1[6] = bytes32(proof.w4.y);\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\n    }\n\n    // Alpha challenges non-linearise the gate contributions\n    function generateAlphaChallenges(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\n    {\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\n        uint256[5] memory alpha0;\n        alpha0[0] = Fr.unwrap(previousChallenge);\n        alpha0[1] = proof.lookupInverses.x;\n        alpha0[2] = proof.lookupInverses.y;\n        alpha0[3] = proof.zPerm.x;\n        alpha0[4] = proof.zPerm.y;\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\n        Fr alpha;\n        (alpha,) = splitChallenge(nextPreviousChallenge);\n\n        // Compute powers of alpha for batching subrelations\n        alphas[0] = alpha;\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS; i++) {\n            alphas[i] = alphas[i - 1] * alpha;\n        }\n    }\n\n    function generateGateChallenges(Fr previousChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\n    {\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\n        (gateChallenges[0],) = splitChallenge(previousChallenge);\n        for (uint256 i = 1; i < logN; i++) {\n            gateChallenges[i] = gateChallenges[i - 1] * gateChallenges[i - 1];\n        }\n        nextPreviousChallenge = previousChallenge;\n    }\n\n    function generateLibraChallenge(Fr previousChallenge, Honk.ZKProof memory proof)\n        internal\n        pure\n        returns (Fr libraChallenge, Fr nextPreviousChallenge)\n    {\n        // 2 comm, 1 sum, 1 challenge\n        uint256[4] memory challengeData;\n        challengeData[0] = Fr.unwrap(previousChallenge);\n        challengeData[1] = proof.libraCommitments[0].x;\n        challengeData[2] = proof.libraCommitments[0].y;\n        challengeData[3] = Fr.unwrap(proof.libraSum);\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(challengeData)));\n        (libraChallenge,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateSumcheckChallenges(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\n    {\n        for (uint256 i = 0; i < logN; i++) {\n            Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\n            univariateChal[0] = prevChallenge;\n\n            for (uint256 j = 0; j < ZK_BATCHED_RELATION_PARTIAL_LENGTH; j++) {\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\n            }\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\n\n            (sumcheckChallenges[i],) = splitChallenge(prevChallenge);\n        }\n        nextPreviousChallenge = prevChallenge;\n    }\n\n    // We add Libra claimed eval + 3 comm + 1 more eval\n    function generateRhoChallenge(Honk.ZKProof memory proof, Fr prevChallenge)\n        internal\n        pure\n        returns (Fr rho, Fr nextPreviousChallenge)\n    {\n        uint256[NUMBER_OF_ENTITIES + 9] memory rhoChallengeElements;\n        rhoChallengeElements[0] = Fr.unwrap(prevChallenge);\n        uint256 i;\n        for (i = 1; i <= NUMBER_OF_ENTITIES; i++) {\n            rhoChallengeElements[i] = Fr.unwrap(proof.sumcheckEvaluations[i - 1]);\n        }\n        rhoChallengeElements[i] = Fr.unwrap(proof.libraEvaluation);\n\n        i += 1;\n        rhoChallengeElements[i] = proof.libraCommitments[1].x;\n        rhoChallengeElements[i + 1] = proof.libraCommitments[1].y;\n        i += 2;\n        rhoChallengeElements[i] = proof.libraCommitments[2].x;\n        rhoChallengeElements[i + 1] = proof.libraCommitments[2].y;\n        i += 2;\n        rhoChallengeElements[i] = proof.geminiMaskingPoly.x;\n        rhoChallengeElements[i + 1] = proof.geminiMaskingPoly.y;\n\n        i += 2;\n        rhoChallengeElements[i] = Fr.unwrap(proof.geminiMaskingEval);\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\n        (rho,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateGeminiRChallenge(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr geminiR, Fr nextPreviousChallenge)\n    {\n        uint256[] memory gR = new uint256[]((logN - 1) * 2 + 1);\n        gR[0] = Fr.unwrap(prevChallenge);\n\n        for (uint256 i = 0; i < logN - 1; i++) {\n            gR[1 + i * 2] = proof.geminiFoldComms[i].x;\n            gR[2 + i * 2] = proof.geminiFoldComms[i].y;\n        }\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\n\n        (geminiR,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateShplonkNuChallenge(Honk.ZKProof memory proof, Fr prevChallenge, uint256 logN)\n        internal\n        pure\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\n    {\n        uint256[] memory shplonkNuChallengeElements = new uint256[](logN + 1 + 4);\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\n\n        for (uint256 i = 1; i <= logN; i++) {\n            shplonkNuChallengeElements[i] = Fr.unwrap(proof.geminiAEvaluations[i - 1]);\n        }\n\n        uint256 libraIdx = 0;\n        for (uint256 i = logN + 1; i <= logN + 4; i++) {\n            shplonkNuChallengeElements[i] = Fr.unwrap(proof.libraPolyEvals[libraIdx]);\n            libraIdx++;\n        }\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\n        (shplonkNu,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function generateShplonkZChallenge(Honk.ZKProof memory proof, Fr prevChallenge)\n        internal\n        pure\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\n    {\n        uint256[3] memory shplonkZChallengeElements;\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\n\n        shplonkZChallengeElements[1] = proof.shplonkQ.x;\n        shplonkZChallengeElements[2] = proof.shplonkQ.y;\n\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\n        (shplonkZ,) = splitChallenge(nextPreviousChallenge);\n    }\n\n    function loadProof(bytes calldata proof, uint256 logN) internal pure returns (Honk.ZKProof memory p) {\n        uint256 boundary = 0x0;\n\n        // Pairing point object\n        for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n            p.pairingPointObject[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n        // Commitments\n        p.w1 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w2 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w3 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n\n        // Lookup / Permutation Helper Commitments\n        p.lookupReadCounts = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.lookupReadTags = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.w4 = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.lookupInverses = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.zPerm = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.libraCommitments[0] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n\n        p.libraSum = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n        // Sumcheck univariates\n        for (uint256 i = 0; i < logN; i++) {\n            for (uint256 j = 0; j < ZK_BATCHED_RELATION_PARTIAL_LENGTH; j++) {\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n                boundary += FIELD_ELEMENT_SIZE;\n            }\n        }\n\n        // Sumcheck evaluations\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        p.libraEvaluation = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n\n        p.libraCommitments[1] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.libraCommitments[2] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.geminiMaskingPoly = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        p.geminiMaskingEval = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n        boundary += FIELD_ELEMENT_SIZE;\n\n        // Gemini\n        // Read gemini fold univariates\n        for (uint256 i = 0; i < logN - 1; i++) {\n            p.geminiFoldComms[i] = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n            boundary += GROUP_ELEMENT_SIZE;\n        }\n\n        // Read gemini a evaluations\n        for (uint256 i = 0; i < logN; i++) {\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        for (uint256 i = 0; i < 4; i++) {\n            p.libraPolyEvals[i] = bytesToFr(proof[boundary:boundary + FIELD_ELEMENT_SIZE]);\n            boundary += FIELD_ELEMENT_SIZE;\n        }\n\n        // Shplonk\n        p.shplonkQ = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n        boundary += GROUP_ELEMENT_SIZE;\n        // KZG\n        p.kzgQuotient = bytesToG1Point(proof[boundary:boundary + GROUP_ELEMENT_SIZE]);\n    }\n}\n\n// Field arithmetic libraries\n\nlibrary RelationsLib {\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\n\n    function accumulateRelationEvaluations(\n        Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\n        Fr powPartialEval\n    ) internal pure returns (Fr accumulator) {\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\n\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulateMemoryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\n        accumulateNnfRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\n\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\n    }\n\n    /**\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\n     * editors, and thus is noisy.\n     */\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\n        return p[uint256(_wire)];\n    }\n\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\n    /**\n     * Ultra Arithmetic Relation\n     *\n     */\n\n    function accumulateArithmeticRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        // Relation 0\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\n        {\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\n\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\n            accum = accum + (q_arith - ONE) * wire(p, WIRE.W_4_SHIFT);\n            accum = accum * q_arith;\n            accum = accum * domainSep;\n            evals[0] = accum;\n        }\n\n        // Relation 1\n        {\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\n            accum = accum * (q_arith - Fr.wrap(2));\n            accum = accum * (q_arith - ONE);\n            accum = accum * q_arith;\n            accum = accum * domainSep;\n            evals[1] = accum;\n        }\n    }\n\n    function accumulatePermutationRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr grand_product_numerator;\n        Fr grand_product_denominator;\n\n        {\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\n\n            grand_product_numerator = num;\n        }\n        {\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\n\n            grand_product_denominator = den;\n        }\n\n        // Contribution 2\n        {\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\n\n            acc = acc\n                - (\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\n                        * grand_product_denominator\n                );\n            acc = acc * domainSep;\n            evals[2] = acc;\n        }\n\n        // Contribution 3\n        {\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\n            evals[3] = acc;\n        }\n    }\n\n    function accumulateLogDerivativeLookupRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr write_term;\n        Fr read_term;\n\n        // Calculate the write term (the table accumulation)\n        {\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\n        }\n\n        // Calculate the write term\n        {\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\n\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\n        }\n\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\n\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\n\n        // Inverse calculated correctly relation\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\n        accumulatorNone = accumulatorNone * domainSep;\n\n        // Inverse\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\n\n        Fr read_tag = wire(p, WIRE.LOOKUP_READ_TAGS);\n\n        Fr read_tag_boolean_relation = read_tag * read_tag - read_tag;\n\n        evals[4] = accumulatorNone;\n        evals[5] = accumulatorOne;\n        evals[6] = read_tag_boolean_relation * domainSep;\n    }\n\n    function accumulateDeltaRangeRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        Fr minus_one = ZERO - ONE;\n        Fr minus_two = ZERO - Fr.wrap(2);\n        Fr minus_three = ZERO - Fr.wrap(3);\n\n        // Compute wire differences\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\n\n        // Contribution 6\n        {\n            Fr acc = delta_1;\n            acc = acc * (delta_1 + minus_one);\n            acc = acc * (delta_1 + minus_two);\n            acc = acc * (delta_1 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[7] = acc;\n        }\n\n        // Contribution 7\n        {\n            Fr acc = delta_2;\n            acc = acc * (delta_2 + minus_one);\n            acc = acc * (delta_2 + minus_two);\n            acc = acc * (delta_2 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[8] = acc;\n        }\n\n        // Contribution 8\n        {\n            Fr acc = delta_3;\n            acc = acc * (delta_3 + minus_one);\n            acc = acc * (delta_3 + minus_two);\n            acc = acc * (delta_3 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[9] = acc;\n        }\n\n        // Contribution 9\n        {\n            Fr acc = delta_4;\n            acc = acc * (delta_4 + minus_one);\n            acc = acc * (delta_4 + minus_two);\n            acc = acc * (delta_4 + minus_three);\n            acc = acc * wire(p, WIRE.Q_RANGE);\n            acc = acc * domainSep;\n            evals[10] = acc;\n        }\n    }\n\n    struct EllipticParams {\n        // Points\n        Fr x_1;\n        Fr y_1;\n        Fr x_2;\n        Fr y_2;\n        Fr y_3;\n        Fr x_3;\n        // push accumulators into memory\n        Fr x_double_identity;\n    }\n\n    function accumulateEllipticRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        EllipticParams memory ep;\n        ep.x_1 = wire(p, WIRE.W_R);\n        ep.y_1 = wire(p, WIRE.W_O);\n\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\n\n        Fr q_sign = wire(p, WIRE.Q_L);\n        Fr q_is_double = wire(p, WIRE.Q_M);\n\n        // Contribution 10 point addition, x-coordinate check\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n        Fr x_diff = (ep.x_2 - ep.x_1);\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\n        {\n            // Move to top\n            Fr partialEval = domainSep;\n\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\n            x_add_identity = x_add_identity * x_diff * x_diff;\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\n\n            evals[11] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (ONE - q_is_double);\n        }\n\n        // Contribution 11 point addition, x-coordinate check\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\n        {\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\n            evals[12] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (ONE - q_is_double);\n        }\n\n        // Contribution 10 point doubling, x-coordinate check\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\n        {\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\n\n            // NOTE: pushed into memory (stack >:'( )\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\n\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\n            evals[11] = evals[11] + acc;\n        }\n\n        // Contribution 11 point doubling, y-coordinate check\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\n        {\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\n            evals[12] = evals[12] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\n        }\n    }\n\n    // Parameters used within the Memory Relation\n    // A struct is used to work around stack too deep. This relation has alot of variables\n    struct MemParams {\n        Fr memory_record_check;\n        Fr partial_record_check;\n        Fr next_gate_access_type;\n        Fr record_delta;\n        Fr index_delta;\n        Fr adjacent_values_match_if_adjacent_indices_match;\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\n        Fr access_check;\n        Fr next_gate_access_type_is_boolean;\n        Fr ROM_consistency_check_identity;\n        Fr RAM_consistency_check_identity;\n        Fr timestamp_delta;\n        Fr RAM_timestamp_check_identity;\n        Fr memory_identity;\n        Fr index_is_monotonically_increasing;\n    }\n\n    function accumulateMemoryRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Honk.RelationParameters memory rp,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        MemParams memory ap;\n\n        /**\n         * MEMORY\n         *\n         * A RAM memory record contains a tuple of the following fields:\n         *  * i: `index` of memory cell being accessed\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\n         *  * v: `value` of memory cell being accessed\n         *  * a: `access` type of record. read: 0 = read, 1 = write\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\n         *\n         * A ROM memory record contains a tuple of the following fields:\n         *  * i: `index` of memory cell being accessed\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\n         *\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\n         *\n         *  | gate type | i  | v2/t  |  v | a  | r  |\n         *  | --------- | -- | ----- | -- | -- | -- |\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\n         *\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\n         * `w2` to fix its value)\n         *\n         *\n         */\n\n        /**\n         * Memory Record Check\n         * Partial degree: 1\n         * Total degree: 4\n         *\n         * A ROM/ROM access gate can be evaluated with the identity:\n         *\n         * qc + w1 \\eta + w2 \\eta_two + w3 \\eta_three - w4 = 0\n         *\n         * For ROM gates, qc = 0\n         */\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\n\n        /**\n         * Contribution 13 & 14\n         * ROM Consistency Check\n         * Partial degree: 1\n         * Total degree: 4\n         *\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\n         * records that are sorted.\n         *\n         * We apply the following checks for the sorted records:\n         *\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\n         * 2. index values for adjacent records are monotonically increasing\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\n         *\n         */\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\n\n        ap.index_is_monotonically_increasing = ap.index_delta * (ap.index_delta - Fr.wrap(1)); // deg 2\n\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + ONE) * ap.record_delta; // deg 2\n\n        evals[14] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\n            * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5\n        evals[15] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\n            * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5\n\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\n\n        /**\n         * Contributions 15,16,17\n         * RAM Consistency Check\n         *\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\n         * This is validated by requiring `access` to be boolean\n         *\n         * For two adjacent entries in the sorted list if _both_\n         *  A) index values match\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\n         * then\n         *  C) both values must match.\n         * The gate boolean check is\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\n         *\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\n         * with a WRITE operation.\n         */\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\n        ap.access_check = access_type * (access_type - Fr.wrap(1)); // check value is 0 or 1; deg 2 or 8\n\n        // reverse order we could re-use `ap.partial_record_check`  1 -  ((w3' * eta + w2') * eta + w1') * eta\n        // deg 1 or 4\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\n\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation =\n            (ap.index_delta * MINUS_ONE + ONE) * value_delta * (ap.next_gate_access_type * MINUS_ONE + ONE); // deg 3 or 6\n\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\n        // type is  correct, to cover this edge case\n        // deg 2 or 4\n        ap.next_gate_access_type_is_boolean =\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\n\n        // Putting it all together...\n        evals[16] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\n            * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 5 or 8\n        evals[17] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4\n        evals[18] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_O)) * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4 or 6\n\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_O)); // deg 3 or 9\n\n        /**\n         * RAM Timestamp Consistency Check\n         *\n         * | w1 | w2 | w3 | w4 |\n         * | index | timestamp | timestamp_check | -- |\n         *\n         * Let delta_index = index_{i + 1} - index_{i}\n         *\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\n         * Else timestamp_check = 0\n         */\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\n        ap.RAM_timestamp_check_identity = (ap.index_delta * MINUS_ONE + ONE) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\n\n        /**\n         * Complete Contribution 12\n         * The complete RAM/ROM memory identity\n         * Partial degree:\n         */\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\n        ap.memory_identity =\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\n\n        // (deg 3 or 9) + (deg 4) + (deg 3)\n        ap.memory_identity = ap.memory_identity * (wire(p, WIRE.Q_MEMORY) * domainSep); // deg 4 or 10\n        evals[13] = ap.memory_identity;\n    }\n\n    // Constants for the Non-native Field relation\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\n\n    // Parameters used within the Non-Native Field Relation\n    // A struct is used to work around stack too deep. This relation has alot of variables\n    struct NnfParams {\n        Fr limb_subproduct;\n        Fr non_native_field_gate_1;\n        Fr non_native_field_gate_2;\n        Fr non_native_field_gate_3;\n        Fr limb_accumulator_1;\n        Fr limb_accumulator_2;\n        Fr nnf_identity;\n    }\n\n    function accumulateNnfRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        NnfParams memory ap;\n\n        /**\n         * Contribution 12\n         * Non native field arithmetic gate 2\n         * deg 4\n         *\n         *             _                                                                               _\n         *            /   _                   _                               _       14                \\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\n         *            \\_                                                                               _/\n         *\n         *\n         */\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\n        ap.non_native_field_gate_2 =\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\n\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\n\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\n\n        Fr non_native_field_identity =\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\n\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\n        // deg 2\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\n\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\n        // deg 2\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\n\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\n\n        ap.nnf_identity = non_native_field_identity + limb_accumulator_identity;\n        ap.nnf_identity = ap.nnf_identity * (wire(p, WIRE.Q_NNF) * domainSep);\n        evals[19] = ap.nnf_identity;\n    }\n\n    struct PoseidonExternalParams {\n        Fr s1;\n        Fr s2;\n        Fr s3;\n        Fr s4;\n        Fr u1;\n        Fr u2;\n        Fr u3;\n        Fr u4;\n        Fr t0;\n        Fr t1;\n        Fr t2;\n        Fr t3;\n        Fr v1;\n        Fr v2;\n        Fr v3;\n        Fr v4;\n        Fr q_pos_by_scaling;\n    }\n\n    function accumulatePoseidonExternalRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        PoseidonExternalParams memory ep;\n\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\n\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\n        // matrix mul v = M_E * u with 14 additions\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\n        ep.v4 = ep.t1 + ep.t1;\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\n        ep.v2 = ep.t0 + ep.t0;\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\n\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\n\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\n\n        evals[22] = evals[22] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\n\n        evals[23] = evals[23] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\n    }\n\n    struct PoseidonInternalParams {\n        Fr u1;\n        Fr u2;\n        Fr u3;\n        Fr u4;\n        Fr u_sum;\n        Fr v1;\n        Fr v2;\n        Fr v3;\n        Fr v4;\n        Fr s1;\n        Fr q_pos_by_scaling;\n    }\n\n    function accumulatePoseidonInternalRelation(\n        Fr[NUMBER_OF_ENTITIES] memory p,\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\n        Fr domainSep\n    ) internal pure {\n        PoseidonInternalParams memory ip;\n\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\n        ];\n\n        // add round constants\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\n\n        // apply s-box round\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\n        ip.u2 = wire(p, WIRE.W_R);\n        ip.u3 = wire(p, WIRE.W_O);\n        ip.u4 = wire(p, WIRE.W_4);\n\n        // matrix mul with v = M_I * u 4 muls and 7 additions\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\n\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\n\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\n\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\n\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\n        evals[26] = evals[26] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\n\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\n        evals[27] = evals[27] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\n    }\n\n    function scaleAndBatchSubrelations(\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\n    ) internal pure returns (Fr accumulator) {\n        accumulator = evaluations[0];\n\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\n        }\n    }\n}\n\n// Field arithmetic libraries - prevent littering the code with modmul / addmul\n\nlibrary CommitmentSchemeLib {\n    using FrLib for Fr;\n\n    // Avoid stack too deep\n    struct ShpleminiIntermediates {\n        Fr unshiftedScalar;\n        Fr shiftedScalar;\n        Fr unshiftedScalarNeg;\n        Fr shiftedScalarNeg;\n        // Scalar to be multiplied by [1]₁\n        Fr constantTermAccumulator;\n        // Accumulator for powers of rho\n        Fr batchingChallenge;\n        // Linear combination of multilinear (sumcheck) evaluations and powers of rho\n        Fr batchedEvaluation;\n        Fr[4] denominators;\n        Fr[4] batchingScalars;\n        // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\n        Fr posInvertedDenominator;\n        // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\n        Fr negInvertedDenominator;\n        // ν^{2i} * 1/(z - r^{2^i})\n        Fr scalingFactorPos;\n        // ν^{2i+1} * 1/(z + r^{2^i})\n        Fr scalingFactorNeg;\n        // Fold_i(r^{2^i}) reconstructed by Verifier\n        Fr[] foldPosEvaluations;\n    }\n\n    function computeSquares(Fr r, uint256 logN) internal pure returns (Fr[] memory) {\n        Fr[] memory squares = new Fr[](logN);\n        squares[0] = r;\n        for (uint256 i = 1; i < logN; ++i) {\n            squares[i] = squares[i - 1].sqr();\n        }\n        return squares;\n    }\n    // Compute the evaluations Aₗ(r^{2ˡ}) for l = 0, ..., m-1\n\n    function computeFoldPosEvaluations(\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\n        Fr batchedEvalAccumulator,\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\n        Fr[] memory geminiEvalChallengePowers,\n        uint256 logSize\n    ) internal view returns (Fr[] memory) {\n        Fr[] memory foldPosEvaluations = new Fr[](logSize);\n        for (uint256 i = logSize; i > 0; --i) {\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\n            Fr u = sumcheckUChallenges[i - 1];\n\n            Fr batchedEvalRoundAcc = (\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\n                    - geminiEvaluations[i - 1] * (challengePower * (ONE - u) - u)\n            );\n            // Divide by the denominator\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (ONE - u) + u).invert();\n\n            batchedEvalAccumulator = batchedEvalRoundAcc;\n            foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\n        }\n        return foldPosEvaluations;\n    }\n}\n\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\n\nfunction bytes32ToString(bytes32 value) pure returns (string memory result) {\n    bytes memory alphabet = \"0123456789abcdef\";\n\n    bytes memory str = new bytes(66);\n    str[0] = \"0\";\n    str[1] = \"x\";\n    for (uint256 i = 0; i < 32; i++) {\n        str[2 + i * 2] = alphabet[uint8(value[i] >> 4)];\n        str[3 + i * 2] = alphabet[uint8(value[i] & 0x0f)];\n    }\n    result = string(str);\n}\n\n// Fr utility\n\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\n}\n\n// EC Point utilities\nfunction bytesToG1Point(bytes calldata proofSection) pure returns (Honk.G1Point memory point) {\n    point = Honk.G1Point({\n        x: uint256(bytes32(proofSection[0x00:0x20])) % Q,\n        y: uint256(bytes32(proofSection[0x20:0x40])) % Q\n    });\n}\n\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\n    point.y = (Q - point.y) % Q;\n    return point;\n}\n\n/**\n * Convert the pairing points to G1 points.\n *\n * The pairing points are serialised as an array of 68 bit limbs representing two points\n * The lhs of a pairing operation and the rhs of a pairing operation\n *\n * There are 4 fields for each group element, leaving 8 fields for each side of the pairing.\n *\n * @param pairingPoints The pairing points to convert.\n * @return lhs\n * @return rhs\n */\nfunction convertPairingPointsToG1(Fr[PAIRING_POINTS_SIZE] memory pairingPoints)\n    pure\n    returns (Honk.G1Point memory lhs, Honk.G1Point memory rhs)\n{\n    uint256 lhsX = Fr.unwrap(pairingPoints[0]);\n    lhsX |= Fr.unwrap(pairingPoints[1]) << 68;\n    lhsX |= Fr.unwrap(pairingPoints[2]) << 136;\n    lhsX |= Fr.unwrap(pairingPoints[3]) << 204;\n    lhs.x = lhsX;\n\n    uint256 lhsY = Fr.unwrap(pairingPoints[4]);\n    lhsY |= Fr.unwrap(pairingPoints[5]) << 68;\n    lhsY |= Fr.unwrap(pairingPoints[6]) << 136;\n    lhsY |= Fr.unwrap(pairingPoints[7]) << 204;\n    lhs.y = lhsY;\n\n    uint256 rhsX = Fr.unwrap(pairingPoints[8]);\n    rhsX |= Fr.unwrap(pairingPoints[9]) << 68;\n    rhsX |= Fr.unwrap(pairingPoints[10]) << 136;\n    rhsX |= Fr.unwrap(pairingPoints[11]) << 204;\n    rhs.x = rhsX;\n\n    uint256 rhsY = Fr.unwrap(pairingPoints[12]);\n    rhsY |= Fr.unwrap(pairingPoints[13]) << 68;\n    rhsY |= Fr.unwrap(pairingPoints[14]) << 136;\n    rhsY |= Fr.unwrap(pairingPoints[15]) << 204;\n    rhs.y = rhsY;\n}\n\n/**\n * Hash the pairing inputs from the present verification context with those extracted from the public inputs.\n *\n * @param proofPairingPoints Pairing points from the proof - (public inputs).\n * @param accLhs Accumulator point for the left side - result of shplemini.\n * @param accRhs Accumulator point for the right side - result of shplemini.\n * @return recursionSeparator The recursion separator - generated from hashing the above.\n */\nfunction generateRecursionSeparator(\n    Fr[PAIRING_POINTS_SIZE] memory proofPairingPoints,\n    Honk.G1Point memory accLhs,\n    Honk.G1Point memory accRhs\n) pure returns (Fr recursionSeparator) {\n    // hash the proof aggregated X\n    // hash the proof aggregated Y\n    // hash the accum X\n    // hash the accum Y\n\n    (Honk.G1Point memory proofLhs, Honk.G1Point memory proofRhs) = convertPairingPointsToG1(proofPairingPoints);\n\n    uint256[8] memory recursionSeparatorElements;\n\n    // Proof points\n    recursionSeparatorElements[0] = proofLhs.x;\n    recursionSeparatorElements[1] = proofLhs.y;\n    recursionSeparatorElements[2] = proofRhs.x;\n    recursionSeparatorElements[3] = proofRhs.y;\n\n    // Accumulator points\n    recursionSeparatorElements[4] = accLhs.x;\n    recursionSeparatorElements[5] = accLhs.y;\n    recursionSeparatorElements[6] = accRhs.x;\n    recursionSeparatorElements[7] = accRhs.y;\n\n    recursionSeparator = FrLib.fromBytes32(keccak256(abi.encodePacked(recursionSeparatorElements)));\n}\n\n/**\n * G1 Mul with Separator\n * Using the ecAdd and ecMul precompiles\n *\n * @param basePoint The point to multiply.\n * @param other The other point to add.\n * @param recursionSeperator The separator to use for the multiplication.\n * @return `(recursionSeperator * basePoint) + other`.\n */\nfunction mulWithSeperator(Honk.G1Point memory basePoint, Honk.G1Point memory other, Fr recursionSeperator)\n    view\n    returns (Honk.G1Point memory)\n{\n    Honk.G1Point memory result;\n\n    result = ecMul(recursionSeperator, basePoint);\n    result = ecAdd(result, other);\n\n    return result;\n}\n\n/**\n * G1 Mul\n * Takes a Fr value and a G1 point and uses the ecMul precompile to return the result.\n *\n * @param value The value to multiply the point by.\n * @param point The point to multiply.\n * @return result The result of the multiplication.\n */\nfunction ecMul(Fr value, Honk.G1Point memory point) view returns (Honk.G1Point memory) {\n    Honk.G1Point memory result;\n\n    assembly {\n        let free := mload(0x40)\n        // Write the point into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free       |  point.x\n        // free + 0x20|  point.y\n        mstore(free, mload(point))\n        mstore(add(free, 0x20), mload(add(point, 0x20)))\n        // Write the scalar into memory (one 32 byte word)\n        // Memory layout:\n        // Address    |  value\n        // free + 0x40|  value\n        mstore(add(free, 0x40), value)\n\n        // Call the ecMul precompile, it takes in the following\n        // [point.x, point.y, scalar], and returns the result back into the free memory location.\n        let success := staticcall(gas(), 0x07, free, 0x60, free, 0x40)\n        if iszero(success) {\n            revert(0, 0)\n        }\n        // Copy the result of the multiplication back into the result memory location.\n        // Memory layout:\n        // Address    |  value\n        // result     |  result.x\n        // result + 0x20|  result.y\n        mstore(result, mload(free))\n        mstore(add(result, 0x20), mload(add(free, 0x20)))\n\n        mstore(0x40, add(free, 0x60))\n    }\n\n    return result;\n}\n\n/**\n * G1 Add\n * Takes two G1 points and uses the ecAdd precompile to return the result.\n *\n * @param lhs The left hand side of the addition.\n * @param rhs The right hand side of the addition.\n * @return result The result of the addition.\n */\nfunction ecAdd(Honk.G1Point memory lhs, Honk.G1Point memory rhs) view returns (Honk.G1Point memory) {\n    Honk.G1Point memory result;\n\n    assembly {\n        let free := mload(0x40)\n        // Write lhs into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free       |  lhs.x\n        // free + 0x20|  lhs.y\n        mstore(free, mload(lhs))\n        mstore(add(free, 0x20), mload(add(lhs, 0x20)))\n\n        // Write rhs into memory (two 32 byte words)\n        // Memory layout:\n        // Address    |  value\n        // free + 0x40|  rhs.x\n        // free + 0x60|  rhs.y\n        mstore(add(free, 0x40), mload(rhs))\n        mstore(add(free, 0x60), mload(add(rhs, 0x20)))\n\n        // Call the ecAdd precompile, it takes in the following\n        // [lhs.x, lhs.y, rhs.x, rhs.y], and returns their addition back into the free memory location.\n        let success := staticcall(gas(), 0x06, free, 0x80, free, 0x40)\n        if iszero(success) { revert(0, 0) }\n\n        // Copy the result of the addition back into the result memory location.\n        // Memory layout:\n        // Address    |  value\n        // result     |  result.x\n        // result + 0x20|  result.y\n        mstore(result, mload(free))\n        mstore(add(result, 0x20), mload(add(free, 0x20)))\n\n        mstore(0x40, add(free, 0x80))\n    }\n\n    return result;\n}\n\nfunction validateOnCurve(Honk.G1Point memory point) pure {\n    uint256 x = point.x;\n    uint256 y = point.y;\n\n    bool success = false;\n    assembly {\n        let xx := mulmod(x, x, Q)\n        success := eq(mulmod(y, y, Q), addmod(mulmod(x, xx, Q), 3, Q))\n    }\n\n    require(success, \"point is not on the curve\");\n}\n\nfunction pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool decodedResult) {\n    bytes memory input = abi.encodePacked(\n        rhs.x,\n        rhs.y,\n        // Fixed G2 point\n        uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\n        uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\n        uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\n        uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\n        lhs.x,\n        lhs.y,\n        // G2 point from VK\n        uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\n        uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\n        uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\n        uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\n    );\n\n    (bool success, bytes memory result) = address(0x08).staticcall(input);\n    decodedResult = success && abi.decode(result, (bool));\n}\n\n// Field arithmetic libraries - prevent littering the code with modmul / addmul\n\n\n\n\nabstract contract BaseZKHonkVerifier is IVerifier {\n    using FrLib for Fr;\n\n    uint256 immutable $N;\n    uint256 immutable $LOG_N;\n    uint256 immutable $VK_HASH;\n    uint256 immutable $NUM_PUBLIC_INPUTS;\n\n    constructor(uint256 _N, uint256 _logN, uint256 _vkHash, uint256 _numPublicInputs) {\n        $N = _N;\n        $LOG_N = _logN;\n        $VK_HASH = _vkHash;\n        $NUM_PUBLIC_INPUTS = _numPublicInputs;\n    }\n\n    // Errors\n    error ProofLengthWrong();\n    error ProofLengthWrongWithLogN(uint256 logN, uint256 actualLength, uint256 expectedLength);\n    error PublicInputsLengthWrong();\n    error SumcheckFailed();\n    error ShpleminiFailed();\n    error GeminiChallengeInSubgroup();\n    error ConsistencyCheckFailed();\n\n    // Constants for proof length calculation (matching UltraKeccakZKFlavor)\n    uint256 constant NUM_WITNESS_ENTITIES = 8;\n    uint256 constant NUM_ELEMENTS_COMM = 2; // uint256 elements for curve points\n    uint256 constant NUM_ELEMENTS_FR = 1; // uint256 elements for field elements\n    uint256 constant NUM_LIBRA_EVALUATIONS = 4; // libra evaluations\n\n    // Calculate proof size based on log_n (matching UltraKeccakZKFlavor formula)\n    function calculateProofSize(uint256 logN) internal pure returns (uint256) {\n        // Witness and Libra commitments\n        uint256 proofLength = NUM_WITNESS_ENTITIES * NUM_ELEMENTS_COMM; // witness commitments\n        proofLength += NUM_ELEMENTS_COMM * 4; // Libra concat, grand sum, quotient comms + Gemini masking\n\n        // Sumcheck\n        proofLength += logN * ZK_BATCHED_RELATION_PARTIAL_LENGTH * NUM_ELEMENTS_FR; // sumcheck univariates\n        proofLength += NUMBER_OF_ENTITIES * NUM_ELEMENTS_FR; // sumcheck evaluations\n\n        // Libra and Gemini\n        proofLength += NUM_ELEMENTS_FR * 3; // Libra sum, claimed eval, Gemini masking eval\n        proofLength += logN * NUM_ELEMENTS_FR; // Gemini a evaluations\n        proofLength += NUM_LIBRA_EVALUATIONS * NUM_ELEMENTS_FR; // libra evaluations\n\n        // PCS commitments\n        proofLength += (logN - 1) * NUM_ELEMENTS_COMM; // Gemini Fold commitments\n        proofLength += NUM_ELEMENTS_COMM * 2; // Shplonk Q and KZG W commitments\n\n        // Pairing points\n        proofLength += PAIRING_POINTS_SIZE; // pairing inputs carried on public inputs\n\n        return proofLength;\n    }\n\n    uint256 constant SHIFTED_COMMITMENTS_START = 30;\n\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\n\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs)\n        public\n        view\n        override\n        returns (bool verified)\n    {\n        // Calculate expected proof size based on $LOG_N\n        uint256 expectedProofSize = calculateProofSize($LOG_N);\n\n        // Check the received proof is the expected size where each field element is 32 bytes\n        if (proof.length != expectedProofSize * 32) {\n            revert ProofLengthWrongWithLogN($LOG_N, proof.length, expectedProofSize * 32);\n        }\n\n        Honk.VerificationKey memory vk = loadVerificationKey();\n        Honk.ZKProof memory p = ZKTranscriptLib.loadProof(proof, $LOG_N);\n\n        if (publicInputs.length != vk.publicInputsSize - PAIRING_POINTS_SIZE) {\n            revert PublicInputsLengthWrong();\n        }\n\n        // Generate the fiat shamir challenges for the whole protocol\n        ZKTranscript memory t =\n            ZKTranscriptLib.generateTranscript(p, publicInputs, $VK_HASH, $NUM_PUBLIC_INPUTS, $LOG_N);\n\n        // Derive public input delta\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\n            publicInputs,\n            p.pairingPointObject,\n            t.relationParameters.beta,\n            t.relationParameters.gamma, /*pubInputsOffset=*/\n            1\n        );\n\n        // Sumcheck\n        if (!verifySumcheck(p, t)) revert SumcheckFailed();\n\n        if (!verifyShplemini(p, vk, t)) revert ShpleminiFailed();\n\n        verified = true;\n    }\n\n    uint256 constant PERMUTATION_ARGUMENT_VALUE_SEPARATOR = 1 << 28;\n\n    function computePublicInputDelta(\n        bytes32[] memory publicInputs,\n        Fr[PAIRING_POINTS_SIZE] memory pairingPointObject,\n        Fr beta,\n        Fr gamma,\n        uint256 offset\n    ) internal view returns (Fr publicInputDelta) {\n        Fr numerator = Fr.wrap(1);\n        Fr denominator = Fr.wrap(1);\n\n        Fr numeratorAcc = gamma + (beta * FrLib.from(PERMUTATION_ARGUMENT_VALUE_SEPARATOR + offset));\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\n\n        {\n            for (uint256 i = 0; i < $NUM_PUBLIC_INPUTS - PAIRING_POINTS_SIZE; i++) {\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\n\n                numerator = numerator * (numeratorAcc + pubInput);\n                denominator = denominator * (denominatorAcc + pubInput);\n\n                numeratorAcc = numeratorAcc + beta;\n                denominatorAcc = denominatorAcc - beta;\n            }\n\n            for (uint256 i = 0; i < PAIRING_POINTS_SIZE; i++) {\n                Fr pubInput = pairingPointObject[i];\n\n                numerator = numerator * (numeratorAcc + pubInput);\n                denominator = denominator * (denominatorAcc + pubInput);\n\n                numeratorAcc = numeratorAcc + beta;\n                denominatorAcc = denominatorAcc - beta;\n            }\n        }\n\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\n        publicInputDelta = FrLib.div(numerator, denominator);\n    }\n\n    function verifySumcheck(Honk.ZKProof memory proof, ZKTranscript memory tp) internal view returns (bool verified) {\n        Fr roundTargetSum = tp.libraChallenge * proof.libraSum; // default 0\n        Fr powPartialEvaluation = Fr.wrap(1);\n\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\n        for (uint256 round; round < $LOG_N; ++round) {\n            Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\n            Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\n            if (totalSum != roundTargetSum) revert SumcheckFailed();\n\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\n\n            // Update the round target for the next rounf\n            roundTargetSum = computeNextTargetSum(roundUnivariate, roundChallenge);\n            powPartialEvaluation =\n                powPartialEvaluation * (Fr.wrap(1) + roundChallenge * (tp.gateChallenges[round] - Fr.wrap(1)));\n        }\n\n        // Last round\n        Fr grandHonkRelationSum = RelationsLib.accumulateRelationEvaluations(\n            proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation\n        );\n\n        Fr evaluation = Fr.wrap(1);\n        for (uint256 i = 2; i < $LOG_N; i++) {\n            evaluation = evaluation * tp.sumCheckUChallenges[i];\n        }\n\n        grandHonkRelationSum =\n            grandHonkRelationSum * (Fr.wrap(1) - evaluation) + proof.libraEvaluation * tp.libraChallenge;\n        verified = (grandHonkRelationSum == roundTargetSum);\n    }\n\n    // Return the new target sum for the next sumcheck round\n    function computeNextTargetSum(Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\n        internal\n        view\n        returns (Fr targetSum)\n    {\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000009d80),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000005a0),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000240),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000005a0),\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000009d80)\n        ];\n\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\n\n        // Performing Barycentric evaluations\n        // Compute B(x)\n        Fr numeratorValue = Fr.wrap(1);\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\n        }\n\n        Fr[ZK_BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            denominatorInverses[i] = FrLib.invert(BARYCENTRIC_LAGRANGE_DENOMINATORS[i] * (roundChallenge - Fr.wrap(i)));\n        }\n\n        for (uint256 i = 0; i < ZK_BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\n            targetSum = targetSum + roundUnivariates[i] * denominatorInverses[i];\n        }\n\n        // Scale the sum by the value of B(x)\n        targetSum = targetSum * numeratorValue;\n    }\n\n    uint256 constant LIBRA_COMMITMENTS = 3;\n    uint256 constant LIBRA_EVALUATIONS = 4;\n    uint256 constant LIBRA_UNIVARIATES_LENGTH = 9;\n\n    struct PairingInputs {\n        Honk.G1Point P_0;\n        Honk.G1Point P_1;\n    }\n\n    function verifyShplemini(Honk.ZKProof memory proof, Honk.VerificationKey memory vk, ZKTranscript memory tp)\n        internal\n        view\n        returns (bool verified)\n    {\n        CommitmentSchemeLib.ShpleminiIntermediates memory mem; // stack\n\n        // - Compute vector (r, r², ... , r²⁽ⁿ⁻¹⁾), where n = log_circuit_size\n        Fr[] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR, $LOG_N);\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\n        Fr[] memory scalars = new Fr[](NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3);\n        Honk.G1Point[] memory commitments = new Honk.G1Point[](NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3);\n\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\n\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\n        mem.shiftedScalar =\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\n\n        scalars[0] = Fr.wrap(1);\n        commitments[0] = proof.shplonkQ;\n\n        /* Batch multivariate opening claims, shifted and unshifted\n        * The vector of scalars is populated as follows:\n        * \\f[\n        * \\left(\n        * - \\left(\\frac{1}{z-r} + \\nu \\times \\frac{1}{z+r}\\right),\n        * \\ldots,\n        * - \\rho^{i+k-1} \\times \\left(\\frac{1}{z-r} + \\nu \\times \\frac{1}{z+r}\\right),\n        * - \\rho^{i+k} \\times \\frac{1}{r} \\times \\left(\\frac{1}{z-r} - \\nu \\times \\frac{1}{z+r}\\right),\n        * \\ldots,\n        * - \\rho^{k+m-1} \\times \\frac{1}{r} \\times \\left(\\frac{1}{z-r} - \\nu \\times \\frac{1}{z+r}\\right)\n        * \\right)\n        * \\f]\n        *\n        * The following vector is concatenated to the vector of commitments:\n        * \\f[\n        * f_0, \\ldots, f_{m-1}, f_{\\text{shift}, 0}, \\ldots, f_{\\text{shift}, k-1}\n        * \\f]\n        *\n        * Simultaneously, the evaluation of the multilinear polynomial\n        * \\f[\n        * \\sum \\rho^i \\cdot f_i + \\sum \\rho^{i+k} \\cdot f_{\\text{shift}, i}\n        * \\f]\n        * at the challenge point \\f$ (u_0,\\ldots, u_{n-1}) \\f$ is computed.\n        *\n        * This approach minimizes the number of iterations over the commitments to multilinear polynomials\n        * and eliminates the need to store the powers of \\f$ \\rho \\f$.\n        */\n        mem.batchedEvaluation = proof.geminiMaskingEval;\n        mem.batchingChallenge = tp.rho;\n        mem.unshiftedScalarNeg = mem.unshiftedScalar.neg();\n        mem.shiftedScalarNeg = mem.shiftedScalar.neg();\n\n        scalars[1] = mem.unshiftedScalarNeg;\n        for (uint256 i = 0; i < NUMBER_UNSHIFTED; ++i) {\n            scalars[i + 2] = mem.unshiftedScalarNeg * mem.batchingChallenge;\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i] * mem.batchingChallenge);\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\n        }\n        // g commitments are accumulated at r\n        // For each of the to be shifted commitments perform the shift in place by\n        // adding to the unshifted value.\n        // We do so, as the values are to be used in batchMul later, and as\n        // `a * c + b * c = (a + b) * c` this will allow us to reduce memory and compute.\n        // Applied to w1, w2, w3, w4 and zPerm\n        for (uint256 i = 0; i < NUMBER_TO_BE_SHIFTED; ++i) {\n            uint256 scalarOff = i + SHIFTED_COMMITMENTS_START;\n            uint256 evaluationOff = i + NUMBER_UNSHIFTED;\n\n            scalars[scalarOff] = scalars[scalarOff] + (mem.shiftedScalarNeg * mem.batchingChallenge);\n            mem.batchedEvaluation =\n                mem.batchedEvaluation + (proof.sumcheckEvaluations[evaluationOff] * mem.batchingChallenge);\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\n        }\n\n        commitments[1] = proof.geminiMaskingPoly;\n\n        commitments[2] = vk.qm;\n        commitments[3] = vk.qc;\n        commitments[4] = vk.ql;\n        commitments[5] = vk.qr;\n        commitments[6] = vk.qo;\n        commitments[7] = vk.q4;\n        commitments[8] = vk.qLookup;\n        commitments[9] = vk.qArith;\n        commitments[10] = vk.qDeltaRange;\n        commitments[11] = vk.qElliptic;\n        commitments[12] = vk.qMemory;\n        commitments[13] = vk.qNnf;\n        commitments[14] = vk.qPoseidon2External;\n        commitments[15] = vk.qPoseidon2Internal;\n        commitments[16] = vk.s1;\n        commitments[17] = vk.s2;\n        commitments[18] = vk.s3;\n        commitments[19] = vk.s4;\n        commitments[20] = vk.id1;\n        commitments[21] = vk.id2;\n        commitments[22] = vk.id3;\n        commitments[23] = vk.id4;\n        commitments[24] = vk.t1;\n        commitments[25] = vk.t2;\n        commitments[26] = vk.t3;\n        commitments[27] = vk.t4;\n        commitments[28] = vk.lagrangeFirst;\n        commitments[29] = vk.lagrangeLast;\n\n        // Accumulate proof points\n        commitments[30] = proof.w1;\n        commitments[31] = proof.w2;\n        commitments[32] = proof.w3;\n        commitments[33] = proof.w4;\n        commitments[34] = proof.zPerm;\n        commitments[35] = proof.lookupInverses;\n        commitments[36] = proof.lookupReadCounts;\n        commitments[37] = proof.lookupReadTags;\n\n        /* Batch gemini claims from the prover\n         * place the commitments to gemini aᵢ to the vector of commitments, compute the contributions from\n         * aᵢ(−r²ⁱ) for i=1, … , n−1 to the constant term accumulator, add corresponding scalars\n         *\n         * 1. Moves the vector\n         * \\f[\n         * \\left( \\text{com}(A_1), \\text{com}(A_2), \\ldots, \\text{com}(A_{n-1}) \\right)\n         * \\f]\n        * to the 'commitments' vector.\n        *\n        * 2. Computes the scalars:\n        * \\f[\n        * \\frac{\\nu^{2}}{z + r^2}, \\frac{\\nu^3}{z + r^4}, \\ldots, \\frac{\\nu^{n-1}}{z + r^{2^{n-1}}}\n        * \\f]\n        * and places them into the 'scalars' vector.\n        *\n        * 3. Accumulates the summands of the constant term:\n         * \\f[\n         * \\sum_{i=2}^{n-1} \\frac{\\nu^{i} \\cdot A_i(-r^{2^i})}{z + r^{2^i}}\n         * \\f]\n         * and adds them to the 'constant_term_accumulator'.\n         */\n\n        // Add contributions from A₀(r) and A₀(-r) to constant_term_accumulator:\n        // Compute the evaluations Aₗ(r^{2ˡ}) for l = 0, ..., $LOG_N - 1\n        Fr[] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\n            tp.sumCheckUChallenges,\n            mem.batchedEvaluation,\n            proof.geminiAEvaluations,\n            powers_of_evaluation_challenge,\n            $LOG_N\n        );\n\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\n        mem.constantTermAccumulator =\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\n\n        mem.batchingChallenge = tp.shplonkNu.sqr();\n        uint256 boundary = NUMBER_UNSHIFTED + 2;\n\n        // Compute Shplonk constant term contributions from Aₗ(± r^{2ˡ}) for l = 1, ..., m-1;\n        // Compute scalar multipliers for each fold commitment\n        for (uint256 i = 0; i < $LOG_N - 1; ++i) {\n            bool dummy_round = i >= ($LOG_N - 1);\n\n            if (!dummy_round) {\n                // Update inverted denominators\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\n\n                // Compute the scalar multipliers for Aₗ(± r^{2ˡ}) and [Aₗ]\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\n                scalars[boundary + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\n\n                // Accumulate the const term contribution given by\n                // v^{2l} * Aₗ(r^{2ˡ}) /(z-r^{2^l}) + v^{2l+1} * Aₗ(-r^{2ˡ}) /(z+ r^{2^l})\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\n            }\n            // Update the running power of v\n            mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\n\n            commitments[boundary + i] = proof.geminiFoldComms[i];\n        }\n\n        boundary += $LOG_N - 1;\n\n        // Finalize the batch opening claim\n        mem.denominators[0] = Fr.wrap(1).div(tp.shplonkZ - tp.geminiR);\n        mem.denominators[1] = Fr.wrap(1).div(tp.shplonkZ - SUBGROUP_GENERATOR * tp.geminiR);\n        mem.denominators[2] = mem.denominators[0];\n        mem.denominators[3] = mem.denominators[0];\n\n        mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\n        for (uint256 i = 0; i < LIBRA_EVALUATIONS; i++) {\n            Fr scalingFactor = mem.denominators[i] * mem.batchingChallenge;\n            mem.batchingScalars[i] = scalingFactor.neg();\n            mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu;\n            mem.constantTermAccumulator = mem.constantTermAccumulator + scalingFactor * proof.libraPolyEvals[i];\n        }\n        scalars[boundary] = mem.batchingScalars[0];\n        scalars[boundary + 1] = mem.batchingScalars[1] + mem.batchingScalars[2];\n        scalars[boundary + 2] = mem.batchingScalars[3];\n\n        for (uint256 i = 0; i < LIBRA_COMMITMENTS; i++) {\n            commitments[boundary++] = proof.libraCommitments[i];\n        }\n\n        commitments[boundary] = Honk.G1Point({x: 1, y: 2});\n        scalars[boundary++] = mem.constantTermAccumulator;\n\n        if (!checkEvalsConsistency(proof.libraPolyEvals, tp.geminiR, tp.sumCheckUChallenges, proof.libraEvaluation)) {\n            revert ConsistencyCheckFailed();\n        }\n\n        Honk.G1Point memory quotient_commitment = proof.kzgQuotient;\n\n        commitments[boundary] = quotient_commitment;\n        scalars[boundary] = tp.shplonkZ; // evaluation challenge\n\n        PairingInputs memory pair;\n        pair.P_0 = batchMul(commitments, scalars);\n        pair.P_1 = negateInplace(quotient_commitment);\n\n        // Aggregate pairing points\n        Fr recursionSeparator = generateRecursionSeparator(proof.pairingPointObject, pair.P_0, pair.P_1);\n        (Honk.G1Point memory P_0_other, Honk.G1Point memory P_1_other) =\n            convertPairingPointsToG1(proof.pairingPointObject);\n\n        // Validate the points from the proof are on the curve\n        validateOnCurve(P_0_other);\n        validateOnCurve(P_1_other);\n\n        // accumulate with aggregate points in proof\n        pair.P_0 = mulWithSeperator(pair.P_0, P_0_other, recursionSeparator);\n        pair.P_1 = mulWithSeperator(pair.P_1, P_1_other, recursionSeparator);\n\n        return pairing(pair.P_0, pair.P_1);\n    }\n\n    struct SmallSubgroupIpaIntermediates {\n        Fr[SUBGROUP_SIZE] challengePolyLagrange;\n        Fr challengePolyEval;\n        Fr lagrangeFirst;\n        Fr lagrangeLast;\n        Fr rootPower;\n        Fr[SUBGROUP_SIZE] denominators; // this has to disappear\n        Fr diff;\n    }\n\n    function checkEvalsConsistency(\n        Fr[LIBRA_EVALUATIONS] memory libraPolyEvals,\n        Fr geminiR,\n        Fr[CONST_PROOF_SIZE_LOG_N] memory uChallenges,\n        Fr libraEval\n    ) internal view returns (bool check) {\n        Fr one = Fr.wrap(1);\n        Fr vanishingPolyEval = geminiR.pow(SUBGROUP_SIZE) - one;\n        if (vanishingPolyEval == Fr.wrap(0)) {\n            revert GeminiChallengeInSubgroup();\n        }\n\n        SmallSubgroupIpaIntermediates memory mem;\n        mem.challengePolyLagrange[0] = one;\n        for (uint256 round = 0; round < $LOG_N; round++) {\n            uint256 currIdx = 1 + LIBRA_UNIVARIATES_LENGTH * round;\n            mem.challengePolyLagrange[currIdx] = one;\n            for (uint256 idx = currIdx + 1; idx < currIdx + LIBRA_UNIVARIATES_LENGTH; idx++) {\n                mem.challengePolyLagrange[idx] = mem.challengePolyLagrange[idx - 1] * uChallenges[round];\n            }\n        }\n\n        mem.rootPower = one;\n        mem.challengePolyEval = Fr.wrap(0);\n        for (uint256 idx = 0; idx < SUBGROUP_SIZE; idx++) {\n            mem.denominators[idx] = mem.rootPower * geminiR - one;\n            mem.denominators[idx] = mem.denominators[idx].invert();\n            mem.challengePolyEval = mem.challengePolyEval + mem.challengePolyLagrange[idx] * mem.denominators[idx];\n            mem.rootPower = mem.rootPower * SUBGROUP_GENERATOR_INVERSE;\n        }\n\n        Fr numerator = vanishingPolyEval * Fr.wrap(SUBGROUP_SIZE).invert();\n        mem.challengePolyEval = mem.challengePolyEval * numerator;\n        mem.lagrangeFirst = mem.denominators[0] * numerator;\n        mem.lagrangeLast = mem.denominators[SUBGROUP_SIZE - 1] * numerator;\n\n        mem.diff = mem.lagrangeFirst * libraPolyEvals[2];\n\n        mem.diff = mem.diff\n            + (geminiR - SUBGROUP_GENERATOR_INVERSE)\n                * (libraPolyEvals[1] - libraPolyEvals[2] - libraPolyEvals[0] * mem.challengePolyEval);\n        mem.diff = mem.diff + mem.lagrangeLast * (libraPolyEvals[2] - libraEval) - vanishingPolyEval * libraPolyEvals[3];\n\n        check = mem.diff == Fr.wrap(0);\n    }\n\n    // This implementation is the same as above with different constants\n    function batchMul(Honk.G1Point[] memory base, Fr[] memory scalars)\n        internal\n        view\n        returns (Honk.G1Point memory result)\n    {\n        uint256 limit = NUMBER_UNSHIFTED + $LOG_N + LIBRA_COMMITMENTS + 3;\n\n        // Validate all points are on the curve\n        for (uint256 i = 0; i < limit; ++i) {\n            validateOnCurve(base[i]);\n        }\n\n        bool success = true;\n        assembly {\n            let free := mload(0x40)\n\n            let count := 0x01\n            for {} lt(count, add(limit, 1)) { count := add(count, 1) } {\n                // Get loop offsets\n                let base_base := add(base, mul(count, 0x20))\n                let scalar_base := add(scalars, mul(count, 0x20))\n\n                mstore(add(free, 0x40), mload(mload(base_base)))\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\n                // Add scalar\n                mstore(add(free, 0x80), mload(scalar_base))\n\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\n                // accumulator = accumulator + accumulator_2\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\n            }\n\n            // Return the result\n            mstore(result, mload(free))\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\n        }\n\n        require(success, ShpleminiFailed());\n    }\n}\n\ncontract privateTransfer2InVerifier is BaseZKHonkVerifier(N, LOG_N, VK_HASH, NUMBER_OF_PUBLIC_INPUTS) {\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\n       return HonkVerificationKey.loadVerificationKey();\n    }\n}\n"
      },
      "project/contracts/WormholeToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\n\n\n// @TODO \npragma solidity ^0.8.3;\n\nimport {ERC20WithWormHoleMerkleTree} from \"./ERC20WithWormHoleMerkleTree.sol\"; \nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {LeanIMTData, Hasher} from \"zk-kit-lean-imt-custom-hash/InternalLeanIMT.sol\";\nimport {leanIMTPoseidon2} from \"./leanIMTPoseidon2.sol\";\nimport {IVerifier} from \"./privateTransfer2InVerifier.sol\";\n\nstruct FeeData {\n    uint256 tokensPerEthPrice;\n    uint256 maxFee; \n    uint256 amountForRecipient;\n    uint256 relayerBonus;\n    uint256 estimatedGasCost; \n    uint256 estimatedPriorityFee;\n    address refundAddress;\n    address relayerAddress;\n}\n\nstruct SignatureInputs {\n    address recipient;\n    uint256 amountToReMint;\n    bytes callData;\n    bool callCanFail;\n    uint256 callValue;\n    bytes[] encryptedTotalSpends;\n}\n\n\nerror VerificationFailed();\n// accountNoteNullifier is indexed so users can search for it and find out the total amount spend, which is needed to make the next spend the next spent\n// the nullifiers mapping contains the blockNumber it was nullified at. This can be used for a faster syncing strategy\nevent Nullified(uint256 indexed nullifier, bytes encryptedTotalSpends);\nevent StorageRootAdded(uint256 blockNumber);\nevent NewLeaf(uint256 leaf);\n\ncontract WormholeToken is ERC20WithWormHoleMerkleTree, EIP712 {\n    // this is so leafs from received balance and spent balance wont get mixed up\n    uint256 constant public TOTAL_BURNED_DOMAIN = 0x544f54414c5f4255524e4544; //  UTF8(\"TOTAL_BURNED\").toHex()\n    address internal constant POSEIDON2_ADDRESS = 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C; // yul-recompile-200: 0xb41072641808e6186eF5246fE1990e46EB45B65A gas: 62572, huff: 0x382ABeF9789C1B5FeE54C72Bd9aaf7983726841C gas:39 627, yul-lib: 0x925e05cfb89f619BE3187Bf13D355A6D1864D24D,\n\n    // @notice accountNoteNullifier = poseidon(nonce, viewingKey)\n    // @notice accountNoteHash = poseidon(totalAmountSpent, nonce, viewingKey)\n    mapping (uint256 => uint256) public nullifiers; // accountNoteNullifier -> blockNumber\n    mapping (uint256 => bool) public roots;\n\n    uint40 currentLeafIndex;\n\n    uint256 public amountFreeTokens = 1000000*10**decimals();\n    uint256 public decimalsTokenPrice = 8;\n\n    address public privateTransferVerifier2In;\n    address public privateTransferVerifier100In;\n    LeanIMTData public tree;\n    \n    /**\n     * \n     */\n    constructor(address _privateTransferVerifier2In, address _privateTransferVerifier100In)\n        ERC20WithWormHoleMerkleTree(\"zkwormholes-token\", \"WRMHL\")\n        EIP712(\"zkwormholes-token\", \"1\") \n    {\n        privateTransferVerifier2In = _privateTransferVerifier2In;\n        privateTransferVerifier100In = _privateTransferVerifier100In;\n    }\n\n    function treeSize() public view  returns (uint256) {\n        return tree.size;\n    }\n\n    bytes32 private constant _RE_MINT_TYPEHASH =\n        keccak256(\n            \"privateReMint(address _recipient,uint256 _amount,bytes _callData,bool _callCanFail,uint256 _callValue,bytes[] _encryptedTotalSpends)\"\n        );\n\n    bytes32 private constant _RE_MINT_RELAYER_TYPEHASH =\n        keccak256(\n            \"privateReMintRelayer(address _recipient,uint256 _amount,bytes _callData,bool _callCanFail,uint256 _callValue,bytes[] _encryptedTotalSpends,FeeData _feeData)FeeData(uint256 tokensPerEthPrice,uint256 maxFee,uint256 amountForRecipient,uint256 relayerBonus,uint256 estimatedGasCost,uint256 estimatedPriorityFee,address refundAddress,address relayerAddress)\"\n        );\n\n    bytes32 private constant _FEEDATA_TYPEHASH = keccak256(\n        \"FeeData(uint256 tokensPerEthPrice,uint256 maxFee,uint256 amountForRecipient,uint256 relayerBonus,uint256 estimatedGasCost,uint256 estimatedPriorityFee,address refundAddress,address relayerAddress)\"\n    );\n\n    function _hashBytesArray(bytes[] memory items) internal pure returns (bytes32) {\n        bytes32[] memory hashes = new bytes32[](items.length);\n        for (uint256 i = 0; i < items.length; i++) {\n            hashes[i] = keccak256(items[i]);\n        }\n        return keccak256(abi.encodePacked(hashes));\n    }\n\n    function _hashFeeData(FeeData memory _feeData) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            _FEEDATA_TYPEHASH,\n            _feeData.tokensPerEthPrice,\n            _feeData.maxFee,\n            _feeData.amountForRecipient,\n            _feeData.relayerBonus,\n            _feeData.estimatedGasCost,\n            _feeData.estimatedPriorityFee,\n            _feeData.refundAddress,\n            _feeData.relayerAddress\n        ));\n    }\n\n    function _hashSignatureInputs(\n        SignatureInputs calldata _signatureInputs\n    ) public view returns (bytes32) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _RE_MINT_TYPEHASH,\n                _signatureInputs.recipient,\n                _signatureInputs.amountToReMint,\n                keccak256(_signatureInputs.callData),\n                _signatureInputs.callCanFail,\n                _signatureInputs.callValue,\n                _hashBytesArray(_signatureInputs.encryptedTotalSpends)\n            )\n        );\n        return _hashTypedDataV4(structHash);\n    }\n\n    function _hashSignatureInputsRelayer(\n        SignatureInputs calldata _signatureInputs,\n        FeeData calldata _feeData\n    ) public view returns (bytes32) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _RE_MINT_RELAYER_TYPEHASH,\n                _signatureInputs.recipient,\n                _signatureInputs.amountToReMint,\n                keccak256(_signatureInputs.callData),\n                _signatureInputs.callCanFail,\n                _signatureInputs.callValue,\n                _hashBytesArray(_signatureInputs.encryptedTotalSpends),\n                _hashFeeData(_feeData)\n            )\n        );\n        return _hashTypedDataV4(structHash);\n    }\n\n    function hashPoseidon2T3(uint256[3] memory input) public view returns (uint256) {\n        (, bytes memory result) = POSEIDON2_ADDRESS.staticcall(abi.encode(input));\n        return uint256(bytes32(result));\n    }\n\n    function hashPoseidon2T6(uint256[6] memory input) public view returns (uint256) {\n        (, bytes memory result) = POSEIDON2_ADDRESS.staticcall(abi.encode(input));\n        return uint256(bytes32(result));\n    }\n\n    // The function used for hashing the balanceLeaf\n    function hashBalanceLeaf(address _to, uint256 _newBalance) private view returns (uint256) {\n        uint256[3] memory input;\n        input[0] = _addressToUint256(_to);\n        input[1] = _newBalance;\n        input[2] = TOTAL_BURNED_DOMAIN;\n        return hashPoseidon2T3(input);\n    }\n\n    function _insertInMerkleTree(uint256 leaf) internal {\n        leanIMTPoseidon2.insert(tree, leaf);\n        emit NewLeaf(leaf);\n        roots[leanIMTPoseidon2.root(tree)] = true;\n    }\n\n    function _insertManyInMerkleTree(uint256[] memory leafs) override internal {\n        leanIMTPoseidon2.insertMany(tree, leafs);\n        for (uint i = 0; i < leafs.length; i++) {\n            emit NewLeaf(leafs[i]);\n        }\n        roots[leanIMTPoseidon2.root(tree)] = true;\n    }\n\n\n    function _updateBalanceInMerkleTree(address _to, uint256 _newBalance) override internal {        \n        // tx.origin is always a EOA, so no need to do a merkle tree insertion, saves gas on defi interactions for example someone buying the token\n        if (tx.origin == _to ) {return;}\n        //to.code.length check is removed since it creates  perverse incentives\n        //if (tx.origin == _to || _to.code.length > 0) {return;}\n        \n        // @WARNING you might be tempted to create smarter ways to check if its for sure not a private address. \n        // Example: check that `_to` is an smart contract (_to.code.length > 0) or store the tx.origin address somewhere in a mapping like \"allKnownEOAs\" to check to save gas on future transfers. \n        // Registering your EOA in \"allKnownEOAs\" / using smart contract accounts saves you on gas in the future. But that creates perverse incentives that break plausible deniability.\n        // doing so will cause every EOA owner to register in \"allKnownEOAs\" / use smart contract accounts and then there is no plausible deniability left since it's now \"looks weird\" to not do that.\n        // Even doing account != contract is bad in that sense. Since account based wallets would also save on gas.\n        \n\n        uint256 leaf = hashBalanceLeaf(_to, _newBalance);\n\n        if (leanIMTPoseidon2.has(tree,leaf)) {\n            // it's already in there! (rarely happens but can happen if an EOA receives an amount that results in a balance it had before)\n            return;\n        } else {\n            _insertInMerkleTree(leaf);\n        }\n    }\n\n    function _updateBalanceInMerkleTree(address _to, uint256 _newBalance, uint256[] memory _accountNoteHashes) override internal {        \n        // check if account == tx.origin since in that case it's not a private address.\n        // and we only need to insert _accountNoteHash\n        // tx.origin is always a EOA\n        if (tx.origin == _to ) {\n            _insertManyInMerkleTree(_accountNoteHashes);\n        } else {\n            uint256 accountBalanceLeaf = hashBalanceLeaf(_to, _newBalance);\n\n            if (leanIMTPoseidon2.has(tree,accountBalanceLeaf)) {\n                // accountBalanceLeaf is already in there! so we only insert _accountNoteHash\n                // note: _accountNoteHash is always unique, remember it is poseidon(totalSpend,viewingKey,nonce)\n                _insertManyInMerkleTree( _accountNoteHashes);\n            } else {\n                uint256[] memory leafs = new uint256[](1+_accountNoteHashes.length);\n                leafs[0] = accountBalanceLeaf;\n                for (uint i = 0; i < _accountNoteHashes.length; i++) {\n                    leafs[i+1] = _accountNoteHashes[i];\n                }\n                _insertManyInMerkleTree(leafs);\n            }\n        }\n    }\n\n    function _updateBalanceInMerkleTree(address[] memory _accounts, uint256[] memory _newBalances, uint256[] memory _accountNoteHashes) override internal {        \n        // check if account == tx.origin since in that case it's not a private address.\n        // and we only need to insert _accountNoteHash\n        // tx.origin is always a EOA\n        uint256[] memory leafs = new uint256[](_accounts.length + _accountNoteHashes.length);\n\n        uint256 leafsIndex = 0;\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            if (tx.origin != _accounts[i]) {\n                uint256 accountBalanceLeaf = hashBalanceLeaf(_accounts[i], _newBalances[i]);\n                // only happens when someone receives an amount that exactly adds up to a balance that results a balance that had before\n                // very rare don't really want to check for this but leanIMT wont allow me to insert the same leaf twice\n                if(leanIMTPoseidon2.has(tree,accountBalanceLeaf)) {\n                    leafs[leafsIndex++] = accountBalanceLeaf;\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < _accountNoteHashes.length; i++) {\n            leafs[leafsIndex++] = _accountNoteHashes[i];\n        }\n\n        // Trim array to actual length\n        assembly { mstore(leafs, leafsIndex) }\n\n        _insertManyInMerkleTree(leafs);\n    }\n\n    function root() public view returns(uint256){\n        return leanIMTPoseidon2.root(tree);\n    }\n\n    // @WARNING remove this in prod, anyone can mint for free!\n    function getFreeTokens(address _to) public {\n        _mint(_to, amountFreeTokens);\n    }\n\n\n    function _addressToUint256(address _address) private pure returns (uint256) {\n        return uint256(uint160(bytes20(_address)));\n    }\n\n    function _formatPublicInputs(\n        uint256 _root,\n        uint256 _amount,\n        bytes32 _signatureHash,\n        uint256[] memory _accountNoteHashes,        // a commitment inserted in the merkle tree, tracks how much is spend after this transfer hash(prev_total_spent+amount, prev_account_nonce, viewing_key)\n        uint256[] memory _accountNoteNullifiers   // nullifies the previous account_note.  hash(prev_account_nonce, viewing_key)\n    ) public pure returns (bytes32[] memory) {\n        if (_accountNoteHashes.length == 2) {\n            bytes32[] memory publicInputs = new bytes32[](34 + 2*2);\n\n            publicInputs[0] = bytes32(_root);\n            publicInputs[1] = bytes32(uint256(_amount));\n            uint256 signatureHashOffset = 2;\n            for (uint256 i = 0; i < 32; i++) {\n                publicInputs[i + signatureHashOffset] = bytes32(uint256(uint8(_signatureHash[i])));\n            }\n\n            uint256 noteHashesOffSet = 32 + signatureHashOffset;\n            for (uint256 i = 0; i < _accountNoteHashes.length ; i++) {\n                publicInputs[2 * i + noteHashesOffSet] = bytes32(_accountNoteHashes[i]);\n                publicInputs[2 * i + noteHashesOffSet + 1] = bytes32(_accountNoteNullifiers[i]);\n            }\n\n            return publicInputs;\n\n        } else if (_accountNoteHashes.length == 100) {\n            bytes32[] memory publicInputs = new bytes32[](34 + 100*2);\n\n            publicInputs[0] = bytes32(_root);\n            publicInputs[1] = bytes32(uint256(_amount));\n            uint256 signatureHashOffset = 2;\n            for (uint256 i = 0; i < 32; i++) {\n                publicInputs[i + signatureHashOffset] = bytes32(uint256(uint8(_signatureHash[i])));\n            }\n\n            uint256 noteHashesOffSet = 32 + signatureHashOffset;\n            for (uint256 i = 0; i < _accountNoteHashes.length ; i++) {\n                publicInputs[2 * i + noteHashesOffSet] = bytes32(_accountNoteHashes[i]);\n                publicInputs[2 * i + noteHashesOffSet + 1] = bytes32(_accountNoteNullifiers[i]);\n            }\n\n            return publicInputs;\n        } else {\n            revert(\"amount of note hashes not supported\");\n        }\n\n    }\n\n\n    function _verifyReMint(\n        uint256 _amount,\n        uint256[] memory _accountNoteHashes,         // a commitment inserted in the merkle tree, tracks how much is spend after this transfer hash(prev_total_spent+amount, prev_account_nonce, viewing_key)\n        uint256[] memory _accountNoteNullifiers,     // nullifies the previous account_note.  hash(prev_account_nonce, viewing_key)\n        uint256 _root,\n        bytes calldata _snarkProof,\n        bytes[] calldata _encryptedTotalSpends,\n        bytes32 signatureHash\n    ) public {\n        require(roots[_root], \"invalid root\");\n        // check and store nullifiers, emit Nullified events with _encryptedTotalSpends blobs\n        for (uint256 i = 0; i < _accountNoteNullifiers.length; i++) {\n            uint256 _accountNoteNullifier = _accountNoteNullifiers[i];\n            require(nullifiers[_accountNoteNullifier] == uint256(0), \"nullifier already exist\");\n            nullifiers[_accountNoteNullifier] = block.number;\n            emit Nullified(_accountNoteNullifier, _encryptedTotalSpends[i]); \n        }\n\n        // format public inputs and verify proof \n        bytes32[] memory publicInputs = _formatPublicInputs(_root, _amount, signatureHash, _accountNoteHashes, _accountNoteNullifiers);\n        if (_accountNoteNullifiers.length == 2) {\n            if (!IVerifier(privateTransferVerifier2In).verify(_snarkProof, publicInputs)) {\n                revert VerificationFailed();\n            }\n        } else if (_accountNoteNullifiers.length == 100) {\n            if (!IVerifier(privateTransferVerifier100In).verify(_snarkProof, publicInputs)) {\n                revert VerificationFailed();\n            }\n        } else {\n            revert(\"amount of note hashes not supported\");\n        }\n    }\n\n    function privateReMint(\n        uint256[] memory _accountNoteHashes,         // a commitment inserted in the merkle tree, tracks how much is spend after this transfer hash(prev_total_spent+amount, prev_account_nonce, viewing_key)\n        uint256[] memory _accountNoteNullifiers,     // nullifies the previous account_note.  hash(prev_account_nonce, viewing_key)\n        uint256 _root,\n        bytes calldata _snarkProof,\n        SignatureInputs calldata _signatureInputs\n    ) public {\n        bytes32 _signatureHash = _hashSignatureInputs(_signatureInputs);\n        _verifyReMint(_signatureInputs.amountToReMint, _accountNoteHashes, _accountNoteNullifiers, _root, _snarkProof, _signatureInputs.encryptedTotalSpends, _signatureHash);\n        \n        // modified version of _mint that also inserts noteHashes and does not modify total supply!\n        _reMint(_signatureInputs.recipient, _signatureInputs.amountToReMint, _accountNoteHashes);\n        _processCall(_signatureInputs);\n    }\n\n    function _calculateFee(FeeData calldata _feeData, uint256 _amountToReMint) public view returns(uint256,uint256) {\n        uint256 _feeInWei =  _feeData.estimatedGasCost * (block.basefee + _feeData.estimatedPriorityFee);\n        uint256 _fee = ((_feeInWei * _feeData.tokensPerEthPrice) / 10**decimalsTokenPrice) + _feeData.relayerBonus;\n        require(_fee < _feeData.maxFee, \"relayer fee is too high\");\n        require(_amountToReMint > _fee, \"fee is more then amount being reMinted\");\n        require((_amountToReMint - _fee) >= _feeData.amountForRecipient , \"not enough left after fees for recipient\");\n        uint256 _refundAmount = _feeData.maxFee - _fee;\n        return (_fee, _refundAmount);\n    }\n\n    function privateReMintRelayer(\n        uint256[] memory _accountNoteHashes,         // a commitment inserted in the merkle tree, tracks how much is spend after this transfer hash(prev_total_spent+amount, prev_account_nonce, viewing_key)\n        uint256[] memory _accountNoteNullifiers,     // nullifies the previous account_note.  hash(prev_account_nonce, viewing_key)\n        uint256 _root,\n        bytes calldata _snarkProof,\n        SignatureInputs calldata _signatureInputs,\n        FeeData calldata _feeData\n    ) public {\n        (uint256 _fee, uint256 _refundAmount) = _calculateFee(_feeData, _signatureInputs.amountToReMint);\n        bytes32 _signatureHash = _hashSignatureInputsRelayer(_signatureInputs, _feeData);\n        _verifyReMint(_signatureInputs.amountToReMint, _accountNoteHashes, _accountNoteNullifiers, _root, _snarkProof, _signatureInputs.encryptedTotalSpends, _signatureHash);\n\n        // optional let anyone claim the fee\n        address relayerAddress;\n        if (_feeData.relayerAddress == address(1)) {\n            relayerAddress = msg.sender;\n        } else {\n            relayerAddress = _feeData.relayerAddress;\n        }\n\n        // giga ugly solidity array bs :/\n        address[] memory recipients = new address[](3);\n        recipients[0] = _signatureInputs.recipient;\n        recipients[1] = _feeData.refundAddress;\n        recipients[2] = relayerAddress;\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = _feeData.amountForRecipient;\n        amounts[1] = _refundAmount;\n        amounts[2] = _fee;\n        _reMintBulk(recipients, amounts, _accountNoteHashes);\n        _processCall(_signatureInputs);\n    }\n\n    function _processCall(SignatureInputs calldata _signatureInputs) private {\n        if (_signatureInputs.callData.length != 0 || _signatureInputs.callValue > 0) { \n            (bool success,) = _signatureInputs.recipient.call{value:_signatureInputs.callValue}(_signatureInputs.callData);\n            require(_signatureInputs.callCanFail || success, \"call failed and was not allowed to fail\");\n        }\n    }\n}"
      }
    }
  }
}